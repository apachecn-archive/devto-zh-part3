# 递归方法

> 原文：<https://dev.to/kevinsarav/recursive-method-2k9o>

在这篇文章中，我将回顾我刚刚完成的一个项目。它使用递归来找出不同的硬币组合，可以从一个给定数量的美分。我将回顾这个项目带来的挑战。

我这个项目的第一块绊脚石是让递归工作。出于某种原因，每次我试图做递归时，我都会陷入一个无限循环，即使我试图确保递归包含一个递减的值。我推断这可能是因为 Java 是通过值传递而不是通过引用传递，因为我试图使用从方法外部获取的值。我通过用我的类创建一个对象并使用它来解决这个问题。

我的下一个绊脚石是如何进行这项计划。第一个合乎逻辑的步骤是以一个合乎逻辑的人的方式把硬币分开。你会首先想要更有价值的硬币。例如，你会选择得到 1 个 25 美分的硬币，而不是 2 个 10 美分的硬币和 1 个 5 美分的硬币。我做了一个单独的方法来达到这个目的。除此之外，我还对那个方法使用了递归。

这种逻辑的主要障碍是在这一点之后做什么。从逻辑上讲，你会想先把五分镍币变成一分镍币，然后把一角硬币变成五分镍币，再把两毛五分硬币变成一角硬币，如此循环往复。我发明了一种方法。这个方法适用于低于 25 美分的所有东西，但是高于 25 美分的任何东西都会导致我得到错误的组合数量。我的结论是，这可能是因为我对如何处理季度的逻辑。我最初是这样做的，一旦 10 美分和 5 美分变成了 1 美分，然后逻辑上我把 25 美分减 1，加 2 个 10 美分和 1 个 5 美分。然而，我的程序无法计算大于当前一角硬币数量的值。例如，如果我把 1 个 25 美分硬币变成 2 个 10 美分硬币和 1 个 5 美分硬币，旁边有 17 个 1 美分硬币，我忘记了 4 个 10 美分硬币和 2 个 1 美分硬币的组合。我的逻辑永远不会把我带回到更高的一角硬币的价值，相反，我只剩下更小的一角和五分硬币的价值。

为了解决这个问题，我首先在便士的数量上加了 25 个便士，这样我就可以先把这些便士变成一角硬币，然后是五分硬币。通过这种方式，我可以计算出有更多一角硬币的组合。然后我把便士除以 10 的结果相加，然后我把便士转换成便士的模数，这样我就得到了余数。然后我对镍币使用同样的逻辑，最后将 25 美分的硬币减 1。

我再次遇到了第一个绊脚石，由于某种原因，我可以不用对象来进行递归。这可能是因为我的变量名相同，这可能会混淆我的程序。不管怎样，我让程序在没有对象的情况下运行。

* * *

在我的下一篇文章中，我希望谈谈我的计算器项目的进展和我的硕士班小组项目的进展。现在学期快结束了，小组项目很快就要到期了，我需要网络开发技能来取得成功。我目前正在 YouTube 上学习 Angular，希望它能给我一个好的开始。