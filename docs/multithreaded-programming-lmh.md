# 多线程编程

> 原文：<https://dev.to/mattcanello/multithreaded-programming-lmh>

# 简介

许多软件开发人员认为多线程编程是一个高级(而且可怕)的话题。因为理解这一点对于在整个软件开发中使用多线程技术来说并不重要，所以一些程序员宁愿跳过底层的复杂性，直接使用多线程技术。

然而，花些时间理解一些概念可以帮助开发人员更好地了解这种编程的各个方面，从而提高编写和阅读这种代码的能力。

在本文中，我打算向读者介绍与这个主题相关的想法，而不是深入到任何语言或平台的细节，而是集中在一般行为上。

这不是给专业人士写的文章。为了大局着想，我会有意简化一些细节。

# 螺纹

在计算机科学中，线程只不过是 CPU 最终将处理的一系列顺序指令流。

操作系统通常负责管理线程。然而，有时运行应用程序的平台(例如 JVM)实现了自己的线程系统，它可以依赖也可以不依赖宿主操作系统。

多线程程序或应用程序是那些在其进程中运行多个线程的程序或应用程序。在现实世界中，基本上都存在。

以图形界面为特色的应用程序通常会保留一个特定的线程来处理用户界面元素。这个线程经常被称为主线程。目标是在运行应用程序内部逻辑时避免阻塞或冻结用户界面。这样，UI 线程的唯一职责就是处理 UI 交互和更新，这样所有其他线程就可以处理这些脏活了。

另一方面，一个进程中有太多的线程可能意味着某个地方出现了瓶颈——虽然不一定与代码有关:例如，对于一个 I/O 密集型系统来说，它可能是一个很慢的磁盘；或者执行 web 请求时的高延迟。

同样重要的是要注意，只有当所有线程都完成时，进程才会真正终止。因此，即使关闭了所有的窗口或屏幕(从而结束了主线程)，只要至少有一个线程还活着，进程就可能继续运行。如果这不是预期的行为，请记住这一点。

现在，多少线程是太多了？多少根线应该足够了？这些问题很难回答。理论上，线程的最大数量应该是运行应用程序的设备中可用 CPU 的数量，以避免上下文切换(不要担心，我们会实现这一点)。当然，如果应用程序是建立在一个框架之上的，那么框架本身需要的线程数量也应该考虑在内。

一个乌托邦式的假设，你可能也会得出这样的结论。打开你的任务管理器，看看你的电脑上有多少线程正在运行。我估计会比它拥有的 CPU 数量多很多。

因此，线程“正确”数量的答案既不是一个固定的数字，甚至也不是一个数学公式；应用程序必须拥有它需要的线程数量。

# 上下文切换

现在，让我们深入了解计算机是如何工作的(这里的“计算机”是指“所有使用 CPU 的电子设备”)；只是为了彻底)。

CPU 被设计用来执行一系列指令。然而，一个 CPU 一次只能处理一个指令流(线程)。那么，如何让四核电脑运行不仅仅是四个线程呢？

操作系统和 CPU 快速遍历所有线程，跨越所有进程，以使所有应用程序看起来都在同时运行。操作系统在所有可用的 CPU 之间分配线程，然后每个 CPU 将在几秒钟内为每个给定的线程运行它能够运行的所有指令。在这些线程之间切换意味着暂停当前线程的执行，并恢复下一个线程的执行。

“上下文切换”是 CPU 从一个线程切换到另一个线程时的动作名称。

显然，这个遍历线程的过程是有代价的。CPU 的使用需要时间。有些指令和操作可以快速运行，有些则较慢。这也意味着电力/电池消耗。这就是密集处理的应用程序会耗尽设备电池的原因。

# 线程池

在创建一个全新的操作系统线程时，你应该小心。它需要内存分配和 CPU 指令来设置和关闭它。

因此，为了更好地处理线程的使用并避免创建新的线程，操作系统或平台考虑了线程池特性，该特性允许应用程序使用已经存在的线程。

这是一种更有效的方式来处理多线程，而不用处理它的创建或销毁。此外，操作系统知道线程池中的某个线程何时不在使用中，因此，它们可以在线程迭代期间自动“跳过”它。

与常规线程不同，线程池线程在主线程完成后不会保留，这使得它特别适用于将随程序一起终止的后台操作。

# 阻塞线程

您可能在某处听说过或读到过不应该阻塞线程。人们愿意大声尖叫，但很少解释原因。

当阻塞一个线程时，你强迫 CPU 尝试运行这个线程，即使它只是在等待什么。这样，代码不仅会降低应用程序的性能，还会降低整个系统的性能。总之就是浪费 CPU 时间。

尽管有时强迫线程在继续前进之前等待某些东西似乎更容易，但这并不值得推荐。这个被阻塞的线程迫使系统在一段时间内不做任何事情，因为它可能正在做其他的事情。

同步操作确实更容易理解和阅读，但是为了可维护性而将所有的异步操作都变成同步操作是非常错误的。我知道在某些语言或平台中以正确的方式处理异步操作可能很痛苦，但这不能成为不处理的借口。

成为一名开发人员的一部分是学习如何处理你正在使用的技术中好的和糟糕的部分。

# 异步

异步方法或函数是依赖于外部事物响应的过程。查询 web 服务、读取文件、等待用户输入交互，所有这些都不依赖于线程，不依赖于 CPU。

以正确的方式实现和利用异步过程的全部意义在于让 CPU 在其他线程、其他进程上工作，而不是浪费时间无所事事。

有两种异步方法/函数:CPU 绑定的和 I/O 绑定的。

I/O 绑定的异步代码是一段 CPU 不直接做任何事情的代码。与某些特定硬件通信的驱动器负责运行该代码。这意味着，例如，网络请求/响应和磁盘读/写操作自然是 I/O 绑定的异步操作，因为它们依赖于硬件来工作。

大多数 I/O 操作不需要线程等待数据的原因是底层协议(低级)使用了一种队列结构，这种结构非常适合 async/await 方法。

另一方面，CPU 绑定的异步代码是在 CPU 上运行的代码。执行耗时计算或计算繁重的正则表达式是可以放在一边以异步方式在单独的线程上工作的操作类型的示例。

需要注意的是，仅仅适应 async/await 模式并不一定意味着您编写的代码可以异步执行。

如果你写一个 for 语句，并且在每次迭代中程序等待一个异步方法，你只是把异步代码转换成同步代码。必须调度异步代码，以便其他(同步)代码可以运行。CPU 应该只在需要异步操作的结果时才等待异步操作完成。

如果您有一个 *facade* 方法在每一行上等待，并且其中两行或更多行彼此不相关，那么它也不是异步的。在这种情况下，该方法应该触发所有彼此不相关的任务，并且当它们返回时，继续运行依赖于它们各自结果的剩余任务。

我希望通过这两个例子，您能够认识到异步模式应该如何工作。

# 并发与并行

并发性和并行性都与同一个概念有关:将工作分布在多个单元中，以这样一种方式，它不会损害最终产品，但会最小化总执行时间。

并发执行是两个(或更多)任务同时运行的可能性，而并行执行是这两个(或更多)任务同时运行的能力。

并发代表可能性。并行才是现实。

将并发转化为并行需要不止一个 CPU。您可能会编写并发代码，但它实际上只会在多个 CPU 并存的情况下并行运行。运行并发代码的单核设备只能以顺序方式执行它。

尽管并行执行可能非常惊人，但有些资源，有时在所有线程之间共享，有时在所有进程之间共享，需要一些协调才能正常工作。例如，写入流(文件或控制台)；如果您不想损坏文件，也不想在输出中显示随机合并的消息，那么有必要协调它们的读写操作。

# CPU 缓存

为了性能而缓存数据的策略在计算机科学中已经存在很长时间了。它大量应用于网络环境，因为它也减少了上网时的带宽消耗。有些人可能没有意识到，CPU 也采用了同样的技术。

CPU 可以缓存变量的值，以提高代码执行的速度。

当一个线程读取一个变量的值并将其存储在其内部缓存中，但随后另一个在不同 CPU 中运行的线程设置同一变量的值时，问题就出现了:第一个线程可能会由于其缓存而继续使用过时的信息。

不过，这并不常见。当然，并不是所有的数据结构都会这样。

此外，如果您曾经面临这种情况，要知道可以指定 CPU 不应该缓存某个特定变量的值。在声明变量时，应该使用“volatile”关键字。尽管如此，这个关键字的使用不应该是鲁莽的。仔细分析每一种情况，因为即使缓存会存储过时的信息，但它总体上为应用程序提供了更好的性能。

# 线程安全

与异步操作或多线程上下文相关的“线程安全”的说法很常见。如果不同的线程可以同时访问一个确定的数据结构的同一个实例并对其执行操作，这意味着它是线程安全的。

比方说:一本字典。一种常规的键/值对列表，其中的键必须是唯一的。使用多线程时，两个(或更多)线程可以同时计算同一个 if 语句，产生相同的结果。现在想象一下，检查字典中某个键是否存在的语句和这个 if 语句保护的代码块应该向字典中添加一个新的(唯一的)键。第一个到达“add”方法的线程将运行完成，但是第二个线程将抛出一个异常。

这是因为这个例子的字典结构不是线程安全的。为了正确处理多线程，有必要推迟第二个线程进入代码。这样，当第二个线程试图计算 if 语句时，它将产生不同的结果。

有几种不同的方法来实现并发控制，最终您会找到适合每种情况的最佳技术。

针对上述情况的解决方案是在检查和添加语句周围应用锁。锁定一段代码意味着锁块中的所有内容将一次运行一个线程，如果其他线程到达了块的开头，它们将不得不等待，直到锁块中的线程完成它的执行。

将锁应用于特定语句块的问题是，它序列化了对代码特定部分的并发访问，这实际上与使用多线程时的情况相反。当然，即使在异步方法中，即使在多线程环境中，也会有需要顺序或受控执行的例程。因此，理解代码并只在必要时使用锁是很重要的。否则，它只是撤销所有工作的一部分。

# 结论

多线程是现代软件开发中不可否认的一部分。它受到编程语言和平台的支持，并一直延伸到操作系统。知道如何使用多线程肯定可以引导开发人员构建更好的应用程序。

因此，我希望这篇文章能对这个主题有所启发，并帮助你利用你的知识。