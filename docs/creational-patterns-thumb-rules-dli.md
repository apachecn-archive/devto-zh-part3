# 创造模式——经验法则

> 原文：<https://dev.to/itscoderslife/creational-patterns-thumb-rules-dli>

##### *本帖直接抄袭[资料来源](https://sourcemaking.com/design_patterns/creational_patterns)，只是为了方便读者查阅这段知识。*

**如何以及何时应用**的规则:

1.  有时创造模式是竞争对手:有时**原型**或**抽象工厂**可以被有利地使用。在其他时候，它们是互补的:**抽象工厂**可能存储一组原型，从中克隆并返回产品对象，**构建器**可以使用其他模式之一来实现构建哪些组件。**抽象工厂、构建器、**和**原型**在其实现中可以使用**单件**。
2.  **抽象工厂、构建器、**、**原型**定义了一个工厂对象，负责了解和创建产品对象的类，并使之成为系统的一个参数。**抽象工厂**拥有生产几个类对象的工厂对象。**构建器**让工厂对象使用相应的复杂协议逐步构建复杂产品。**原型**让工厂对象(又名原型)通过复制原型对象来构建产品。
3.  抽象工厂类通常用工厂方法实现，但也可以用**原型**实现。
4.  **抽象工厂**可以作为**门面**的替代来隐藏特定于平台的类。
5.  **构建器**专注于一步一步地构建一个复杂的对象。**抽象工厂**强调一族产品对象(简单或复杂)。**构建器**在最后一步返回产品，但是就**抽象工厂**而言，产品被立即返回。
6.  **构建者**之于创造如同**之于策略**之于算法。
7.  **构建器**经常会构建一个**组合**。
8.  工厂方法通常在模板方法中被调用。
9.  **工厂法**:继承创造。**原型**:委托创作。
10.  通常，设计从使用**工厂方法**(不太复杂，更可定制，子类激增)开始，随着设计师发现哪里需要更大的灵活性，设计向**抽象工厂、原型或构建器**(更灵活，更复杂)发展。
11.  原型不需要子类化，但是它需要初始化操作。**工厂方法**需要子类化，但不需要初始化。
12.  大量使用**复合**和**装饰**模式的设计通常也能从**原型**中获益。