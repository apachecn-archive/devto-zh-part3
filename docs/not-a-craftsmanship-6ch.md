# 不是手艺

> 原文：<https://dev.to/jorinvo/not-a-craftsmanship-6ch>

这里绝对没有什么新东西。只是我慢慢理解了人们一直在说的事情。也许分享这些甚至不能帮助别人。但是把事情写下来对我有帮助。毕竟，我们不能仅仅通过理论来学习。我们需要亲身经历。这里有很多想法混杂在一起。但都是有关联的。随时联系详细阐述一些部分。

我在这个行业呆得越久，就越能理解那些老人在说什么。我越来越意识到的一件事是，作为工程师，我们是多么高估代码。

代码感觉非常有价值，因为它是我们的创造。在某些时候，我们需要编写代码来实现某些东西。感觉很厉害。

但是就你必须投入到编写代码的时间和精力而言，代码是廉价的。如果你把实际写代码比作计划要做什么，理解一个业务领域，理解技术选项，理解我们在开发产品时必须经历的过程——写代码将花费你最少的时间。

如果你正在开发一个会存在一段时间而不会马上死亡的产品，那么你今天写的代码很可能在将来对你来说是一种负担而不是资产。我们编写的许多代码不会存在太久。很快，我们将对这个领域有更好的理解，找到更合适的解决方案，需求发生变化，或者我们正在创建的东西对这个世界并不那么有用。

当开始编程时，我觉得它是关于完美的。我对创造这个完美的小世界很感兴趣，在这里一切都是合乎逻辑的。我觉得只要我搜索和实验足够长的时间，我就会提炼出完美的解决方案。生活在这样一个美丽的世界里。我猜其他人也有类似的经历。很容易被我们网站项目的性质、学生作业等等所欺骗。它们与开发一个与现实世界互动的有生命的、进化的产品是非常不同的。

之后经历的现实是，所有的选择都是妥协。你的项目的某些部分总是遗留代码，你想重写和改进，但是你没有时间这么做，因为优先级很重要，这个旧的、不完美的代码现在仍然工作，并且在改变它之前等待花费的时间更少。
这段代码是如何以这种不完美的状态结束的？你写的时候没有想出你能想到的最好的解决方案吗？我确信我尽力了。但是需求可能已经改变了，我可能学到了关于我们当时正在解决的问题的新东西，或者可能在编写代码时，我们做了一个折衷，在这里投入了不太多的时间。
这个过程有一个非常基本的东西:当你解决一个问题时，你会从解决方案中学习。第一种解决方案很可能不是最合适的。有时候，或者更确切地说，太多次了，你也只是在一开始就解决了错误的问题之后才意识到。

衡量“好”软件设计的最重要的标准是让它在未来为未知的需求而改变变得容易。很少有软件是静态的，我们可以像创作雕塑或制作吉他一样完善它。创建软件是一个过程。我怀疑用工艺来比喻软件开发可能会弊大于利。更恰当的形象是政治或经济:
我们在苏联看到，如果你试图规划一个完美的系统，会发生什么。想想所有失败的规划城市。政治和软件太复杂，无法提前计划。构建如此复杂的稳固系统的唯一方法是有机地发展它们。因此，我们不应该专注于完善结果(代码)，而应该专注于优化过程。
另一个我喜欢的形象是一个植物学家在打理花园:
从有机系统中获取灵感。想想进化是如何让大自然想出如此复杂的有机系统的:创造新的实验，保留好的，忽略坏的。
我们不必太在意这些实验中的每一个。不要执着于代码。
以松耦合的方式构建它，因此更改部件很简单。让丢弃零件变得简单。

我们需要更多地关注理解和优化我们如何创建软件的过程。如果代码的结构非常临时，那么文字代码、代码注释等等都不是足够的文档。
我们需要学习记录我们正在经历的过程。
我们代码的版本控制是朝着正确方向迈出的一步。但这只是在最低的粒度级别上。我们需要记录我们正在做的事情。如果我们将来再看它，我们需要理解我们为什么和如何做某事的背景。我们当时的假设呢？什么约束在哪里？它们与我们现在所处的地方有什么不同？

现在的编程教育非常关注代码。而且不仅仅是大学。教育是一个终生的过程。我们在行业中以文章、书籍、会议的形式进行的教育都非常关注代码。我们需要更多的工具来组织流程。教程序员如何写下他们的推理，教我们如何画图表，教我们如何实验和扔掉代码，教我们如何为决策调用正确的权衡。我意识到这些东西在学院环境中很难教。也许这就是为什么传统教育对这个行业的程序员工作毫无用处。这些行业最好在真实的环境中学习，在那里我们可以积累经验，互相学习。互相分享你们的故事。不要只给我看你造的东西。更有趣的是方法。为什么最后会有这个解决方案？你是通过什么过程到达那里的？在这个过程中你还考虑了什么？这些是我最喜欢的思想交流方式。

让我们更容易观察我们的系统在做什么。请注意，系统会随着时间的推移而存在。通过监控、记录和度量使我们的系统可观察。收集数据以了解随时间的变化。看看你的系统如何发展。赶上潮流。移除或更新过时的零件。今天很棒的东西明天可能就完全没用了。关注当前重要的事情:如果您意识到某个 API 端点不再被使用，您知道下次您必须接触它时，您可能会简单地删除它，而不是费心更新它。如果你意识到一个功能被大量使用，投资它。必要时优化性能，当人们遇到困难时改进功能。

要意识到你的过程和产品来自于你的组织结构。如果你有一个自上而下决策的层级组织，你将会计划系统而不是让它们自然进化。个体行为者需要有独立于彼此做出自己决定的自由。然而，他们仍然需要相互沟通，相互理解。构建具有扁平层级和松散耦合团队的组织。建立相互沟通的机制。

在组织层面上这样做，互相分享你的工作故事。你可以在你的公司私下这样做:内部博客和谈话都很棒。

在技术层面上，为了使双方能够以一种松散耦合的方式构建软件，双方需要走到一起，为他们的软件通信定义一个契约。只要他们遵守合同，他们就是自由的。拥有定义和执行合同的良好工具。

所有这些都是软件复杂性的来源。不要太在意你写的代码。