# 节点分析器在运行时对 Node.js 应用程序进行性能分析

> 原文:[https://dev . to/sbadhwar/performance-profiling-your-node-js-application-at-runtime-h9i](https://dev.to/sbadhwar/performance-profiling-your-node-js-application-at-runtime-h9i)

作为开发人员，我们主要关注以尽可能好的方式开发应用程序。这包括语言、工具、算法等的选择。无论哪种方式，都有助于我们获得尽可能好的结果，同时还能控制生产效率。这些应用程序可以是桌面 GUI 应用程序、系统实用程序或 Web 应用程序，它们为用户提供了轻松完成任务的能力。一旦确定了应用程序中的慢区域，这个开发过程还包括优化代码库。但是，我们有多少时间去查看关于哪些特定函数或方法执行缓慢并且被频繁使用的数据呢？当致力于优化我们的应用程序时，与识别代码库中的热方法相关的数据可能会有很大的帮助。

这篇文章介绍了如何在运行时分析 Node.js 应用程序，而不会真正中断应用程序。此外，由于应用程序根本没有被中断，我们可以在生产中运行它，以便在应用程序为实时流量提供服务时识别性能热点。但是，为什么我在这里针对 Node.js 而不是其他语言呢？这个问题的答案在于，最近我一直在努力寻找一种方法，通过这种方法，我们可以分析一个正在运行的 Node.js 服务器端应用程序，而不需要重新启动应用程序或产生过多的开销，这些开销可能会导致应用程序变慢，从而中断生产环境。随着这篇文章的展开，我们将看看为什么需要代码级性能分析，有哪些技术，然后深入了解如何在 Node.js 世界中实现这种分析的概念。所以，我们走吧。

# [](#the-need%C2%A0for-performance-profiling-the-codebase)需要对代码库进行性能分析

开发应用程序需要时间。优化代码库完全是另一个层面。很多时候，开发人员花费大量时间优化代码部分，但这并不能为用户带来任何显著的性能提升。那么，这是否意味着优化不正确或者应用程序不能进一步优化？答案是否定的。很多应用程序都有巨大的潜力可以优化，但这种潜力并没有实现。发生这种情况的原因是，开发人员可能会看到一些功能，并认为它可以优化，花费大量精力来改变其中的算法或数据访问模式，却意识到这种改进对用户来说几乎没有任何性能好处。但是为什么会这样呢？

事实证明，开发人员确实在函数中实现了正确的优化，但是该函数很少被调用。很多时候都是这样。事实证明，在优化应用程序时，实施正确的优化是有益的，但在正确的位置实施它才是会产生影响的。但是我们如何找到优化的地方呢？让我们找出答案。

大多数投入生产的应用程序都遵循某种性能指标，这些指标是它们的基准。在大多数情况下，应用程序在平均负载情况下能够在基准测试中表现良好。真正的麻烦来了，当应用程序变得像病毒一样传播，很多用户开始同时访问这个应用程序。这就是性能问题开始出现的地方。作为开发人员或性能工程师，我们需要找出应用程序花费大部分时间的地方。这就是代码级性能分析发挥作用的地方。

代码级性能分析允许开发人员或性能工程师查看他们的应用程序在哪里花费了大部分时间。这些详细信息以被调用的函数或方法的名称、被调用的频率以及运行的时间来表示。不是所有的方法都是平等的。其中一些可能调用频率较低，但速度非常慢；一些可能调用频率很高，但能在几微秒内完成工作。开发人员和性能团队有责任从代码级分析中识别性能热点。只有正确识别，然后优化，结果才会产生积极的影响。那么，我们该如何着手识别这些性能瓶颈呢？让我们找出答案。

# [](#finding-performance-hotspots-in-the-codebase)在代码库中寻找性能热点

当谈到理解代码库中的性能热点时，工程师们有很多方便的技巧。这些技术中的两个涉及代码库的检测或对其进行采样，以便收集关于应用程序在哪里花费了大部分时间的信息。真正的部分是确定何时使用哪种技术。那么，让我们来看看这些技术，并了解其中发生了什么。

## [](#codebase-instrumentation)代码库插装

代码库插装是一种众所周知的技术，它提供了对应用程序的哪个部分花费了多少时间的相当精确的估计。这种技术提供的细节可能非常复杂，包括从一个函数到另一个函数的请求流、每个函数花费的时间、调用单个函数的频率。可以充分利用这种细节来找出哪些方法可以获得更大的优化收益，哪些方法可以保持原样，从而优化开发人员的工作效率。

在实现代码插装的过程中，开发人员通常需要在一个函数的开始和结束处添加一些特定的调用，以便估计一个特定的函数调用花费了多少时间。这个细节可以通过收集更多的信息来丰富，这些信息是关于谁通常通过反射和不同编程语言公开的其他机制来调用给定的函数。这些数据富含每个函数的性能相关指标的详细信息，可用于正确有效地评估代码库中的性能热点。

但是，尽管使用仪器的过程很有用，但它也有自己的缺点。这些包括:

*   **修改代码库:**为了实现插装，开发者需要修改代码库来拦截对单个函数的调用。这种变化会对应用程序产生深远的影响。
*   **去优化的应用程序:**检测代码库的另一个影响可能是应用程序的去优化。编译器和解释器使用大量的技术来优化函数调用。在某些情况下，添加检测代码可能会阻碍这些优化，从而导致应用程序在一定程度上变慢。
*   **CPU 周期增加:**任何添加的插装代码都会消耗应用程序的一些 CPU 周期。虽然大多数情况下它非常少，但是根据您的应用程序可能需要提供的性能保证的类型，这可能会产生巨大的成本。

主要是由开发人员来决定他们希望如何对他们的应用程序进行测试。即使他们不想做仪器仪表。大多数时候，当开发人员求助于插装时，他们通常只将插装代码添加到他们认为可能容易出现性能问题的一组特定函数中。

但是，我们还有另一种技术，在收集与代码库性能相关的信息方面，这种技术侵入性更小，性能更高。

## [](#profiling-through-sampling)通过采样进行剖析

了解了插装的工作原理后，开发人员可能不希望在他们的应用程序中引入插装代码。这种决定可能有很多原因。那么，他们能做什么呢？他们有其他方法来获得代码级的性能指标吗？事实证明，确实有一种方法。这个过程被称为采样。

通过采样，开发人员可以调用一个实用程序，该实用程序定期拍摄进程堆栈的快照，然后估计当时正在运行哪些函数。这个快照可以包括单个线程的快照，也可以同时包括整个应用程序的快照。这在很大程度上还取决于应用程序运行的环境，以及该环境是否允许对应用程序进行快照。

由于应用程序的快照是从外部以明确定义的时间间隔拍摄的，因此应用程序的开销是有限的。此外，由于该过程不涉及对代码库的任何类型的修改，所以应用程序无需修改就可以运行，通常所有的编译器优化都是为了加速应用程序的运行。但是，与所有事情一样，这一过程也有其自身的缺点，包括:

*   **依赖于应用程序运行时:**采样高度依赖于应用程序运行时公开的特性。如果运行时不公开应用程序符号，或者不提供异步捕获正在执行的应用程序堆栈的快照的机制(即，不使应用程序临时暂停)，该技术将不起作用或者可能涉及大量开销。
*   **降低粒度:**由于应用程序快照是在应用程序外部以一定的时间间隔捕获的，因此不可能正确估计各个方法花费的时间。这转化为收集数据的粒度降低。

如果工程师同意在度量粒度方面进行权衡，并且需要一个他们可以在应用程序外部实现的解决方案，那么基于采样的分析可能会非常有用。通过使用调用频率和堆栈跟踪来估计性能，可以解决没有关于在单个函数调用中花费多少时间的准确数据的缺点。

有了这两种技术的基本概念，现在让我们深入了解如何在运行时对 Node.js 应用程序进行性能分析。

# [](#performance-profiling-nodejs-applications)性能分析 Node.js 应用程序

近年来，在 Node.js 的推动下，Javascript 已经开始统治服务器端应用程序领域。这个 Javascript 堆栈在开发人员生态系统中获得了巨大的成功，这主要是因为许多现成的第三方库为大量问题提供了预构建的解决方案，用于在客户端和服务器端开发应用程序的公共语言堆栈，以及处理大量并发用户的能力。

随着许多知名的大型公司，如优步、网飞、LinkedIn 和其他公司采用 Node.js，生态系统正在获得很大的牵引力，许多开发者正在进入生态系统，构建各种各样的应用程序来满足不同用户的需求。Node.js 的大量使用也为在服务器端优化基于 Javascript 的应用程序带来了很多机会。

Node.js 运行时由 Google V8 Javascript 引擎提供支持，该引擎在技术上是一个执行 Javascript 代码以生成输出的虚拟机。在 Node.js 世界中，代码库的优化目标是请求生成响应并将其发送回客户端需要多长时间，各个函数在 V8 Javascript 引擎中执行需要多长时间。

幸运的是，V8 为我们在代码库上运行性能分析提供了强大的功能。这种性能分析是通过使用 V8 inspector 协议实现的，该协议允许开发人员对 V8 引擎内部执行的代码库进行调试和采样。

## [](#v8-inspector-protocol)V8 检查员协议

V8 javascript 引擎提供了许多有用的调试功能。用户和将 V8 引擎嵌入应用程序的开发人员都可以使用这些功能。该协议为用户提供了连接到 V8 引擎并检查其状态的方法。 [V8 Inspector 协议](https://v8.dev/docs/inspector)通常通过 websocket 公开，应用程序通过 UUID 唯一标识。当用户想要连接到 V8 inspector 协议时，他们通常需要两者，暴露协议的地址和应用程序的 UUID。

为了与 V8 inspector 协议进行交互，开发人员通常有两个接口，一个是 Chrome DevTools 接口，另一个是编程接口。在这篇文章中，我们将重点讨论后一个问题。

现在，让我们看看如何使用这个协议在 Node.js 应用程序上运行性能分析。

## [](#exposing-the-v8-inspector-protocol-in-nodejs-application)在 Node.js 应用程序中暴露 V8 Inspector 协议

通常，当 Node.js 应用程序启动时，应用程序不会启动默认启用的 V8 inspector 协议。要启用 V8 inspector 协议，用户需要向应用程序提供 _–inspect _ flag。

`$ nodejs --inspect <script_name>`

当 Node.js 运行时以这种方式启动时，它通常会在 ws://127.0.0.1:9229/上启动一个 websocket，在我们可以连接的接口上公开 V8 inspector 协议，然后使用它进行操作。

但是这种启动 V8 inspector 协议的方式在生产中有点麻烦，因为要启动调试器，首先需要关闭应用程序，然后用标志再次启动它。这并不是在每个环境中都可行，可能会使用户暂时无法使用该应用程序。应该有更好的方法来实现这一点:

### [](#enabling-the-protocol-at-runtime)运行时启用协议

事实证明，即使应用程序正在执行，我们也有办法启用协议。这是通过使用两种不同的机制实现的:Linux 和 Mac 上的信号，以及对基于 Windows 的主机的未记录的内部调用。

Node.js 运行时配置为通过启动 V8 inspector 协议来响应 *SIGUSR1* 信号。一旦任何 Node.js 应用程序收到 SIGUSR1 信号，该应用程序就会启动 V8 inspector 协议。为此，可以使用以下命令:

`$ kill -usr1 <PID of the node.js application>`

对于基于 Windows 的主机，同样的功能可以通过使用未记录的方法调用*过程来实现。_debugProcess(PID)* 。对于正在运行的 node.js 应用程序，可以这样做:

`$ nodejs -e "process._debugProcess(PID)"`

一旦使用了任一选项，就可以在 *ws://127.0.0.1:9229/* 找到正在运行的协议

## [](#connecting-to-the-protocol)连接到协议

现在，一旦我们启用了协议，让我们使用一些快速 Python 脚本来连接到协议。为了成功执行下面的命令，我们需要在系统上安装一个小的 python 库。要安装此库，请运行以下命令(可能在虚拟环境中):

`$ pip install websocket_client`

上面的命令安装了一个小库，帮助我们连接 websockets 并与之交互。

现在，一旦安装了库，下一件事就是识别带有 V8 inspector 协议的 websocket 在哪里运行。如果已经用 SIGUSR1 通知了应用程序，那么应用程序的日志消息应该包含 URL。否则可以访问[http://127 . 0 . 0 . 1:9229/JSON](http://127.0.0.1:9229/json)。应用程序的 UUID 是“ID”字段，可以在 JSON 中找到指定的应用程序名称。

`$ curl http://127.0.0.1:9229/json<br />
[ {<br />
"description": "node.js instance",<br />
"devtoolsFrontendUrl": "chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/c3453b38-82be-46c3-9d56-39d8783fbb47",<br />
"faviconUrl": "https://nodejs.org/static/favicon.ico",<br />
<strong>"id": "c3453b38-82be-46c3-9d56-39d8783fbb47",</strong><br />
"title": "nodejs[276]",<br />
"type": "node",<br />
"url": "file://",<br />
"webSocketDebuggerUrl": "ws://127.0.0.1:9229/c3453b38-82be-46c3-9d56-39d8783fbb47"<br />
} ]`

现在，根据我们对 UUID 的了解，是时候通过运行

`$ python`

一旦进入解释器，从 websocket_client 导入 create_connection 方法，这将帮助我们连接到 websocket，公开 V8 inspector 协议。

`>>> from websocket import create_connection`

一旦方法被导入，让我们通过执行以下命令连接到我们的 websocket:

`>>> ws = create_connection("ws://127.0.0.1:9229/c3453b38-82be-46c3-9d56-39d8783fbb47")`

这样，如果一切运行正常，我们将连接到 V8 inspector 协议。协议上的通信是通过交换 JSON 格式的消息进行的。因此，我们还需要在解释器中导入另一个库来提供 JSON 支持。这可以通过使用以下命令来完成:

`>>> import json`

现在，我们已经准备好在正在执行的 Node.js 应用程序上运行我们的分析会话。

## [](#starting-the-profiler)启动 Profiler

随着套接字连接的建立和 JSON 支持的到位，让我们开始进行概要分析。

开始分析的第一步是在运行时内部启用分析器。为此，我们精心制作了以下请求 JSON:

`>>> enable_profiler = {"id": 1, "method": "Profiler.enable"}`

在前面的语句中，我们创建了一个 Python 字典，有两个键:

*   **id:** 跟踪请求的唯一 id。一旦一个请求被 V8 inspector 协议接受，该协议返回一个响应，其 id 字段与请求的 id 字段相同。这对于需要异步执行的命令来说非常方便。
*   **方法:**要执行的方法。该字段的值包含两部分。要调用的域和方法。域就像一个命名空间，特定的方法存在于其中。例如，在我们的例子中，域是 Profiler，方法是 enable。

一旦创建了这个请求，我们就可以通过执行以下命令来发送这个请求:

`>>> ws.send(json.dumps(enable_profiler, separators=(',',':')))`

由于基于 websocket 的 inspector 协议接受没有任何空白分隔符的请求，我们通过设置在 *json.dumps()* 方法调用中使用的分隔符来删除请求中的任何空白分隔符。发送命令后，可以通过执行以下命令来检查响应:

`>>> ws.recv()`

如果请求因一些错误而结束，我们将得到一个 JSON，并返回错误键和错误代码集。

现在，有了这个，我们的侧写器就启动了。但是现在，它没有对应用程序进行任何分析。要开始分析，我们需要发送另一个请求。以下命令为我们做到了这一点:

`>>> start_profiler = {"id": 2, "method": "Profiler.start"}`

`>>> ws.send(json.dumps(start_profiler, separators=(&#8216;,&#8217;,&#8217;:&#8217;)))`

`>>> ws.recv()`

随着上述命令的执行，如果没有收到错误，我们的分析会话已经开始。现在，让我们让分析器运行一段时间。这个由 V8 引擎实现的分析器是一个采样分析器，它以特定的时间间隔对应用程序堆栈进行采样。默认情况下，探查器设置为每 1000 微秒采样一次。

现在，一旦我们让分析器运行了一段时间，就该停止分析器并获得结果了。执行以下命令会停止分析器，并获得结果。

`>>> stop_profiler = {"id": 3, "method": "Profiler.stop"}`

`>>> ws.send(json.dumps(stop_profiler, separators=(&#8216;,&#8217;,&#8217;:&#8217;)))`

`>>> ws.recv()`

执行上述命令的结果是一个包含以下键的 JSON:

*   **startTime** :剖析开始的时间
*   **endTIme** :剖析结束的时间
*   **timeDeltas** :由连续样本之间的增量组成的数组。第一个样本的增量是开始时间和第一个样本的时间之差。
*   **nodes** :一个 Profiler 节点数组，包含关于单个方法、其行号、源文件等的信息。
*   **samples** :由节点 id 组成的数组，该节点 id 在拍摄快照时被发现正在执行

这就完成了我们的数据分析会话。现在就看我们如何利用这些数据了。很多时候，你可能想从收集的数据中生成[火焰图](http://www.brendangregg.com/flamegraphs.html)。

现在，我们该禁用分析器了，这可以通过执行以下命令来完成:

`>>> disable_profiler = {"id": 4, "method": "Profiler.disable"}`

`>>> ws.send(json.dumps(disable_profiler, separators=(&#8216;,&#8217;,&#8217;:&#8217;)))`

`>>> ws.recv()`

完成后，我们现在可以通过执行以下命令断开与协议的连接:

`>>> ws.close()`

然后关闭解释器。

这样，我们就知道了如何在一个正在运行的 Node.js 应用程序上运行一个分析会话，而不会中断该应用程序或对它造成严重的性能损失，这使得该技术对于分析在生产环境中运行的应用程序非常有用。一旦有了这些分析数据，我们就可以利用它来找出代码中可以通过代码优化带来巨大好处的地方。

# [](#further-reading)进一步阅读

如果你对这篇文章感兴趣，并想知道如何使用 V8 inspector 协议，请点击以下链接了解更多信息

*   [调试嵌入式 V8 Inspector 协议](https://v8.dev/docs/inspector)
*   [V8 检查员协议](https://chromedevtools.github.io/debugger-protocol-viewer/tot/)
*   布伦丹·格雷格的火焰图
*   [Chrome 中的 Javascript CPU 剖析](https://developers.google.com/web/updates/2016/12/devtools-javascript-cpu-profile-migration)