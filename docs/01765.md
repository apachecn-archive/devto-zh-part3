# git——如何验证提交消息？

> 原文:[https://dev . to/rlxdprogrammer/git-how-to-validate-commit-messages-55 M5](https://dev.to/rlxdprogrammer/git-how-to-validate-commit-messages-55m5)

上次我写了一篇给初学者的 GIT 入门。这一次我想给出一个关于 GIT 中一个高级问题的解决方案。我必须解决以下问题:所有提交消息需要遵循一些特定的规则(最大长度的行等)。)并且如果其提交消息不满足这些规则，则不应该能够推送任何提交。

我认为这个问题应该有一个简单的解决方案，而且肯定很多人已经解决了这个问题，因为提交消息的验证应该是几个项目都需要的。事实上这并不容易。我来描述一下为什么！

# [](#git-commit-hooks)Git 提交钩子

在 GIT 中，你可以指定所谓的提交钩子。这些是在特定操作的情况下调用的脚本。有运行在“客户机”端的提交挂钩，也有运行在“服务器”端的提交挂钩。我使用引号，因为我们知道在 GIT 中，服务器和客户端回购没有指定的角色，每个回购都可以充当服务器和客户端。您可以在下面找到所有这些提交挂钩。git 回购中的 git/hooks。

有一个提交钩子叫做 commit-msg，这正是我们所需要的。如果您正在调用 git commit 命令，那么这个脚本将被调用，它将获得 commit 消息作为输入参数，如果它没有返回 0，那么 commit 将被丢弃。听起来真不错。该脚本在“客户端”回购上提交的情况下运行的唯一问题是。这意味着如果克隆服务器 repo 的客户机从。git/hooks 文件夹，他就可以提交任何他想要的东西。所以这是很好的第一步检查，但是它仍然不能以安全的方式解决问题。此外，commit_hooks 不受版本控制，所以您需要找到另一种方法(可能通过一些附加的脚本)将它们复制到客户端 repos。或者，您可以在 hooks 文件夹和版本控制文件夹之间创建一个符号链接。

如果我们想百分百确定服务器 repo 中不会出现无效的提交消息，我们需要在服务器端检查它。

对于服务器端的检查，一种可能是使用提交钩子。每当有人向服务器推送东西时，就会调用这个提交钩子，如果它有一个非零返回值，那么推送就会被拒绝。

唯一的问题是，这个提交挂钩没有明确的输入，不知道具体提交了哪些内容。它可以从标准输入中读取它的输入，并且它只包含以下格式的 git 引用的更改:旧值新值引用名。

现在如何确定哪些是新的提交？

首先深入一点 git，了解一下引用。

# [](#git-branches-and-references)Git 分支和引用

当你在 git 中推提交时，你总是在推一个分支。默认情况下，您位于主分支上，但是您可以随时创建从现有分支分支出来的新分支。如果你正在做一个 git 推送，它要么将你的分支推送到它的上游分支，如果它存在的话。如果从服务器获取分支，将自动设置其上游分支。上游分支始终是服务器上的分支。如果上游分支不存在，或者如果您处于分离头模式(您不在任何分支上，您的头只是指向一个随机提交)，git 将要求您指定您要推送到哪个分支(就像 git 推原始主机)。

我们现在退一步。什么是 git ref？git ref 就像是指向存储库中特定提交的命名指针。下可以找到所有参考资料。git/ref 目录。而分支无非是特殊的引用。它们也只是一个指向提交的指针，但是如果你正在提交一些新的东西到提交中，分支会自动改变指向分支上最近的提交。但它只是一个命名的指针，没有别的。

# git 推送时会发生什么？

Commits 知道的不多。他们知道自己的内容和父母的承诺。在合并提交的情况下，提交有多个父级，否则只有一个。回购中的第一个“根”提交根本没有父提交。

因此，如果你调用 git push，你总是在推一个或多个(通过使用 git push - all)分支。您首先让服务器知道分支指向的是哪个新提交。这是接收前提交钩子的输入值。推提交钩子也检查分支是否已经存在于服务器上，如果是，那么它让预接收钩子知道它以前的内容是什么。

然后，服务器检查它是否已经有了那个提交(提交存储在。git/objects)。如果没有，那么它将从客户端获取提交并检查它的父级。如果父提交不在服务器上，父提交也将被移动到服务器。它将一直持续到位于服务器上的第一个父提交。

如何在预接收钩子中找出哪些提交是新的？

最大的成就是 pre-receive 钩子只告诉我们哪些引用被修改成了什么，其他什么都没有。我们的目标是验证所有新的 push commit 消息，除此之外别无其他。

第一种也是最简单的情况是，有人将提交推送到之前已经存在的分支。在这种情况下，我们获得了引用的旧值和新值，并使用 git log old_hash..new_hash 我们会看到它们之间有哪些提交。

有一种情况，当这个方法显示了比需要更多的提交时:在合并提交的情况下，它显示的是合并分支的全部内容，然而也可能是那个分支已经被至少部分地推送了。

我还需要提到引用(或分支)被删除的情况。在这种情况下，新散列将是 0 的 40 倍，但这也意味着不需要验证任何提交消息。

最后一种情况是当一个新的分支被推送时。在这种情况下，引用的旧哈希是零的 40 倍，我们有了引用的新哈希。这意味着我们只有分支上最新提交的散列。了解什么？经过一些调查，我的想法是做同样的推。检查最新提交，然后跳转到其父提交，在合并提交的情况下，对所有父提交做同样的事情，并停止此活动，我们在之前已经推过的分支上达到一个提交。

这个想法听起来不错，但是如何判断提交是否已经在服务器上。当然有多种解决方案，但我花了一些时间才找到一个有效的。

我的解决方案是 git branch - contains 这个命令返回一个关于分支的列表，这些分支在其历史中包含一个特定的提交。但是要注意！因为 git 只存储了对分支上最近提交的引用，所以作为该提交祖先的所有提交都在该分支上。因此，如果我从主分支的某个点分支，那么在我的分支之前的主分支上的所有提交也是我的分支的一部分。还有一点需要注意:客户机上的分支和服务器上的分支不一样，这将是我们任务的解决方案。

根据我的经验，服务器上的所有提交至少属于一个分支，因为不可能推送分离的提交。在更改引用之前调用预接收提交挂钩。这意味着之前没有被推送的所有提交都不是任何当前存在的分支的一部分，但是已经存在的所有提交都是至少一个分支的一部分。这是我们可以用在这里的事实。

# [](#summary)总结

让我总结一下在服务器端提交钩子上检查 git 提交消息的解决方案。

从分支的最近一次提交开始，一个父级接一个父级，检查这个 git 分支包含的提交是否返回一个空列表。如果是，验证其提交消息并检查其父级，如果不是，则该提交之前已经被推送过，我们在该分支上没有其他事情要做。特别注意合并提交，检查每个父级。

我希望这个解决方案是正确的，直到现在它通过了所有的测试用例，我也希望它能帮助你解决你的任务。