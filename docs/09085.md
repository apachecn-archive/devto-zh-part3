# 布局 git 存储库

> 原文:[https://dev . to/andrewhowdencom/laying-out-a-git-repository-ii1](https://dev.to/andrewhowdencom/laying-out-a-git-repository-ii1)

版本控制是软件开发中最基本的部分之一。它允许开发人员浏览项目历史，了解谁实现了每个变更，以及他们为什么这样做。在理解任何特定问题时，这是一个非常有用的工具。

littleman.co 使用 git 作为其版本控制工具的选择。是软件行业事实上的标准，已经取代了 Mercurial、Subversion 和 CVS。我们的大多数开发工具和工作流程都建立在`git`原语之上，例如:

*   补丁

*   分支

*   标签

诸如此类。话虽如此，但对于如何规划一个项目，它却保持着惊人的沉默。

这对工具来说是件好事，但对开发人员来说不一定。当第一次阅读一个项目来理解和调试它时，开发人员需要尽可能快地建立一个该项目的模型。然后，他们可以使用该模型来预测软件应该如何运行；同样，发现违反这些预测的事情。如果我们能够保持项目的一致性，我们就能够减少开发人员为了找到想要的问题而需要调查的奇怪事情的数量。

因此，以相同的方式构建中的所有项目是一个好主意，这样开发人员可以很容易地理解和搜索它们。

# [](#existing-standards)现有标准

定义一个项目应该如何布局的标准并不是什么新鲜事。有:

*   Linux 文件系统层次标准

*   [标准围棋项目布局](https://github.com/golang-standards/project-layout)

*   [Maven 标准目录布局](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)

*   [Python 标准项目布局](https://docs.python-guide.org/writing/structure/)

如果这些标准中的一个在你的组织中广泛使用，最好继续使用它，而不是[采用另一个标准](https://xkcd.com/927/)。然而，这些标准中的每一个都有局限性，它们只能在定义它们的语言或构建工具的上下文中使用。在像 littleman.co 这样包含许多不同语言、应用程序和其他开发类型的环境中，这些标准要么没有定义足够有用的行为，要么定义的东西不能在语言之间很好地传播。

# [](#determining-the-boundaries-of-a-repository)确定储存库的边界

一个项目通常有许多不同的组成部分，它们需要聚集在一起，让项目用户面对并做有用的工作。像这样的事情:

*   应用

*   基础设施

*   CI/CD

*   史前古器物

*   证明文件

这些事情必须以某种方式进行协调，允许开发人员以可预测的方式和可预测的时间对项目进行更改，并将这些更改推送给用户。

传统上，这些组件中的每一个都是独立的，由不同的团队处理。然而，随着连续交付的出现，开发人员可以以“自助服务”的方式将代码推向生产，并让机器人负责以下任务:

*   确保应用程序在到达用户之前按预期运行

*   用新应用程序替换生产中的现有应用程序

*   在失败的情况下将应用程序回滚到其先前的版本

*   创建测试环境

诸如此类。

部署是确定单个存储库中应该有什么的最有用的界限。例如，如果应用程序是单个部署中唯一需要更改的东西，那么它可以是存储库中唯一需要更改的东西。然而，如果应用程序正在改变，并且需要底层基础设施的改变，那么基础设施也应该在存储库中。如果应用程序需要一组新的测试，并且这些测试应该在也属于存储库的 CI/CD 配置中。

然而，这也为不属于存储库的内容提供了很好的界限。应用程序不应该要求 Kubernetes 处于特定的配置中，因此 Kubernetes 的配置和生命周期应该在单独的存储库中进行管理。如果应用程序需要新的 TLS 证书，但这些证书是在正常应用程序开发流程之外的流程中处理的，则它们也不应存储在存储库中。

通过使用部署作为我们的边界来确定项目的进出，我们看到了许多好处:

## [](#democratised-project-tooling)民主化的项目工具

即使像 Docker 或 CI/CD 这样的东西可能需要应用程序开发人员没有任何理由去学习的专业知识，但是通过在相同的地方看到这些变化，并且遵守与应用程序的其他部分相同的标准，这些开发人员可以更好地理解他们自己的项目生命周期。他们可以利用这些知识来减少理解和解决与该流程中的任何更改相关的问题所需的时间，例如应用程序中 CI/CD 中断资产编译的配置更改。

此外，这些开发人员可以为 CI/CD 流程提供特定于应用程序的见解，例如存储配置的最佳位置或必须应用的特定于环境的应用程序配置。

## [](#single-view-of-changes)单个视图的变化

当理解一个 bug 是如何以及何时被引入到一个服务中时，我们必须查找和关联的地方越少，我们就能越快地发现和解决问题。

通过将与项目相关的所有变更分解到下一个“部署层”,我们可以很快看出是应用程序代码变更、配置变更还是环境变更，它们是在问题开始影响用户的同时引入的。

## [](#coordinated-changes)协调变化

有时应用程序更改和配置或环境更改必须同时发生。例子包括:

*   添加新的数据存储(Redis)

*   新公开的应用程序配置

*   需要系统库的新应用程序功能

通过将应用程序和基础架构放在一个存储库中，我们可以在一个拉式请求中审查应用程序更改和基础架构更改，并确保以协调的方式发布和测试它们。

此外，生成的任何部署工件都可以直接追溯到`git`存储库中的变更，从而允许运营团队成员确切地知道在任何给定时间生产中正在运行什么代码。

# [](#the-standard)标准

littleman.co 标准源于上述要求。目录布局如下:

```
$ tree .

├── bin
├── build
│   ├── ci
│   └── container
│       ├── Dockerfile
│       └── etc
├── deploy
│   ├── ansible
│   │   └── playbook.yml
│   ├── docker-compose
│   │   ├── docker-compose.yml
│   │   └── mnt
│   │       └── app
│   └── helm
├── docs
├── LICENSE.txt
├── README.adoc
├── src
└── web

14 directories, 5 files 
```

GitHub 上发布了一个[新项目，这个帖子描述了现有的标准，格式为](https://github.com/littlemanco/boilr-gitrepo)[一个`boilr`模板](https://github.com/tmrts/boilr)。

## [](#)/

```
├── LICENSE.txt
├── README.adoc
├── .drone.yml
├── .arclint 
```

根据惯例或者项目工具的要求，有各种各样的文件存在于项目的根目录中。

其中包括:

*   **LICENSE.txt** :项目许可证

*   **README.adoc** :项目的一些基本描述

*   **.drone.yml** :项目的任务运行器/ CI 配置

*   **。arclint**:Arcanist lint runner 的配置

# [](#build)打造

```
└── build 
```

构建配置预计会产生某种工件，要么在构建的后期使用，要么部署到某种环境中。

其中包括:

## [](#ci)词

```
└── build
    └── ci 
```

有时构建系统有一些限制，需要额外的程序脚本来做一些`$THING`。

虽然这些有点反模式；在可能的情况下，以更抽象的方式构建解决问题的工具，或者以`drone`插件的风格构建可重用的插件。

## [](#containers)容器

```
└── build
    └── container 
```

容器是 littleman.co 使用的标准部署工件。它们是根据`Dockerfile`定义构建的。

一般来说，每个项目只有一个生产容器，尽管其他容器可以用来帮助定制应用程序构建任务。

# [](#deploy)部署

```
└── deploy 
```

部署文件夹包含任何“基础结构即代码”配置。有多种常用类型，包括:

## [](#helm)掌舵

```
└── deploy
    └── helm
        ├── Chart.yml
        ├── templates
        └── ... 
```

Helm 是一个管理 Kubernetes 对象的定义和生命周期的项目。这是一种自以为是的打包和销售软件的方式，有许多预打包的软件。

软件的每一部分都被打包成一个“图表”。该图表包括:

*   一些描述软件的元数据

*   部署定义

*   部署定义配置

通常一个项目只有一个图表。但是，如果启动此项目需要多个图表，则每个图表都嵌套在自己的子目录中:

```
└── deploy
    └── helm
        └── service-a
            ├── Chart.yml
            ├── templates
            └── ...
        └── service-b
            ├── Chart.yml
            └── ... 
```

然而，一般来说，一个项目需要多个服务是一种反模式。项目应该作为一个单独的、[原子变更](https://en.wikipedia.org/wiki/Atomic_commit)来部署。这些服务更好地组织[在子图模式](https://helm.sh/docs/chart_template_guide/)。

## [](#ansible)Ansible

```
└── deploy
    └── ansible 
```

Ansible 是一个定义机器规格并强制执行的工具。该文件夹中的布局应该是由 Ansible upstream 定义的布局，除了每个项目应该只定义一个角色。

## [](#docker-compose)复合坞站

```
└── deploy
    └── docker-compose 
```

`docker-compose`是一个工具，它有助于在本地开发环境中以有限的方式构建“类似生产”的环境。

它的范围被设计为局限于本地开发。

## [](#docs)文档

```
└── docs 
```

项目特定文件

## [](#src)Src

```
└── src 
```

与应用程序相关的所有文件。

如果应用程序被解释，这应该被称为“应用程序”。

## [](#web)网页

```
└── web 
```

生成的 web 应用程序

# [](#in-conclusion)总之

我们的工具塑造了项目的概念模型。在开发过程中，保持一致性可以减少我们在开始诊断问题或向项目添加功能之前对每个不同项目进行调查的工作量，采用单一项目布局可以尽可能保持一致性。在给定一致的底层基础设施的情况下，littleman.co 项目中的`git`库中包含的东西是向用户部署项目或随后改变项目行为所需的所有东西。布局相当简单，但需要迭代，因此被推送到 GitHub 。希望了解我们如何构建项目将会给你一些关于如何构建你自己的项目的指导，或者邀请关于你的项目当前是否被构建为在你的团队中最大化清晰性和一致性的问题。