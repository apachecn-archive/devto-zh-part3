# 所有编程语言都很烂！

> 原文:[https://dev . to/drbearhands/all-programming-languages-suck-597 a](https://dev.to/drbearhands/all-programming-languages-suck-597a)

这是一个关于如何改进现代编程语言，从而改进一般编程的想法的集合。虽然我把一切都写成陈述而不是问题。如果您能给我任何反馈，我将不胜感激。我希望从这里开始一个更长期的项目，但首先有必要讨论一下这个概念，以避免搞砸，看起来像一个平民。如果你有什么不明白的，欢迎在评论中提问。

我用过相当多的编程语言，但没有一种是我真正喜欢的。如果我写一个程序，我不能保证它不会崩溃、死锁或自旋锁，我不能保证它不会偷我的钱 <sup>[link-1](https://news.softpedia.com/news/node-js-package-manager-vulnerable-to-malicious-worm-packages-502216.shtml) ， [link-2](https://thehackernews.com/2018/11/nodejs-event-stream-module.html)</sup> 或泄露我的数据，我将不得不重写它以在不同的硬件上工作，如果一个非软件工程师把他们的脚本交给我用于生产，我可能不得不重写它...

简而言之，明显缺乏元编程。虽然我们使用的语言通常是图灵完备的，允许我们计算任何可计算的东西，但是它们没有提供足够的原语来推理*关于*我们的解决方案。

我们当前方法的结果是程序员的进入门槛更高，更多的错误和漏洞，更长的开发时间，硬件开发的停滞，低质量的产品和 CS 毕业生更糟糕的工作。在一个越来越依赖软件的世界里，由于可以预防的错误，宇宙飞船爆炸，人们死亡。

函数式程序员可能希望这篇文章是对强类型、纯函数式语言的赞美，但即使是这些语言也没有真正兑现它们的承诺。然而，它们确实更接近目标，所以我将把它们作为一个起点，并提出修改建议。

我将大量引用 Haskell 和 Elm，不是因为它们是最好的或最差的，而是因为它们是我最熟悉的纯语言。如果你知道一种语言可以解决所有这些问题，请告诉我。

## [](#1-stop-using-monads-as-effects)1。停止使用单子作为效果

从那时起，效果就成了纯函数式编程的眼中钉。一个没有效果的程序不能*做*任何事情，它甚至不能开始计算，那么写一个有什么意义呢？因此，用人们可能找到的任何方式在纯语言中建模效果都是有吸引力的，并且单子似乎确实适合。但是，效果≠单子。它们只是模拟连续黑盒状态变化的一种方式。本质上是一种在 FP 风格的类别中进行命令式编程的方法。Haskell+IO 在概念上和用 C 语言编程 <sup>[link-1](http://conal.net/blog/posts/the-c-language-is-purely-functional) ， [link-2](http://conal.net/blog/posts/the-c-language-is-purely-functional#comment-467)</sup> 没什么区别。

作为单子的效果是证明系统的死亡。因为单子是幺半群，它们破坏信息。对幺半群范畴中的类型应用运算符会产生相同的类型。

这在实践中意味着什么？考虑以下理论上的第三方库的伪代码示例:

```
readImage :: IO imageData
readImage = do
  readFileData "./imgs/cat.jpg" 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

```
totallyLegitReadImage :: IO imageData
totallyLegitReadImage = do
  stealPasswords
  findAndSendNudes
  openBackdoor
  readFileData "./imgs/cat.jpg" 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果你声称类型系统使你的编程语言安全，这似乎是一个相当重要的区别。

我们可以将函数的类型扩展为二维，而不是函数返回有效的单子。我们仍然有传统的类型，让我们称之为*记忆模型*维度，其中函数是命题 a → b。我们在效果维度中添加一个类型。具体来说，一个效果类型可能生成一个函数可能具有的所有效果的 DNF(析取范式)。它还可以扩展到包括更多的顺序约束。单子也是一种第二维度，但是对于第二维度能做什么有严重的限制(顺序性&非特异性)。

不管我们如何模拟效果，我们都希望效果越少越好，这就引出了下一点。

## [](#2-expand-the-reach-of-type-systems)2。扩大类型系统的范围

任何函数式程序在没有效果的函数世界和效果无时无刻不在的真实世界之间都有一道屏障。跨越那个障碍就是任何效果。目前，这一障碍比必要的限制更多。

我们再来看看哈斯克尔。这里的障碍包括从读/写到磁盘、网络连接、听键盘等一切。本质上，函数世界只跨越应用程序内存和 CPU。如果您的意图是编写一个传统意义上的可执行程序，这是很有意义的:一个在冯诺依曼架构上运行的程序，带有其他应用程序和操作系统，而不需要对其他应用程序可能在做什么做任何假设。

这种方法看起来肯定是安全的，因为它几乎不做任何假设。另一方面，它也限制了证明系统的范围，因为在通信代理之间证明事情要困难得多。这反过来可能会降低整个项目的安全性。然而，假设整个节点由编译器管理；磁盘上的文件只是一个常量。例如，如果你在 Jupyter 笔记本中建立深度学习模型，这很有用，因为你可能会假设本地目录中没有其他东西。我们还可以将多个节点置于编译器的完全控制之下，甚至是一个数据库。这些是现实应用中的常见情况。

功能边界应该表示我们的解决方案的抽象输入和输出，而不是一刀切的可执行风格的 IO 效果，这会不必要地缩小安全的功能世界。

## [](#3-separate-what-from-how)3。分开“什么？”从“如何？”

随着功能边界超越内存+ CPU，将一个程序应该做什么(T0)和如何实现(T3)的表达(T2)分开变得可能，甚至是必要。

编程语言最初是作为计算机的直接控制机制，增加了各种抽象层，逐渐从低级易错指令转移到更高级、更优雅的结构。我们得到了调用栈，命名变量，循环，虚拟查找表。我们用类型替换了字节偏移量，用 hashmaps(弱/动态类型)替换了类型。函数式编程完全摒弃了指令。

尽管如此，我所知道的所有语言仍然建立在它们的前辈之上，并继承了它们预期架构的细节。编程语言受到了开发者想要为机器创造控制器的观念的阻碍。这是不对的。一个开发人员想要创建一个问题的解决方案。

那么，假设我们可以在“什么空间”中创建一些程序，并通过一些(交互)过程将它转换为“如何空间”中的程序。

随着这种分裂而来的是所需领域知识的分裂。性能调优可能需要高级 CS 主题的知识，可以由业务逻辑的不同人员独立处理，因为这两者不再纠缠在同一个代码中。

并行计算和硬件开发也将大大受益于这个。几十年来，我们一直坚持使用 x86，因为竞争不仅仅是架构，还有可用的软件。因此，创新已经陷入停滞。替代 x86 的尝试(英特尔已经尝试过)失败了，内核数量的增长比预期的要慢得多。还记得英特尔与 AMD 以及单线程与多线程性能之争吗？单线程性能大获全胜，因为这正是软件的初衷。

这种分离的一部分也可能是摆脱数据结构。在概念层面上，所有的数据只是集合和集合之间的关系。然而，我不太确定这个想法，至少现在还不确定。当然欢迎意见！当然，我们应该在 what-scope 中去掉像“int32”这样的类型。

## [](#4-no-more-sneaky-stuff-inside-the-proof-systems)4。验证系统中不再有偷偷摸摸的东西

当代类型系统不能被完全信任。在某个时候，有人决定隐藏一些东西，以便让它看起来不那么复杂。它*不是没有*复杂。让我们看看 Elm 和 Haskell 的例子。

#### [](#elm)榆树

埃尔姆实际上已经做对了*几乎*。事实上，它对我现在对这件事的看法起了很大的作用。它使用类型系统来“证明”不会有运行时~~错误~~异常。

当然，对于 Elm 来说很简单，因为它是 DSL(领域特定语言)。如果您想要 DSL 范围之外的东西，比如本地存储，那么您就不再受证明系统的保护。你必须使用端口，它是函数边界的一部分，也是进入不纯的、异端的 JavaScript 世界的一扇窗户。

尽管如此，Elm 的类型系统还是有漏洞的。问题在于它的公理，也就是我们用来创建更复杂程序的基本函数。例如，除以 0 会返回 0，所以函数*对初学者来说看起来*更友好。由于`x/0 = 0`无法证明 <sup>[环节](https://dev.to/drbearhands/extra-fundamentals-dividing-by-zero-1li5)</sup> ，导致证明无效，本质上是一种*无声失效*。复杂的行为仍然存在，但是它隐藏在证明系统之外。

#### [](#haskell)哈斯克尔

这将变得有点正式，但这就是关于 Haskell 的讨论的本质。如果你不明白，但想知道，请在评论中提问。
在 Haskell 中，`x`作为类型使用时，实际上表示`x` ∨ ⊥(读作“x 或底部”)。其中⊥是底部的*，这是一个类似错误的 <sup>[链接](https://bartoszmilewski.com/2014/11/24/types-and-functions/)</sup> 。这样做的动机本质上是停机问题:你不能证明用图灵完全语言 <sup>[link](https://en.wikipedia.org/wiki/Halting_problem)</sup> 编写的每一个程序都是终止的。“∞⊥”用于表示计算可能不会终止。异常也是基于⊥的，因此允许在纯函数中出现，这就给证明系统带来了异常。*

 *这种方法有几个问题。
第一，不终止不是价值观。它是函数的一个属性。用一个值来表示它似乎是虚伪的。数学上很方便，但远离现实世界。函数的类型是证明/箭头，存在于 Hask 范畴(不能被证明终止)，不一定存在于 Set 范畴(可以被证明终止)。另一方面，异常*是*值，并且在两个类别中都应该是*显式的*。

其次，我们可以证明绝大多数函数的终止性。我写过的几乎所有东西都是由 O(1)运算，O(n)映射，O(n)折叠和 O(log n)归约组成的。我不记得曾经写过 O(？？？)不是 IO 循环的程序，无论如何它不能被函数类型系统覆盖。如果这确实是一个通用的模式，我们应该区分 Set 中的函数和 Hask 中的函数，因为这将为我们提供关于前者的额外的安全性。

第三，没有人会想要运行一个潜在的非终止函数。有一个点，我们说“他妈的，这花了太长时间”，然后拔掉插头。终止在实践中会被强制执行，所以即使是全功能编程*对绝大多数用例来说也应该是足够的。*

Haskell 也有`unsafeCoerce`和`unsafePerformIO`，但至少那些可以用静态分析轻松检测出来。

## [](#5-expand-the-scope-of-proof-systems)5。扩大证据制度的范围

我们已经讨论过在类型系统中添加效果证明和终止证明。我们可能想要证明更多的品质，特别是如果我们有前面提到的“什么”和“如何”的分离。每一个证明都增加了类型的维度，就像效果给函数增加了一个维度。我举几个例子:

#### [](#complexity)复杂程度

函数式编程充满了复杂性可以轻易证明的例子。设`C(f)`表示`f`的复杂度，则我们有:

*   `C(map f) = O(n * C(f))`
*   `C(fold f) = O(n * C(f))`
*   `C(reduce f) = O(log n * C(f))`

根据我过去的经验，我认为这些操作，结合 O(1)原语，将覆盖 90%的情况。

#### [](#vectorization-etc)矢量化等。

我们还可以确定一个程序是否可以矢量化(如果它可以在 GPU/SIMD 架构上运行):对于使用条件写回的 O(1)程序，我们总是可以的。如果`f`为 O(1)，则对于单个`map f`和`reduce f`相同。对于 FPGAs 和 VLIW 处理器也可以做出类似的论证。

#### [](#heap-recycling)堆回收

我们还可以证明单线程，这可以帮助堆回收 <sup>[链接](https://www.researchgate.net/publication/220989811_Heap_recycling_for_lazy_languages)</sup> 。虽然有人可能会争论堆回收，无论是使用特殊操作符还是唯一性类型，都应该对程序员明确，以避免缺乏优化，但是“什么”和“如何”的分离消除了这种争论。

#### [](#data-safety)数据安全

关于数据安全的推理只能在我们的证明系统范围内进行:例如，如果我们有一个内部完全安全的可执行程序，在同一台机器上运行的对手程序可能会利用该机器的漏洞(例如，缓存预测失误+计时攻击)来读取我们程序的内存。然而，让我们继续在类型/验证系统的范围内*存在的可能性。*

数据依赖在声明性语言中是显而易见的。假设我们将数据`x`标记为“敏感的”，如果我们有一个没有副作用的函数`f :: x → y`，我们知道`f(x)`也将是“敏感的”。我们可以用这个来追踪数据的去向。此外，我们可以添加一个公理`encrypt :: Sensitive PrivateKey → Sensitive x → String`来移除“敏感”标签。

类似地，我们只能允许标记为“NotAPassword”的类型被存储，公理为`saltAndHash :: APassword String → NotAPassword String`。

#### [](#other-stuff)其他东西

还有其他我们可能想表达的东西，可能很多是我没有想到的。例如，对浮点数求和是不正确的。它不仅比使用 reduce 慢，还会产生错误的值。累加器浮动可能变得如此之大，以至于每个单独加法的变化都因数值不精确而丢失。如果你不知道这一点:尝试反复添加`1.0f`到一个浮点变量。在某一点上，它将停止增长。在溢出之前。

## [](#6-dont-make-a-new-language)6。不要创造新的语言

我不认为所有这些都可以用一种新语言来实现。有相当多的实验领域要涉及。例如，ATS 有很酷的新功能，但它的语法相当令人不快 <sup>[链接](https://www.youtube.com/watch?v=zt0OQb1DBko)</sup> 。在定义语言原语时，我宁愿不担心语法。相反，我会创建一个框架来构建语言，它定义类型和术语的抽象形式，并处理一般的证明和组合。一个可以把不同语言/平台的编译器写成插件的平台。

## [](#conclusion)结论

我认为在元编程中有很多未开发的潜力，我正在认真地考虑建立一些东西，但这将是一个相当大的项目。如果你已经读到这里，我很乐意在评论中听到你对此事的任何想法。*