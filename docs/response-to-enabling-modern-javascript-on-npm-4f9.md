# 对“在 npm 上启用现代 JavaScript”的回应

> 原文：<https://dev.to/mikesherov/response-to-enabling-modern-javascript-on-npm-4f9>

## 问题

在[https://jasonformat.com/enabling-modern-js-on-npm/](https://jasonformat.com/enabling-modern-js-on-npm/)中，杰森·米勒提出了一个问题:

1.  假设一般的 JS 应用程序由超过 50%的第三方 JavaScript 组成，
2.  鉴于 npm 上的第三方代码(我们称之为库代码)通常仍然以 ES5 为目标，因为它仍然是最小公分母，
3.  考虑到 ES6 更具表现力并且有更多的内置功能，所以它产生的代码比 ES5 小得多，
4.  即使第一方代码(我们称之为应用程序代码)是 ES6 并且没有转换成 ES5，一般的应用程序也比它需要的要大得多！

## 解山水

这里任何解决方案的核心都是这样一个概念，即库作者必须能够自由地发布 ES6+作为新的最小公分母。是的，解决任何 JS 版本的差异构建都很重要，但我会特别指出 ES5 - ES6 悬崖是唯一重要的，因为 ES5 是“永不绿悬崖”。就是最后一个不常青的浏览器是 IE11，不支持 ES6。所有其他版本的差异将在较短的时间范围内发生，可能不太紧急。尽管如此，对于任何 JS 版本的通用解决方案在这里都是很重要的。总会有更多的悬崖。

我们还必须确定这里的参与者:

1.  应用程序开发人员，他们需要好的工具默认值，这样他们就可以得到仍然符合他们的浏览器支持声明的小应用程序包。
2.  库作者，他们需要工具作者的合理保证，工具将使应用程序开发人员基本上不费力地使用 ES6，以免他们受到仍然需要 ES5 的应用程序开发人员的反对和支持。
3.  编译器作者，特别是 Babel，Buble，TS，他们需要知道，如果他们可以让开发者免费使用 es6，库作者将会同意将 ES6 作为库的主要 npm 工件发布。

## 解决方案第 1 部分-转换节点 _ 模块

问题的症结在于，当前的编译器类(考虑到其突出性，我们将使用 Babel 作为例子)默认不接触 node_modules。除非你明确地告诉 Babel，否则它不会编译你的 node_modules。这是有充分理由的。第三方 node_modules 都已经是有效的 es5 了，所以在它们上面运行编译器实际上是无效的，如果试图编译一些不需要的东西，会减慢你的编译速度！此外，因为 Babel 不仅仅是一个 JS 到 JS 的编译器，事实上它有一个丰富的插件生态系统，你可能会在你的代码中使用实验性的建议或在你的代码中使用 React 转换，在 node_modules 上运行这些转换没有意义*也没有意义*。

有了这样的理解，现在让我们后退一步，想象一下我们*希望* Babel 做些什么来使生态系统迁移到 es6:

1.  允许应用程序开发人员指定目标环境(现在作为 babel-preset-env 提供)。也就是说，一个应用程序应该能够说“无论我所有的代码+依赖项是什么版本的 JS，我都希望将其转换为这些浏览器/环境的最低公分母的 JS 版本”。
2.  允许应用程序开发人员指定其他转换在第一方(或第二方)代码上运行。也就是说，除了说输出应该是 JS 的什么版本之外，应用程序 dev 应该能够说“我的第一方代码实际上是 JSX，而且，我所依赖的 node_modules 中的这些特定包实际上是 TS”，等等。
3.  获取所有已知的 stage 4 转换(也就是说，可以将任何 ES6+代码转换为 ES5 的所有转换)，删除目标环境不需要的转换，并在所有 node_modules 上运行那些还没有被上面的步骤 2 处理的转换。

这将意味着使用 TS 或 Flow 或 JSX 的库作者仍然必须转换到 JS，但不一定是 ES5！库作者可以自由地发布 ES6，因为他们知道流行的工具会将他们的 JS 降低到正确的目标。

现在，从正确性的角度来看，我认为这是可行的，但是我们如何解决构建性能问题呢？如上所述，突然编译所有 node_modules 肯定会降低构建速度。如果库作者愿意发布一个机器可读的文件，宣布他们是什么版本的 JS，类似于 package.json 的“engines”字段，那么如果 Babel 能够确定该库是一个小于或等于应用程序所需版本的 JS 版本，它就能够摆脱 transpiling。事实上，Babel 理论上可以生成这个文件。它可以有一种模式，在这种模式下，不需要实际转换到 es5，它只是记录哪些转换不是无操作的，并将它们写入文件，供以后运行 Babel 时使用。不过，为了简单起见，编写“ES2019”可能比编写“polyfill Array.flat”更简单，并运行所有 ES2018 转换，然后...”该文件还将帮助检测 JS 版本的库是否是您的 Babel 版本尚未转换的版本，并可以警告应用程序开发人员进行升级。

## 解决方案第 2 部分- ES6 准备日

随着 Babel 和其他编译器现在如所描述的那样运行，我们将目光投向了库作者。既然编译器可以帮忙，我们如何让他们停止发布 ES5 呢？

虽然我们可能会认为 npm 是一个庞大的依赖关系宝库，触手可及，但事实上，有一些*真的真的*常见的依赖关系，在这些天发布到浏览器的内容中占了很大的比例:【https://www.npmjs.com/browse/depende】T2

如果我们能说服最依赖的软件包进行切换，难道我们不能说我们完成了任务吗？

谢天谢地，有现有技术...“我能用 Python 3 吗？”这就是 Python 3 的情况。Python 3 是 Python 2 的一个巨大飞跃，多年来，社区一直冻结在 Py2 上，因为非常流行的软件包还没有推出 Py3。社区最终联合起来，开始发布网站，简单地列出顶级 Python 包以及它们是否支持 Py3:[http://py3readiness.org/](http://py3readiness.org/)https://python3wos.appspot.com/[T3】](https://python3wos.appspot.com/)

也许作为一个社区，我们可以做类似的事情...有了编译器生态系统的支持和一个简单的请求“请发布 es6 而不是 ES5，如果有必要，编译器会为你降级”，我们建立了一个网站来跟踪前 500 个 npm 包朝着这个目标的进展。我们定了一个射击的日期。我们宣布 2020 年 1 月 1 日(或更合理的日期)为争取 50%(或更合理的百分比)的日期。当然，你可能会得到前 20 名和一些 profilic 出版商的承诺，这将是一个巨大的开端:-)

## 把所有的东西放在一起

总之，如果我们首先确保编译器可以将 node_modules 中的任何版本的实际 JS(第 4 阶段语法，无自定义转换)转换为应用程序开发人员所需的版本，它将解除库作者现在在 es6 中发布的能力，而不会使应用程序开发人员跳过配置环来获得依赖关系。如果我们也为库提供一个公共的格式来声明它们的 JS 版本，我们可以克服构建速度的问题。有了这个畅通的渠道，我们就可以将目标社会化，并获得顶级 lib 作者的公开承诺，在一个有抱负的时间框架内迁移到 es6。希望很快有一天，降级到 ES5 会像降级到 ES3 一样没有必要！

这将涉及到从编译器(不仅仅是 Babel，还有 pika、Buble、Typescript 等，可能还有 Yarn 或 npm 这样的安装程序)和顶级软件包作者以及社区倡导者那里获得广泛的支持。这并不容易，但如果我们达成一致，这是可行的。

当然，上面的描述中有一些细微的差别，但作为一个整体策略，这似乎是一种向前推进的明确方式，而不是“等待 IE11 死亡”因为即使这样，随着 ES5 悬崖的到来，未来的悬崖总会出现，即使它们不那么严重。

想法？