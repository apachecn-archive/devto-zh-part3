# 走向零 bug

> 原文:[https://dev.to/conw_y/towards-zero-bugs-1bop](https://dev.to/conw_y/towards-zero-bugs-1bop)

我的个人和职业使命是编写无 bug 代码。

零缺陷的软件看起来是一个雄心勃勃的目标。随着时间的推移，软件中的缺陷越来越多，并且变得如此正常，以至于一些开发人员和用户甚至期待它们。

虽然很难达到零错误，但我认为值得一试。我们不应该认输，并预先假定我们的产品会有缺陷。相反，我们应该尽我们所能避免在软件中不经意地产生错误，而这些错误是可以避免的。我们越接近零动物，越好！

随着时间的推移，我已经在心里建立了一个清单，列出了我编写的代码和运行的应用程序中需要注意的事情，以识别潜在的错误。现在，每当我要完成一个变更或一个新特性的工作时，我都会浏览这个清单。我也一直致力于建立一种鼓励自律、严谨和关注细节的心态。

通过运行这些检查并建立这种心态，我的目标是尽早识别并修复 bug，而不是让它们出现在测试环境中，或者更糟，出现在最终用户面前。

我很乐意与其他开发者分享这一点。请阅读并在评论中告诉我你的想法！

## [](#the-checklist)检查表

事不宜迟，以下是我的清单:

**错别字，意外击键，调试语句。**每次你要提交时，停下来一会儿，回顾一下正在发生的变化。确保你只承诺你完全打算承诺的事情。检查打字错误、意外击键、疏忽的大写等。编译器或 linter 通常可以发现这些问题，但是经常会遗漏一些情况，所以花几秒钟浏览一下这些差异还是值得的。还要检查只用于开发的代码，比如日志或调试语句，它们通过了编译，但不应该被签入。

**细微的逻辑错误。**寻找所有那些*看起来*合理的代码，对第一眼和编译器来说，但实际上是错误的或不正确的。
例如:

*   假阳性。比如:`if (!hidden) { show(); } else { hide(); }`。观察`!hidden`实际上相当于可见。所以这段代码实际上会在可见时执行`show()`，在不可见时执行`hide()`！为了纠正这一点，我们想要去掉`!`，得到类似于`if (hidden) { show(); } else { hide(); }`的东西。留意这些微妙的逻辑错误是很重要的。
*   表达式被强制为不正确的布尔值。例如，在 Javascript 中，一个`indexOf(x)`调用不与任何东西进行比较，而应该与一个数值进行比较。实现这一目的的一个正确(也更清晰)的方法可能是调用`includes(x)`，而*会让*返回一个布尔值。
*   一个一个的误差。比如:`for (let i = 0; i <= 10; i++) { ... }`。该循环运行 11 次迭代，而它可能需要运行 10 次。改写成:`for (let i = 0; i < 10; i++) { ... }`会更清楚。
*   过滤操作。您可能执行了一个过滤功能，但是意外地从一个列表中提取项目并只返回那些项目，而您的意图是返回完整的列表*包括*那些项目。或者，您的代码可能会返回除某些项目之外的所有内容，但如果这些项目存在，则您的意图是不返回任何内容。在这方面还有许多其他的变化。总之，仔细检查复杂的过滤操作。

**边缘病例。**要找到这些，试试破你的 app。

*   快速连续点击用户界面的许多不同部分。
*   测试长的动作序列，确保最后的结果完全符合预期。例如，通过执行一个动作，然后撤销它，再重做它，多次，然后验证最终结果，来彻底测试撤销/重做。
*   以意外的格式输入意外大量的值或 null/空值。
*   使用格式正确但不合逻辑的值进行测试(例如，一个月的 32 号)。
*   向列表中添加超出正常数量的项目。
*   一次运行应用程序的多个实例，并验证它是否仍能正常工作。

基本上，尽一切可能破坏您的应用程序，并确保它在所有情况下都能正常恢复。如果您有大量可能的输入组合要测试，单元测试绝对是您的好朋友！

**数值与参考值。**你期望一个值在一个地方设定，在很多其他地方更新吗？还是希望在多个地方保存该值的独立副本？回顾你对引用和值的使用，确保它们对你的用例是正确的。

**内存泄漏。由于不正确和无限制的内存分配，这些会显著降低应用程序的速度，甚至导致其崩溃。这些可以以多种方式表现出来，这取决于您正在开发的语言和环境。
例如:**

*   在 C#或 Java 中，它可能是未被清理的非托管资源。
*   在多线程应用程序中，死线程。
*   在 Javascript 中，映射引用不再存在的 DOM 节点。
*   在 RXJS 中，您忘记取消订阅的可观测量的订阅。

除了手动检查代码之外，几乎每个环境都有自己的一套诊断内存泄漏的工具。比如，对于。NET 中有一个内存分析器，对于 Javascript，大多数浏览器中的开发工具都有一个内存标签或类似的标签。

**代码执行过于频繁。**你是否在一个 for 循环、一个游戏循环、一个模板、一个渲染循环或者任何其他连续执行多次的代码库中执行不必要的操作？这可能会导致你的应用程序变慢，如果变得太糟糕，可能会被认为是错误的行为。可能不需要运行的代码包括每次迭代都生成相同结果的代码(在这种情况下，某种形式的缓存是您的朋友)或只在特定状态下需要的代码(在这种情况下，该状态周围的简单`if`语句可以在不需要时跳过代码)。

【相同】相同但不同。当你有两件看起来和行为非常相似，但性质不同的东西时，要格外小心。我最近遇到的这种情况的一个例子是构建两个树视图，这两个视图描述了基本相同的数据，但每个视图上的可视标记略有不同。这些视觉标记突出了相同数据的相反方面。但是，由于错误，我还对其中一棵树进行了编码，使其颠倒了元素的顺序！这个 bug 应该很明显，但是我没有注意到。我太专注于得到正确的标记(差异)，以至于忘了确保顺序正确(相同)。回想起来，如果我当时回头仔细检查最终结果有*对*的差异，而不是*错*的差异，我本可以早点发现并解决这个问题。

无效支票。无论何时比较两个值，如果需要的话，你是否对比较的两边都进行了空值或者未定义的检查，如果其中一个或者两个都为空值，你该如何处理？根据需要添加检查。

**异步数据依赖。**您的应用程序是否依赖于多组数据，这些数据可能会在不同时间加载？当不是所有的数据都被加载时会发生什么？应用程序崩溃了吗？或者它是否优雅地处理这种情况，也许等到所有数据都加载完毕，同时显示一个“正在加载”的指示器？您可以使用语言的“延迟”机制，通过向数据源之一临时添加延迟来模拟这种状态。比如调用 Javascript 的`setTimeout`方法，RX 的[延迟运算符](http://reactivex.io/documentation/operators/delay.html)或者。网的`Thread.Sleep()`。当然，在签入之前要注意恢复任何测试代码！

浏览器/操作系统升级。根据您的开发环境，当一个新版本出现时，要意识到对该环境进行突破性改变的可能性。每当有新版本发布时就进行升级，并在新版本中测试您的应用程序，寻找 bug。最近，随着 Chrome 72 中 Flexbox 的[变化，我体验到了这一点的重要性，这使得一些 CSS 变化成为必要。](https://bugs.chromium.org/p/chromium/issues/detail?id=927066)

**设备、屏幕尺寸和缩放系数。**如果需要，使用多种设备测试您的应用，包括移动设备、平板电脑和/或桌面设备。您可能还需要检查这些设备上的多种浏览器以及这些设备的多种版本和外形。此外，尝试增加/减少缩放级别，并确保布局、大小等仍然是成比例的。

**可达性。在软件应用领域，易访问性的缺陷甚至缺失是一个主要问题。如果你的应用程序将被广泛的人群使用，你可能应该确保它是可访问的。理想情况下，可访问性从一开始就是“固定的”,但是这并不能消除定期严格测试可访问性特性工作的需要。在我自己的可访问性审计中，我关注三个主要方面:A)仅键盘操作，B)非可视操作，C)遵守 WCAG。这三个方面的基本测试可以在任何网页上进行，方法是 A)推开鼠标，尝试使用无键盘的应用程序，B)将目光从屏幕上移开，尝试仅通过屏幕阅读器来使用应用程序，C)运行 [Wave](https://wave.webaim.org/extension/) 自动化测试工具并检查其输出。类似的测试可以在非 Web/本机应用程序上运行。我计划写一整篇文章专门讨论这个话题，因为它很大。在此期间，您可以查看一些优秀的资源，如[的](https://www.w3.org/WAI)的[轻松检查](https://www.w3.org/WAI/test-evaluate/preliminary/)页面。**

**日期和时间的处理和格式化。测试与日期或时间有关的代码时要格外小心。如果代码正在对日期/时间值执行某种计算，请尝试用各种输入来测试它，并确保它总是产生正确的结果日期/时间。此外，测试它在不同的时区工作。要在本地做到这一点，您可以临时更改您的系统时区，重新加载您的应用程序并重新测试日期/时间特性。**

**数值，如货币。**与日期/时间一样，彻底测试应用程序处理数字的任何方面，尤其是特定于地区的数字，如货币值。

**负载测试。**当大量物品通过系统时，系统会崩溃吗？用几千甚至几百万条记录替换一个假数据源，看看应用程序是否能处理这样的负载。

需求与解决方案。仔细检查最初的需求，看看你是否真的解决了它们。你可能忽略了语言中的微妙暗示，或者你还没有澄清的一些歧义。如果您需要回到业务中来澄清这些问题，那么尽可能早地这样做，这样您就有更好的机会在发布代码之前修复代码中的任何 bug。

点击刷新。有时，由于我不完全理解(也许也不希望理解)的原因，一个正在运行的应用程序会与生成它的代码不同步。是的，即使在使用自动编译工具时，这种情况也会发生。在 web 应用程序的情况下，资产缓存可以发挥作用。对于本机应用程序，进程可能保持打开。我有时会花半个小时或更长时间来试图找出为什么有些东西不工作，或者为什么我不能重现一个 bug，却发现我正在使用的版本已经过时了。长话短说:当有疑问时，点击重启和刷新。

**多重环境。**大多数组织都有多个环境，软件以分阶段的方式部署到这些环境中。有本地开发机器，然后是开发服务器，然后是阶段和/或 QA，然后是生产/发布/现场。在每个环境中对您的应用程序运行一些测试是一个好主意。如果您的特性或更改依赖于特定于环境的因素，例如配置值、数据库模式、数据和其他系统、服务或资源，这一点尤其重要。在新的环境中，任何事情都可能出错，从配置值的输入错误到资源授权的丢失。您不必在每个环境中测试所有东西，但至少测试一下快乐之路可能是个好主意。

找到类似的错误并修复它们(并推广修复方法！).最近出现了这个问题，一位同事发现了一个错误，在这个错误中，错误的属性被用来从 HTTP 响应中检索错误消息。我测试了代码库中从 HTTP 响应中检索到错误消息的所有地方，并在必要的地方修复了它们，而不仅仅是修复了一个响应。然后，我更进一步，通过将 HTTP 错误处理提取到一个公共函数中，对修复进行了概括。因此，通过改进整体框架，不仅消除了额外的错误，而且防止了将来类似的错误。

## [](#the-mindset)心态

这个清单可能看起来令人生畏，尤其是在时间有限的情况下。但是，您不必为您所做的每一项更改都执行所有这些项目。我通常会快速浏览一下这个列表，只挑选出与我所做的改变相关的项目。例如，改变计算数值的逻辑可能不需要检查“设备、屏幕尺寸和缩放系数”。同样，对于对话框布局的改变，我可以跳过“异步数据依赖”。

“旧”的思维模式(我有时在行业中看到)是:

*   我假设我的代码默认没有错误。
*   优秀的开发人员从不写有错误的代码，所以我不应该花太多精力检查我的代码是否有错误，否则我可能会发现我是一个糟糕的开发人员！
*   永远没有足够的时间来检查错误，所以我别无选择，只能发送错误代码。
*   随着经验的积累，我的代码自然会越来越可靠。
*   测试和修复 bug 是枯燥、乏味且不好玩的。
*   彻底测试和修复错误没有任何回报。
*   软件开发是不重要的，卑微的“繁重的工作”，所以如果我们做错了也没关系。

我想传播的“新”思维模式，我认为更有成效，是:

*   我的代码是错误的，除非证明不是这样。
*   成为一名优秀的开发人员的一部分是要有纪律和耐心来检查我写的代码，这些代码看起来很好——甚至很壮观——并找到和修复我知道可能潜伏在其中的所有错误。
*   几乎总是有一些额外的时间投入到寻找和修复 bug 的诚实努力中。
*   投入定期、持续的努力来编写可靠的代码将使我的代码更加可靠。
*   通过积极的心态和一点点“游戏化”,测试和修复 bug 可以变得很有趣。我可以享受修复一个 bug 的兴奋感，并且知道我留下的代码比我发现的要好。
*   测试和修复错误的回报是建立精神肌肉(纪律、严谨、注意细节等)，这将产生更可靠的软件。这些肌肉将推动我在解决问题的各个方面前进，而不仅仅是修正错误。此外，我可以建立一个可靠软件开发人员的声誉，这可能对我的职业生涯有好处。
*   软件开发是一种职业和手艺，我们应该为我们的工作感到自豪。

## [](#let-a-thousand-checklists-bloom)让一千个清单开花！

你有这样的清单吗，不管是书面的还是心里的？你还想在这份清单上添加其他项目吗？关于编写可靠、无错误代码所需的心态，你有什么要补充的吗？

请随意评论你的清单和经历，或者在评论中链接它们。分享我们开发人员可以使用的任何想法将会很棒，以便更接近编写无错误代码。

感谢阅读！

* * *

一些启发我的资源:

*   代码完成(史蒂夫·麦康奈尔)
*   务实的程序员(安德鲁·亨特，戴维·托马斯)
*   干净代码(鲍伯·马丁)
*   清单宣言(阿图尔·加万德)