# Koping 与 KDB 001:名单逆转

> 原文:[https://dev . to/alifaizankazmi/koping-with-kdb-001-list-reversal-3079](https://dev.to/alifaizankazmi/koping-with-kdb-001-list-reversal-3079)

##### [](#estimated-reading-time-10-minutes)预计阅读时间:10 分钟

***前言**:大家好(圣诞快乐)！欢迎来到关于 [kdb+](https://code.kx.com/q/) 的系列帖子的第一篇——这是一个高性能的列数据库，加上它的查询语言 *Q* ，在 FinTech 的一些领域得到了广泛的应用。最近，kdb+也被应用于 FinTech 之外的[机器学习](https://kx.com/blog/detection-of-exoplanets-at-nasa-fdl-with-kdb/)。*

我的叙述技巧有时可能是非线性的:例如，一个章节的标题可能没有意义，除非你已经阅读了该章节的部分或全部；从代码片段中可能看不出我想要实现什么；或者我可能建立了一个解决方案，但在下一个瞬间就抛弃了它。这是故意的。如果这给你阅读带来任何不便，那么请告诉我，我很乐意采用更线性的方法。

最后，Q 中有一个内置函数来反转一个给定的列表，但我们不会使用它。我们将提出自己的解决方案，并在此过程中学习一些东西。

我在学习 Q/kdb+时学到的第一条规则是，Q/kdb+解释器从右向左计算表达式，即使表达式是从左向右输入的。例如，以下表达式的结果:

```
2*3+3 
```

是`12`，因为加法运算符及其操作数首先被求值，加法的结果依次成为*运算符的第二个操作数。

听起来够简单吗？我当然这样认为，直到几分钟后我的额头落在我的手掌上。

## [](#recursion)递归？

我试图定义一个简单的函数，如果将一个列表作为参数传递给它，该函数将返回 true:

```
isList: {[object] type object = 7h} 
```

以下是外行人对上述内容的分类:

*   :是赋值运算符
*   函数定义封装在花括号中
*   函数的参数封装在函数定义内的方括号中
*   =是相等运算符(因为:负责赋值)
*   kdb 中的每个数据类型都由一个特殊的 16 位整数表示。在这种情况下，我们想要表示列表数据类型的整数- 7h(嗯，[不完全是](http://code.kx.com/q/ref/datatypes/))
*   通常，kdb 中的非 niladic 函数是通过传递一个或多个方括号中的参数来调用的。这对于一元函数来说是可选的——就像上面的`type`函数一样

回到我们的函数定义。如果你像我一样，没有立即注意到哪里出了问题，那么下面就是这个表达式

```
type object = 7h 
```

是从右向左计算的，这意味着表达式根本没有执行预期的类型检查！从右到左，此表达式包含两个按以下顺序计算的内部表达式:

```
type (object = 7h) 
```

因此，`object = 7h`计算出一个布尔值(`0b`或`1b`)，然后作为`type`函数的参数。难怪当我们用一列数字调用函数时，会得到下面的结果:

```
isList 1 2 3
-> -1h 
```

`-1h`是布尔数据类型的数字表示。

* * *

顺便说一下，kdb 中的列表通常用圆括号括起来，并用分号来分隔列表项。然而，圆括号和分号可以被删除，因为一列*原子*(在 Java 等语言中被称为原语)，其中每个原子都是相同的数据类型。

* * *

以下是该函数的修正版本:

```
isList: {[object] 7h = type object} 
```

当用一列数字调用时，它给出了我们预期的结果:

```
isList 1 2 3
-> 1b 
```

你会问，我为什么想要这样一个函数？因为我想最终定义一个函数，它将一个列表作为参数，并以相反的顺序返回另一个列表及其元素。实现列表反转的一种方法是通过递归，让递归工作(或者，更准确地说，停止！)我们需要一个基本案例。在这个例子中，基本情况是我们已经将提供的列表减少到它的最后一个元素。

## [](#really-recursion)真的？递归？

等等，我们真的需要递归吗？假设 Q 是一种数组编程语言(除了别的以外)，我们能不能只将一个索引列表作为参数传递给我们的列表，以便获得一个新的反向列表？当然，我们需要确保索引列表也是反向的。但这应该不难。为了生成一个索引列表，我们可以使用`til`函数:

```
til 3
-> 0 1 2 
```

通过使用`count`函数，该函数可用于获取列表的有效索引列表:

```
list: 1 2 3
til count list
-> 0 1 2 
```

现在，如果我们能颠倒索引列表，那么我们的问题就应该解决了:

```
list 2 1 0
-> 3 2 1 
```

下面是一个逆转这个列表的策略:

*   最大有效索引是`-1 + count list`(难道只有我一个人最先想出了`count list - 1`？)
*   从最大有效索引中减去一个按升序排序的索引列表将产生一个反向包含相同索引的列表

在我们的案例中:

```
indices: til count list
2 - indices
-> 2 1 0 
```

很好，现在我们需要将所有这些打包成一个函数。我们不能命名我们的函数`reverse`,因为这个名字已经被保留了(对于一个函数，我还不敢找出它的定义)。函数如下:

```
reverseList: {
    [list] list (-1 + count list) - til count list
} 
```

这似乎是正确的:

```
reverseList 1 2 3
-> 3 2 1

reverseList "level"
-> "level"
reverseList 1 0 1
-> 1 0 1
reverseList "Eva, can I stab bats in a cave?"
-> "?evac a ni stab bats I nac ,avE" 
```

抱歉，我被回文冲昏了头脑。

```
reverseList 110b /List of booleans (incidentally, this is a comment)

-> 011b

reverseList 2018.09.23 2018.09.22 2018.09.21

-> 2018.09.21 2018.09.22 2018.09.23 
```

## 
 [](#is-our-solution-good-enough) 
我们的解决方案够好吗？

几乎没有。为什么我们必须创建一个新的列表(即，反向的索引列表)来反转一个给定的列表？此外，我不喜欢首先使用 parantheses 来强制对表达式求值——这表明相对于 Q 的从右到左求值，我仍然涉世不深。也许我应该尝试一下递归，或者随着我继续研究 Q 并慢慢摆脱命令式/非数组编程范例的束缚，找到一个更好的解决方案。