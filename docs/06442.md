# 如何用 Liquibase 管理大型数据库模式

> 原文:[https://dev . to/matmooredev/how-to-management-a-mega-database-schema-with-liqui base-d6d](https://dev.to/matmooredev/how-to-manage-a-huge-database-schema-with-liquibase-d6d)

在过去的几周里，我一直致力于将 [Liquibase](https://www.liquibase.org/) 引入到一个现有的项目中，这样我们的数据库模式就在代码中定义了，我们可以为开发和测试创建数据库的副本。

这是很多 web 框架(如 Rails、Django、Dropwizard 等)都有的东西。但这是一个较老的项目，其中数据库随着时间的推移而增长，并且更改传统上由 DBA(数据库管理员)管理。

数据库迁移背后的基本思想是永远不要在数据库中直接更改数据库模式；相反，您可以编写脚本来更改它，该工具以一种受控的方式将它应用于数据库，以便数据库始终处于已知的状态，并且将更改签入 git 并像常规代码一样进行审查。

# [](#what-this-allows-us-to-do)这能让我们做什么

我想让任何人都可以检查应用程序并建立自己的数据库，如果出现任何问题，他们可以随时丢弃它并重新开始。目前，我们在 AWS 中共享一个开发数据库，这也是我们运行自动化测试的地方。没有什么能保证这仍然像生产一样。

如果我们采用数据库迁移，我们可以使用像 [CircleCI](https://circleci.com/) 这样的工具来自动构建一个全新的数据库，并针对每个 pull 请求运行我们的测试，这将给我们一些信心，即数据库的更改没有破坏应用程序中的重要功能，反之亦然。

最后，如果我们使用 liquibase 进行生产部署，我们可以加快发布速度，并消除人为错误的根源，如遗漏部分迁移或在不同的环境中做不同的事情。

# [](#how-we-structured-the-migrations)我们如何构建迁移

我们选择 liquibase 是因为它非常灵活。我们有很多存储过程，liquibase 有一个`runOnChange`特性，允许我们在它们的散列改变时自动`CREATE OR REPLACE`它们。因此，你不需要为这些文件的每一个变化都写一个迁移脚本，你只需要运行`liquibase update`，它就会应用更新。

使用 liquibase，您可以将所有的迁移编写为带注释的 SQL 文件，因此您不需要学习特殊的语法，并且您可以在 SQL 中做任何可能的事情。

我们做的第一件事是从生产数据库中导出所有对象，并将其转换成 liquibase 迁移格式。我们将东西分成 3 个目录:

*   `initial_schema`
*   `code`
*   `schema_migrations`

其中`initial_schema`是我们现在拥有的所有表、约束和索引。

一旦我们有了这个匹配的产品，我们打算在`schema_migrations`中切换到创建小的、带时间戳的变更迁移。

`code`包含了我们和`runOnChange`一起使用的所有对象。这允许我们使用 github 查看所有存储过程的历史。

# [](#adding-migrations-to-an-existing-project-is-hard)向现有项目添加迁移非常困难

我想当我们开始这项工作时，我们低估了工作量。理论上，这听起来很容易:导出模式，将其转换为正确的格式，工作就完成了。

实际上，我们在以下方面花费了大量时间:

*   让我们的初始模式真实地反映生产(并检查这一点)
*   确切地决定什么在范围内(我们的数据库中有多个用户/模式，应用程序并不需要所有的用户/模式，所以我们必须弄清楚应用程序的边界到底在哪里)
*   找出 Oracle 允许我们在不出错的情况下运行的顺序

早先，我们注意到 Oracle 将允许您创建“无效”的对象(例如，它们引用了不存在的其他对象)。为了防止这种情况，我们添加了一个 liquibase“前提条件”,它运行`SELECT count(*) FROM all_objects WHERE status = 'INVALID'`,如果计数不为零，就停止迁移。

我们还故意暂时将数据库中一些不规则的部分排除在初始模式之外。这些功能包括发送电子邮件和上传文件(所有这些都在数据库中实现)。我们预计，在当地以一种合理的方式实现这些功能将需要大量的额外工作。我们可能不需要做这一点就可以获得大部分的好处，而且我们总是可以在以后添加缺失的部分。

# [](#making-the-app-easier-to-work-on)让应用程序更容易使用

最终，这样做的目的是让应用程序更容易运行。再做一点工作，我们就可以完全消除对共享开发数据库的需求。我们可以编写可以在开发过程的任何阶段运行的存储过程的测试。我们可以自动化整个部署。所有这些都有助于减少我们为了完成某件事而浪费在无价值任务上的时间。