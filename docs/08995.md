# 去抖深度潜水— JavaScript ES6

> 原文:[https://dev.to/tcase360/debounce-deep-dive-JavaScript-es6-2g 70](https://dev.to/tcase360/debounce-deep-dive--javascript-es6-2g70)

最近，很多人问我如何实现去抖功能，我想知道为什么这个问题在前端工程界如此普遍。

这个问题问得越多，我就越想为什么会问这个问题，我想出的推理很有道理:

*   它测试你对 JavaScript 的更深层次的知识
*   有一个实际的，真实世界的应用
*   这些都是现代前端开发中常用的

* * *

环顾四周，关于去反跳功能内部工作方式的信息并不多，这令人惊讶——我知道下划线有去反跳和节流的实现，但我确实认为在广泛使用它们之前，深入了解它们在做什么是很重要的。这篇博客的目的是解释 JavaScript 在这个(虽然简单)实现中的细微差别。关于实现这些功能的“正确”方法有很多观点，这篇博客文章不是关于这个的。所以事不宜迟，让我们开始吧。

## [](#purpose-of-debounce)去抖的目的

这个函数是为了限制函数被调用的次数而构建的——滚动事件、鼠标移动事件和按键事件都是我们可能想要捕获的事件的很好的例子，但是如果我们在它们每次触发的时候都捕获它们，可能会很费力。为了解决这个问题，我们实现了去抖和节流功能。我们不会在这篇文章中讨论 throttle 函数，但是去抖函数会等到最后一次调用该函数，然后在预定的时间量之后或者一旦事件触发变得不活动时触发。

* * *

## [](#implementation)实现

让我们来看看 ES6 中的去抖功能实现。

```
const debounce = (fn, time) => {
  let timeout;

  return function() {
    const functionCall = () => fn.apply(this, arguments);

    clearTimeout(timeout);
    timeout = setTimeout(functionCall, time);
  }
} 
```

让我们一步一步来看看这个:

1.  创建一个带有两个参数的包装函数:一个回调函数和一个用于超时的整数——它将保存超时的状态。请注意，在引用包装函数时，包装函数只会被调用一次。
2.  声明`timeout`变量，该变量将为`undefined`，直到在返回的函数中设置超时。
3.  返回一个函数——每次调用该函数时都会调用这个函数。确保返回的函数不是箭头函数，因为这样会丢失上下文。
4.  将`this`上下文应用于回调函数，并附加参数。
5.  `clearTimeout`如果超时存在。
6.  `setTimeout`并传递应用的函数。

这样，`clearTimeout`会在每次调用函数时重置超时，如果在规定的时间内函数没有被调用，那么它将最终触发该函数。

使用该函数将如下所示:

```
window.addEventListener('keyup', debounce((e) => {
  console.log(e);
}, 1000)); 
```

传递的第一个参数是事件处理程序，第二个参数是在最后一个事件被触发后我们认为元素“不活动”的时间(以毫秒为单位)。

## [](#explanation)解释

这个函数有几个部分可以作为 JavaScript 的学习点:

*   返回的函数将接受事件处理程序应该获得的参数——即使它们没有在函数声明中显式声明。只需使用在函数内部自动创建的 arguments 变量。
*   fn.apply 非常方便，非常适合这种情况，因为我们并不总是知道提供了多少参数，因此我们可以发送完整的对象。这也将保持我们函数的上下文。
*   functionCall 变量必须在返回的函数中声明，这样我们就可以用正确的参数调用它。
*   我们必须声明超时变量，因为如果我们不将变量传递给 clearTimeout，那么它将全局清除超时，我们不想干涉全局范围，以避免不必要的副作用。

## [](#conclusion)结论

这是一个跨越 11 行的看起来简单的解决方案的问题，但是它涵盖了许多不同的概念，如果做得正确，可以显示对 JavaScript 更深入的理解，比如持久化`this`、返回函数和`.apply()`方法，所有这些都封装在一个可以在现实世界中使用的实际问题中。