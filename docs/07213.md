# 为什么要学习...关于媒体类型

> 原文:[https://dev.to/gypsydave5/why-learn-about-media-types-2f3o](https://dev.to/gypsydave5/why-learn-about-media-types-2f3o)

媒体类型用于传达通过 web 发送的数据类型。它们被使用

*   在 HTTP 响应中声明发送的内容类型
*   在声明客户端可以解释哪种内容的请求中
*   在 POST 请求中声明要发送的内容类型。

基本上，只要网络上有数据，就会有一种媒体类型来告诉你这是什么样的数据。如果没有，那就应该有。

这篇文章将解释如何解释一个媒体类型，也解释它们如何在 HTTP 头中使用，以确保我们得到我们可以理解的数据。

*   这是给谁的？
*   [我以前在哪里见过媒体类型？](#where-have-i-seen-media-types-before)
*   [媒体类型语法](#media-type-syntax)
*   [HTTP 消息头中的媒体类型](#media-types-in-http-message-headers)
*   [内容协商](#content-negotiation)
*   [滚动您自己的媒体类型](#roll-your-own-media-type)
*   [总结](#summary)
*   [Q 和 A](#q-and-a)

## [](#who-is-this-for)这是给谁的？

这是为有兴趣了解如何在 web 上移动数据的 web 开发人员准备的。HTTP 的一些知识，特别是头，是有用的，但不是必需的。

## [](#where-have-i-seen-media-types-before)以前在哪里见过媒体类型？

我第一次看到媒体类型是在我写第一个 HTML 文件的时候——专门为了弄点 CSS: <sup id="fnref1">[1](#fn1)</sup>

```
<link rel="stylesheet" src="style.css" type="text/css" /> 
```

这是我们的第一种媒体类型。

下一次我遇到他们是在我从服务器返回 JSON 的时候:

```
response.contentType = "application/json" 
```

还有一个——`application/json`。

所以它们对我们来说并不完全陌生——它们是“文件充满了 CSS”和“我正在给你发送一些 JSON”的一种说法。当我们看语法时，让我们用这两种类型作为例子。

## [](#media-type-syntax)媒体类型语法

媒体类型由两个由`/`分隔的字段组成。第一个是`type`，第二个是`subtype`。

我们马上可以看到 CSS ( `text/css`)有一个类型`text`和一个子类型`css`。`text`类型非常广泛，它表示媒体只是文本，涵盖了多种类型的内容，例如:

*   这就是你现在正在读的东西！
*   这只是普通的文本！
*   `text/markdown` -我在里面写的东西会变成`text/html`
*   `text/csv`...

你明白了。

`application/json`有一个子类型`json`，这是合适的，因为它*是* JSON。`application`类型告诉我们这是一个应该由应用程序处理的类型。这有点道理，因为它是 JSON，是计算机可读的。

(但是 CSS 不是只意味着由应用程序来处理吗？是的，它是。也许本来应该是`application/css`。也许本来应该是`text/json`。谁知道呢。媒体类型有点不靠谱。整个网络有点不稳定。不要太担心。作为一名 web 开发人员，一部分工作是学会忍受在我们出生之前就已经存在的大量混乱和模糊。学会忍受它。)

其他有趣的类型有

*   `application/pdf`对于 pdf
*   `application/zip`对于 zip 文件
*   还有很多很多...

### [](#all-the-types)所有类型

我们已经看到了`text`和`application`类型——以下是您可能会遇到的类型列表和示例:

| 类型 | 目的 | 例子 |
| --- | --- | --- |
| `application` | 供应用程序使用的媒体 | `application/json` |
| `audio` | 音频媒体 | `audio/mp3` |
| `font` | 字体格式 | `font/ttf` |
| `image` | 视觉媒体 | `image/gif` |
| `multipart` | 需要分部分发送的媒体 | `multipart/form-data` |
| `text` | 人类可读的文本 | `text/html` |
| `video` | 视频媒体 | `video/mp4` |

类型和子类型是媒体类型中唯一需要的部分，但也有一些可选部分。

### [](#parameters)参数

媒体类型可以在分号后标记一个参数列表，由用`=`分隔的键/值对组成。例如

```
text/plain;charset=UTF-8 
```

是一种使用 UTF 8 字符编码的`text/plain`媒体类型。如果我们想让我们可爱的表情符号发挥作用，我们需要记得说我们使用的是 UTF-8，否则客户会认为我们像 20 世纪 70 年代的穴居人一样用 ASCII 写。

参数类型不受媒体类型规范的支配， <sup id="fnref2">[2](#fn2)</sup> 并且您可以拥有任意多的参数类型:

```
text/plain;charset=UTF-8,blog-post=true,author=gypsydave5 
```

他们通过上下文获得他们的意思；例如，浏览器在通过 HTTP 读取媒体类型时，会寻找并使用一个`charset`参数。稍后再谈浏览器。

### [](#structured-syntax-name-suffix)结构化语法名称后缀

这个有点奇怪，但也很酷，所以请原谅我。看看这个媒体类型:

```
image/svg+xml 
```

这是 SVG 图像的类型——可缩放矢量图形。`image`是类型，`svg`是子类型——这就是我们所期望的。

但是这个`+xml`最后在做什么呢？您可能已经知道，SVG 是用 XML 编写的——这是它们最棒的地方之一。所以`+xml`告诉我们 SVG 的语法是 XML 可以说 XML 是 SVG 的“基础”语言。这被称为“结构化语法名”，这是一种很好的方式让我们知道，嘿，你可能不知道什么是 SVG，但是，没关系，它只是一个 XML，所以你会没事的。

(除非你是我，每次听到 XML 这个词都会惊慌失措，你会觉得有些人认为它是人类可读的，你希望整个世界都用 JSON 来表示，这是另一回事了...)

* * *

听着，我可以说你对所有这些媒体类型都很兴奋。现在你知道如何理解它们了，你可以阅读已经在 IANA 注册的所有媒体类型的列表。继续，现在把它们都读一遍。我会等的。

有很多，对吧？尽量不要惊慌——你可能最多只会用到 10 个。但是你看过 SNES 的电影吗？

## HTTP 消息头中的媒体类型

使用媒体类型最重要的地方是在 HTTP 消息中。您将使用它们来描述在 HTTP 请求的`Accept`头中想要的数据的媒体类型，以及在 HTTP 响应的`Content-Type`头中发送的数据类型。

### `Accept`标题

`Accept`头是客户端——就像你的浏览器——告诉服务器它想要什么样的内容的方式。

最简单的情况是这样的:

```
Accept: application/json 
```

如果我把这个放在请求的头中，我会让服务器非常清楚地知道我想要回 JSON。不问任何问题。 <sup id="fnref3">[3](#fn3)</sup>

但是，假设您想要从服务器返回一些音频，但是不介意什么子类型- `audio/mp3`对您来说和`audio/wav`一样好。在这种情况下你可以说:

```
Accept: audio/* 
```

代表通配符，意思是“给我任何东西”。服务器可以合法地回复带有*任何*子类型的`audio`媒体类型。

最后，如果你不在乎从服务器返回什么，你可以只说

```
Accept: */* 
```

### `Content-Type`标题

`Content-Type`是应该添加到 HTTP 响应消息中的头，用来告诉客户端他们在响应正文中得到什么。这就是客户如何知道如何解释你发送的信息。

`Content-Type`头应该有一种媒体类型，所以可以像下面这样简单:

```
Content-Type: text/html 
```

希望这就是你正在阅读的页面的内容类型。

* * *

### [](#wait-cant-i-just-use-a-file-extension)等等，我不能只用一个文件扩展名吗？

你可以想象你已经得到了一些数据，你可以通过一个 URL:

```
http://gypsydave5/data 
```

也许如果我想以 JSON 的形式获取数据，我可以请求:

```
http://gypsydave5/data.json 
```

但是如果我想要 XML，我可以做:

```
http://gypsydave5/data.xml 
```

好处是，如果我习惯于使用文件系统，这很容易理解——我可以通过扩展名来识别文件的类型，所以我现在可以对 URL 做同样的事情。

有什么坏处？可能最烦人的事情是，即使你提供了如上的扩展，你仍然*必须提供一个`Content-Type`头。这是因为，在网络上，关于内容的信息不应该被编码在 URL 中；它应该在`Content-Type`头中。*

一些流行的框架就是这么做的， <sup id="fnref4">[4](#fn4)</sup> 但这是个坏主意。不要这样做。

最大的问题是您将错过执行*内容协商*的机会。

## [](#content-negotiation)内容协商

假设你要去一家三明治店，你的朋友让你去买一个三明治。当然，你说，你想要什么？我不知道，他们说，他们有什么？嗯...你说，我真的不知道-这是菜单，但他们经常在一天的这个时候用完一些馅料。

好吧，你的朋友说，这是我想要的:

> “我想要金枪鱼蛋黄酱或《纽约客》——哪个都行。如果他们没有那些，那么我要一份鸡蛋沙拉。如果他们没有鸡蛋沙拉，那么请给我任何东西——我饿死了。”

听起来还不错。当你去三明治店的时候，你可以用你朋友的三明治需求给他们买一个他们会喜欢的三明治。

同样的事情每天都在网上发生，客户向服务器发送媒体类型列表，试图确保他们能得到他们喜欢的东西。看看这个从网络浏览器发送的 HTTP 请求的`Accept`头:<sup id="fnref5">[5](#fn5)</sup>T5】

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
```

浏览器需要上述媒体类型之一。但是它有一些关于它更喜欢哪个的意见，它用`q`参数来表达。 <sup id="fnref6">[6](#fn6)</sup> `q`参数的值在`1`和`0`之间，一个`q`参数(未提供时)的默认值为`1`。

下面是上面列出的媒体类型及其`q`值。

| 媒体类型 | 蜕变能 |
| --- | --- |
| `text/html` | One |
| `application/xhtml+xml` | One |
| `application/xml` | Zero point nine |
| `*/*` | Zero point eight |

根据偏好排列的一系列选择。如果你或我要去服务器获取浏览器的一些内容，浏览器会告诉我们这样的信息:

> “我很想要`text/html`和`application/xhtml+xml`。但是，如果他们没有这些，我会去一些甜的`application/xml`。如果他们没有，无论如何，只要给我任何东西。”

这确实是你希望浏览器做的——你总是希望得到一些东西。

```
Accept: audio/* 
```

就像我们被送到了唱片店:

> “你能给我新的涅槃专辑吗？我不在乎它是在黑胶唱片上、磁带上还是 CD 上。见鬼，8 轨也行。只要确保我能听到它，好吗——我不只是想要海报。”

这是*内容协商*——我们对服务器的请求给了它关于我们得到的内容类型的偏好。它可以遍历这些优先级，查看它可以返回什么内容类型，并给出最匹配的类型。

### [](#content-negotiation-and-testing)内容协商和测试

在构建 HTML 页面的数据上编写测试比 HTML 本身更容易。如果您构建的应用程序允许客户端选择通过每个 URL 返回的内容类型，您可以通过请求 JSON 表示而不是 HTML 表示来测试“页面”的内容。容易多了！

## [](#roll-your-own-media-type)滚动自己的媒体类型

是的，你也可以发明自己的媒体类型，这并不像你想象的那样罕见或怪异。事实上，在编写 web APIs 时，这是一种强大的技术。媒体类型规范为未注册的子类型留有空间(并且永远不应该注册)。他们以`x-`:<sup id="fnref8">[8](#fn8)</sup>T5】开头

```
application/x-myapplication-orderstatus+json 
```

这可能是我的应用程序中订单状态的媒体类型。`+json`让每个人都知道它是用 JSON 编写的，但是我们已经严格地指定了内容是`myapplication`的一部分——它不仅仅是任何一个旧的 JSON。

如果您不选择利用它来传递关于媒体类型的附加信息，这只是一种虚荣心。例如，如果要改变`application/x-myapplication-orderstatus+json`媒体类型的结构，可以增加一个版本参数:<sup id="fnref9">[9](#fn9)</sup>T5】

```
application/x-myapplication-orderstatus+json;v=1.1 
```

这在描述通过不断发展的 REST API 发送和接收的内容类型时非常有用。<sup id="fnref10">[10](#fn10)T3】</sup>

最后，你可以[向 IANA](https://www.iana.org/form/media-types) 注册你的媒体类型，让世界知道如何与你的应用程序交互。

## [](#summary)总结

我们了解到:

*   媒体类型的语法及其含义。
*   如何在`Content-Type`头中使用媒体类型来声明我们发送的内容。
*   如何在`Accept`头中使用它们来控制我们得到的内容类型。
*   如何使用它们与服务器进行内容协商。

媒体类型很重要——它们有助于在网络上顺畅地传递数据。使用它们——并且很好地使用它们——将有助于您的 web 应用程序更容易被其他人使用和理解。

## [](#q-and-a)问答

> 问:“等等，我没有在我发送的 HTML 上放一个`Content-Type`标题，但是我的浏览器仍然知道它是 HTML——这是怎么回事？”

答:有多种方法可以计算出数据的媒体类型；去仔细阅读[内容嗅探](https://en.wikipedia.org/wiki/Content_sniffing)。

> 问:等等，你是说哑剧类型吗？

不，我没有。MIME 的意思是*多用途互联网邮件扩展*，它是第一个使用媒体类型的地方。但由于它们不仅仅用于“互联网邮件”(给你和我的电子邮件)，正确的名称是“媒体类型”。人们仍然倾向于交替使用哑剧、媒体和内容类型，但现在你知道了正确的答案，你可以在聚会上看起来沾沾自喜，并要求加薪。

* * *

1.  这是 html 4——你不需要在 HTML5 中包含类型。但那会毁了这个完美的例子。 [↩](#fnref1)

2.  除了`q`，这个*是*指定的。 [↩](#fnref2)

3.  事实上，如果服务器不能提供所要求的媒体类型，它应该发回一个 406:不可接受的代码...但这种情况很少发生。 [↩](#fnref3)

4.  [rails 中的活动资源](https://github.com/rails/activeresource) [↩](#fnref4)

5.  在这个例子中是 Firefox。 [↩](#fnref5)

6.  `q`代表质量。我不是在开玩笑。 [↩](#fnref6)

7.  我非常喜欢流行文化。 [↩](#fnref7)

8.  或者`x.`。事实上，`x.`更受 IANA 青睐，但`x-`使用更广泛。 [↩](#fnref8)

9.  您也可以尝试`application/x-myapplication-orderstatus_1.0+json`——这取决于您希望如何解析版本信息以及您的版本化策略是什么(版本的兼容性如何)。 [↩](#fnref9)

10.  Julius Schnorr von Carolsfeld 今天的封面图片可以很容易地拥有标题和自定义媒体类型`Content-Type: text/x-commandments` [↩](#fnref10)