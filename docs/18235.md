# python 中的内存管理——第 1 部分

> 原文:[https://dev.to/pradhvan/memory-managment-in-python-第一部分-1c98](https://dev.to/pradhvan/memory-managment-in-python--part-1-1c98)

偶然发现来自 GitHub [repo](https://github.com/satwikkansal/wtfpython#-strings-can-be-tricky-sometimes-) 的 Python 代码片段，我确实意识到在 Python 中变量实际上并不存储它们被赋值的值，变量实际上存储了值的位置。不像 C++/C 实际上创建一个固定大小的空间，并将其分配给一个变量，我们通常称之为桶/房间，同时向初学者解释变量“什么是变量？”在编程方面。

虽然 python 变量有点不同，但它们的工作方式就像指向酒店中某个特定房间(内存空间)的键，所以每当我们对 available 进行赋值时，我们不是在创建房间，而是创建该房间的键，该键会被 python 的垃圾收集器自动释放/覆盖。(后面会详细介绍垃圾收集器的话题)。所以关键是每当我们做类似
的事情时

```
>>>a = 10

>>>b = 10

>>>id(a)

94268504788576

>>>id(b)

94268504788576 
```

我们在这里进行优化，创建两个相同的键，它们指向酒店(内存)中的同一个房间，因此它们将具有相同的 id，但这种优化仅适用于从-5 到 256 的整数范围。如果超出该范围，变量将指向两个不同的存储，因此将具有不同的 id()。

只是不要混淆为什么我们不使用“==”而使用 id()，==检查变量指向的值在对象中是否相同，id()检查它是否使用相同的对象，因为每个对象都有一个唯一的标识，可以通过 id()函数检查。

回到下面给出的 GitHub repo 的代码片段，将相同的整数知识应用于字符串。

```
 >>>a = "wtf"

>>>b = "wtf"

>>>id(a),id(b)

(139942771029080, 139942771029080)

>>>a = "wtf!"

>>>b = "wtf!"

>>>id(a),id(b)

(139942771029192, 139942771029136)

>>>a = "hello world this is a string"

>>>a = "hello world this is a string"

>>>id(a),id(b)

(139942770977328, 139942770977408) 
```

同样的优化也发生在这里，当字符串很小时，它们引用内存中的同一个对象，而不是创建一个新的对象，这样就节省了内存，这种优化叫做实习。但是当对象变大或包含 ASCII 字母、数字或下划线时，它们不会被保留。

这显示了抽象的最佳状态，python 在这方面非常擅长，它为您完成了分配/释放内存的所有繁重工作，并让您专注于程序的其他部分。直到你真的想知道发生了什么，我想你知道，这就是为什么你在读这个博客😛

尽管回购协议上已经有了这样的解释。我想更多地了解内存管理在内部是如何发生的，所以我无意中听到了由 [nnja](https://www.nnja.io/) 所作的“[Python 中的内存管理——基础知识](https://www.youtube.com/watch?v=URNdRl97q_0)”的演讲。所以是的，像忍者一样有刻痕的人很擅长玩 Python 和堡垒之夜，哈哈哈！(我忍不住发了这个笑话，只是想澄清一下，忍者是堡垒之夜顶级玩家之一)

因此，从技术上讲，Python 没有变量，只有引用其他对象或名称的“名称”, Python 喜欢保存所有引用的计数，作为所有对象引用的引用计数。因此，如果对象的引用计数减少到零，这意味着没有对该对象进行引用，python 的垃圾收集器将该对象视为空闲空间，因此该对象被删除，空间可以自由使用。

作为程序员，我们可以增加或减少对象的引用计数，因为 python 对象存储三样东西:

```
* Type: int,string,float
* Reference Count
* Value 
```

看到博客的第一个代码片段，其中两个名字 a 和 b 都指向同一个对象，值为 10，引用计数为 1，类型为 int。

这就是这一部分的全部内容，将在下一部分详细介绍相同的主题。仍然对一些事情感到困惑，所以保持这种简单明了，以便将来当我迷失甚至不能注意到简单的事情时，我可以回头看😛对于只想简单了解一下的人来说。