# 如何不在你的项目中引入 ReasonReact

> 原文：<https://dev.to/hoichi/how-not-to-introduce-reasonreact-to-your-project-311o>

嗯，实际上，现实并不像 clickbaitey 的标题让你想象的那样残酷。我对 React 和 react 的介绍，以及对这个站点静态构建的 ReasonML 的介绍，并没有产生什么特别的错误。声称您可以一次一个组件地将 React 引入到现有的应用程序中是完全正确的。

此外，ReasonML 相当不错，而且 BuckleScript 是我所知道的最好、最快、优化程度最高的 JS 编译器。

只是我的特定实现有点低效，可能不是一个好的管理决策。如果我能回到过去，我会以不同的方式去做——或者在可预见的未来根本不会去做。

先不说免责声明，让我从头说起。

## TypeScript 怎么了

我关注像 ReasonML 这样的语言的原因是，TypeScript 对我来说似乎有点次优(而且有点无聊)。尽管 ESNext 有所进步，但它还是很罗嗦。您可以在其中模拟 sum 类型和穷举案例，但是它们看起来有些怪异。与 ML 语言中的类型相比，它的类型给你的保证更少。不要让我从 JS 中的 FP 模式开始:`pipe(foo, bar, baz)(x)`读起来远不如`x |> foo |> bar |> baz`自然。

可能和保证一样重要，感觉上 TypeScript 类型给了你太多。例如，扩展对象类型。是的，`Object.assign()`完全是 JavaScript 中的一个东西，那些类型在建模。是的，在一个现有的对象上添加更多的属性确实很方便。

还会导致思维懒惰。以我的静态站点构建脚本为例。他们有:

*   我从文件系统中读取的页面(帖子),带有路径信息和原始内容数据
*   同样，YAML frontmatter 提取和 markdown 解析为 HTML
*   同样，放入博客提要、标签提要和 RSS 的列表中
*   单个页面和提要页面，包装在适当的页面/文章布局中

以上所有类型的设计都很不完善，因为每次我都想:不，我只是用一些额外的道具复制旧的对象，并可能覆盖`content`属性，不管它现在是 HTML 而不是 Markdown。是的，我知道有了适当的纪律，你可以坐下来仔细考虑这些规范，但纪律是会耗尽的，所以你倾向于即兴发挥，然后浪费时间设置断点和记录东西。

所以我希望 OCaml 的限制性记录能推动我使用类型进行设计。

也有一些好事，比如用 Reason standard 库以更简洁的方式处理更多的数据，或者用 ReasonReact 把我的博客变成半 SPA。网页加载速度并不是我在 Netlify 托管的静态网站上遇到的问题。

## 那么，为什么我要从模板开始呢

但是突然之间，我决定我需要引入评论。*和*也许是一个新的主题。*和*所有这些都是为了增加获得更好工作的机会。为此，有人认为，缺乏理性的反应是一个阻碍。因为如果我以后要用它，在我当前的 Jade 模板上工作感觉有点浪费。

因此，我没有解决一个有趣的类型设计问题，而是发现自己在做一件更接近于家务的事情。还有，我确定这是必要的吗？我有发展我博客的客户端部分的实际计划吗？都是因为怕找不到好工作？除了黑客和学习之外，我还想在随机的科技领域写博客吗？

就像我说的，糟糕的管理。虚假的紧迫性高于重要性。

## 那么，事情进行得怎么样了？

嗯，还不错。我不得不求助于一个小技巧，因为 BuckleScript 编译器关于输入/输出目录的选项较少。我还必须使用`rss`包，因为 React 关于如何使用`link`标签的想法与它在 RSS 中的使用方式不兼容(当然不是 HTML，但尝试告诉它 React)。但是也许我的 feed 现在更符合标准了，从一开始就把一些随机的 Atom 例子转换成 Jade 是一种更糟糕的黑客行为。

然而，整个结果也是轻度无用的。现在的方案是这样的:我得到了一个`templates.re`文件，它返回一个在 JS-land 中使用的模板函数的字典。因此，它使用 JS 互操作来:

*   构建字典本身
*   包装单个模板，并将 JS param 对象转换为 ML 标记的参数
*   此外，对于获得帖子和标签数组的模板，从这些帖子和标签中获取单独的道具，因为我已经懒得将这些对象转换成适当的 ML 记录

所以，我的大部分工作都放在了 interop 中，当(或者如果)我把所有东西都转换成 Reason/OCaml 时，我将不得不扔掉它。请注意，BuckleScript JS interop 非常棒，ReasonML sugar 也很棒，但这个过程有点乏味，感觉不像是在做什么重要的事情，尤其是因为它都是临时凑合的。

相反，并没有很多 ML 到 ML 的 API:包装器将 ML 参数传递给模板，模板将它们传递给 ReasonReact 组件。没有那么多类型来帮助我了解我的状态管理，或者在我做错事情时对我大喊大叫。

## 汇总？

总而言之，我确实在 TypeScript 模块中添加了一些小的 ReasonReact 组件，它们工作正常。就学习项目而言，进展顺利。我所学的不是特别基础，但是如果没有一些非基础的知识，你就不能做很多实际的东西。我猜这是基于项目的学习的祸根。

不过，下一次，我会再三考虑这样做是否值得，以及新技术在哪里会产生最大的影响。将 Reason 或 OCaml 用于构建逻辑本身会花费更长的时间，但可能会带来更大的清晰度。转换所有的东西会花费更长的时间，但是会让我从编写互操作代码中解脱出来——或者说，我必须为其他一些模块编写代码，比如 [@most/core](https://mostcore.readthedocs.io/en/latest/) 。前提是我成功地一次性调试了整个系统。

尤其是因为我对测试几乎没有经验。也许我应该在 2019 年写更多这些。

* * *

首先发布在 [hoichi.io](https://hoichi.io) 上，但欢迎你在任何地方阅读。