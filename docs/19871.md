# 您需要的 Git 工作流:如何在单个存储库中处理多个团队

> 原文:[https://dev . to/bnevilleoneill/the-git-workflow-you-need-how-to-deal-multi-teams-in-a-single-repository-527 b](https://dev.to/bnevilleoneill/the-git-workflow-you-need-how-to-deal-with-multiple-teams-in-a-single-repository-527b)

[![](../Images/1b67d0b5b0bb0d1ccee6d007c1dd105d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--u_wZXLG_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2Ag7EqWAX7BHL43bLID049Lw.jpeg)

如果你以前经历过，请打断我:你要么是一个大型开发团队的一部分，要么目前正在管理一个大型开发团队，他们并不都使用相同的技术堆栈工作，因为你的团队由从事 JAVA 的后端开发人员、从事 AngularJS 的前端开发人员组成，你甚至还有几个从事 Python 工作的数据科学家。

最重要的是，每个人都说他们知道如何使用 GIT，但实际上，他们并不知道。他们通常使用他们选择的 IDE 来处理版本控制，点击选项而不知道他们到底在做什么。

通常，理性会指示这些团队分别处理他们的源代码，这意味着为每个代码库使用不同的存储库。这也将使他们能够拥有彼此独立的个人发展流。

也就是说，运气经常不在你这边，你只剩下一个存储库和三个不同的团队，试图学习如何一起工作。在这篇特别的文章中，我将处理这个场景，但是仅仅从源代码控制的角度。换句话说，如何创建一个有用的开发流程，允许每个人一起工作，而不会弄乱彼此的代码。

[![](../Images/2063f22e152ef36aa267c13ae9842601.png)T2】](https://logrocket.com/signup/)

### 为什么不简单地采用一个成功的 Git 分支模型？

2010 年，Vincent Driessen 发表了一篇[非常有趣的文章](https://nvie.com/posts/a-successful-git-branching-model/)，描述了一种在开发团队中使用 GIT 处理版本控制的方法。

从本质上来说，那篇文章提出的(如果你想知道所有的细节，可以直接去读这篇文章，不需要花言巧语)是:

*   为您需要处理的每个特性创建一个分支。这些分支将来自基础**开发**分支，所有开发代码都驻留在那里
*   每个开发人员将致力于他们各自的特性分支，直到他们被认为准备好了
*   一旦准备好，它们将被合并回它们的源
*   当所有的特性都准备好时，您将从开发中创建一个**发布**分支，在那里只接受错误修复以确保没有半成品特性被部署

简而言之，这就是流程，当涉及到标记和修补程序时，还有一些其他的考虑事项，但是我会让您阅读原始文章。

因此，就像许多其他人一样，我将这种方法铭记于心，并且当同质团队在相同的代码上作为一个整体工作时，这种方法工作得非常好(以我的拙见)。

问题来了，当那不再是现实。

不要误解我的意思，如果您的团队精通该工具，该模型仍然有效。如果他们知道从存储库中*拉*对*取*意味着什么，或者知道如何正确处理合并冲突，那么无论如何，都要使用这个模型。

遗憾的是，情况并非总是如此，太多的开发人员在需要使用 GIT 时，往往会忽略它的文档。当团队足够小时，这会导致一些小问题，或者会迫使他们选举队友来承担所有合并的责任。

也许你也去过那里，你的团队中有一些非常了解这个工具的开发人员，他们知道当他们使用它时会发生什么，所以他们往往是处理最复杂任务的人。

例如，您可能让这些开发人员在 sprint 开始时创建特性分支，然后，一旦其他人认为代码准备好了，就负责合并。

在某些情况下，这可能是一种可行的设置，但毫无疑问，它会给那些特定的个人增加很多责任，并且肯定会占用他们的发展时间。

那么，如果我们不尝试调整我们的 git 流，最坏会发生什么呢？

### [](#common-problems-we-need-to-avoid)我们需要避免的常见问题

让我分享几个我经历过的让我想出这个方法的例子。

### [](#chaining-branches)连锁分支

流程规定每个新的分支需要来自主**开发**分支，这是为了避免从其他半成品分支带来不完整的代码。这里的问题是开发人员在创建他们的分支和使用另一个分支时没有注意，可能会错误地使用一个旧的分支作为源。

现在他们试图将他们的完整代码合并到开发中，可以理解，他们有很多合并冲突。如果开发人员只是接受他们的代码版本来解决问题，情况会变得更糟，因为在他们看来，他们的工作是最新的。

一旦这些都完成了，他们上传了他们的代码，是的，但是在这个过程中，他们也用旧的、未完成的版本覆盖了另一个团队的最新版本的代码。

让我们用一个非常简单的图表来看一下:

[![](../Images/a49e7f478bcc1a16d6313730962832dd.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--vS4hmZQn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/623/1%2AolclSesYiEh1Ew80hlBoRQ.png)

最后，从分支 F2 合并的代码有来自 F1 的未完成的代码。因为所有团队共享同一个存储库，F1 可能是前端特定的分支，F2 可能是后端团队。你能想象后端的人搞乱前端的代码会带来什么样的混乱吗？我可以告诉你，这不太好。

### [](#premature-merges)过早合并

与前面的问题类似，如果您将未完成的功能分支合并到开发中，只是为了看看它是如何工作的，或者(甚至更糟)为了确保那里没有冲突，您实际上是在用未完成的代码毒害主分支。

下一个从基础分支创建一个全新分支的开发人员(就像他们应该做的那样)将会带着你的代码。当他们决定合并时，假设你已经完成了你的代码并在他们之前合并，他们将不得不为你的代码解决合并冲突，而不是他们的！ **#WTF**

请看下一个流程图，它展示了这个具体的案例:

[![](../Images/51271e5da9b84492d4e30e56e23d711b.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--SH0DYOMz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/633/1%2AdBhtQJ9jUYf-WFPe6_PZjQ.png)

最后，结果还是和以前一样，你影响了别人的工作，却没有意识到。事实上，这些问题在进入生产之前是看不到的，所以您需要格外小心处理代码的方式。

还有其他方法来破坏你的同事的代码，但是它们与这两个例子有一定的联系，正如你现在可能已经猜到的，实际的挑战不是流程本身，而是团队。

解决这个问题的最终方法是培训相关的开发人员，这样他们就不会犯同样的错误，但是如果你不能，或者他们不会学习(毕竟，*人非圣贤，孰能无过)*你可以选择的另一个方法是调整你的流程，使你的损失最小化。

### [](#a-new-flow)新的流量

我试图用这个流程来达到的目的，是缩小一个错误的影响范围。通过将代码划分成非常独立的分支，如果有人忘记了什么，或者只是不想按规则来玩，他们只会影响他们的直接队友，而不会影响团队的其他成员。

问题是无法避免的，这里的关键是不要让它们蔓延到其他团队，因为这样的话，修复它们就成了整个项目的任务，而如果只是前端或后端的问题，那个团队就可以自己解决了。

现在让我们看看这个流程如何寻找两个团队的组合(您可以很容易地推断出您的项目中的任意数量的子团队):

[![](../Images/c070cd8f46ab819945cc75cc196a7347.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--5OnoSkQK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/883/1%2AitpxDlI13ocyw5n1dRkAWQ.png)

我知道有很多台词，但是请耐心听我说。

这个流程试图展示两个团队(T1 和 T2)如何在 sprint 的时间内，以两种不同的方式(F1 和 F2)工作。

一切都很清楚，以下是细节:

*   虚线箭头是自动发生的合并
*   T1Dev 和 T2Dev 分别是每个团队的开发分支。它们内部的代码不应该混合，这是关键，这就像混合前端代码和数据科学代码(你就是不这样做)
*   T1Stable 和 T2Stable 是相应的 T1Dev 和 T2Dev 的副本，但它们只包含稳定的代码。这是有保证的，因为只有当这些分支的特性被关闭时，合并才会发生(意味着 QA 团队已经批准了它们)。
*   在每个 sprint 的开始，从他们相应的稳定分支为每个团队创建一个标签
*   从当前 sprint 的标签中创建新的特性分支
*   无论合并到基础开发分支中的是什么，都由开发人员进行测试，如果工作正常，就会发出一个合并命令，因此代码被合并到 QA 分支中(随后部署到该环境中，供该团队进行测试)
*   在 sprint 结束时，稳定的代码被部署到生产中(通过将其合并到 PROD 分支中)

我知道这听起来很多，可能看起来难以处理，但它有助于防止许多灾难。

让我解释一下。

标签确保你在 sprint 中创建的所有分支都包含相同的源代码，这是非常重要的，因为如果你不这样做，你可能会在 sprint 开始一周后创建一个新的分支，其中包含任何部分测试的内容，而你的任何其他队友可能已经合并到你的团队的开发分支中了。这基本上防止了你在合并自己的代码时，不情愿地从别人那里推广未完成的代码。

稳定的分支在将代码提升到产品的过程中帮助你(或者可能在那之前的一步，UAT)。你看，在一个理想的世界里，你只需要将你的 QA 分支提升到下一个环境中。但在现实中，总是会有遗留问题，要么是由于未完成的功能，要么是有缺陷的功能。无论是哪种情况，这些代码都不足以脱离 QA 并投入生产，所以当设置下一个部署时，您需要手工挑选您的分支，只有那些得到批准的分支。这样，您已经为每个已经预先批准的团队创建了一个分支，所以您所要做的就是将这些分支合并到生产中，您就准备好了。

单独的开发分支(上面例子中的 T1Dev 和 T2Dev)有助于隔离代码。您看，将代码合并到这些分支中需要由开发人员自己来完成，正如我们在本文开始时所讨论的，您不能总是相信他们有能力正确地这样做。

通过拥有单独的开发分支，您可以确保如果他们犯了任何错误，他们只会影响他们的团队，而不是整个项目。

根据要素的大小，您可能需要从要素分支创建几个单独的分支。你可以按照你认为合适的方式构建你的本地开发工作流，只要记住一件事:你做的任何事情都需要来自并进入特性分支，就是这样。

### [](#a-few-more-recommendations-outside-of-the-flow)流量之外的几更推荐

虽然流程本身将有助于限制你的团队或队友可能犯下的任何无意错误的影响范围，但还有其他建议与之齐头并进，可以更好地防止这些错误。

### [](#document-the-flow)单据流转

需要记录开发流程，尤其是复杂的流程。每个人都需要能够准确理解什么时候需要发生什么，更重要的是如何去做。

换句话说，不要害怕编写万无一失的文档，牵着开发人员的手。这听起来可能很多，但是你将会写一次，并且你将会经常使用它，特别是在你的项目开始的时候，以及之后每一个新的开发者加入的时候。

一步一步的描述有助于他们避免猜测如何执行拉取或合并，并给他们一个处理这些任务的标准化方法，这样如果有任何疑问，任何人都可以回答。

### [](#discuss-the-flow)讨论流程

另一种形式的记录是可能的情况下面对面的问答，或者至少是在聚会或任何其他类型的成员现场聚会上，每个人都可以表达他们的疑问。

有时这些疑虑会凸显出你计划中的缺陷，所以，从另一方面来说，要对改变持开放态度。

就像他们需要接受你的领导一样(如果你是流程的创造者)，你也需要接受你可能的疏忽，甚至是你错过的改进。要意识到这些事情可能会发生，在将计划发布给每个人之前，尝试与团队中更精通 GIT 的成员一起审查计划。如果他们能接受，很有可能其他人也会接受。

### [](#dont-be-afraid-to-enforce-some-standards)不要害怕执行一些标准

还是那句话，有时候问题来自行动自由。如果使用 GIT 的开发人员并不真正理解它是如何工作的，而是试图通过使用外部工具来弥补这一点，那么他们可能会比没有这些工具时带来更多的麻烦。

因此，为了避免这种情况，请随意实施他们需要使用的 GIT 客户端，或者他们需要工作的环境，或者文件夹结构，或者任何您认为可以简化他们处理源代码控制的任务的东西(我[写了一篇文章](https://dev.to/bnevilleoneill/the-importance-of-standards-in-development-teams-2adc-temp-slug-2263273)，介绍了您将从实施中受益的标准类型，如果您有兴趣了解这个主题的更多信息的话)。

我的一个目标是强制使用 GIT 自带的 CLI 客户机，然后在逐步文档中列出他们需要输入的每个命令。这样，这个任务对每个人来说都是不需要动脑筋的(这是理想的场景，让您的开发人员担心代码行，而不是 GIT 行)。

### [](#final-words)最后的话

本文到此为止，感谢您阅读至此，请记住:

*   并不是每个人都对 GIT 有足够的了解，可以单独使用它
*   不是每个人都会承认这一点
*   标准的 git 流并不总是您团队的正确选择
*   你的目标应该是当问题发生时(它们会发生)，有一个最小化附带损害的流程
*   您还应该致力于培训您的团队使用 GIT，起初可能看起来不像，但是这是一项投资，它将使您避免由于不正确的合并而错过交付日期
*   最后，尽可能多地提供关于这个过程的文档，并且开放地接受它是一个不断发展和变化的动态文档

再次感谢您的阅读，如果您愿意，请留下类似故事的评论，告诉我们您过去遇到过什么样的问题，是由于 GIT 的错误使用，还是您用来避免它们的不同流程！

直到下一个！

### [](#plug-logrocket-a-dvr-for-web-apps)Plug: [LogRocket](https://logrocket.com/signup/) ，一款适用于网络应用的 DVR

[![](../Images/d56be9e9e36d8fa98c6959f7097b7787.png)](https://logrocket.com/signup/)

<figcaption>[https://logrocket.com/signup/](https://logrocket.com/signup/)</figcaption>

LogRocket 是一个前端日志工具，可以让你回放问题，就像它们发生在你自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。

除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面应用程序重新创建像素级完美视频。

免费试用。

* * *