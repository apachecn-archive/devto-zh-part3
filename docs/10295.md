# 圆周率中的数字串

> 原文:[https://dev.to/engelke/runs-of-digits-in-pi-4bh2](https://dev.to/engelke/runs-of-digits-in-pi-4bh2)

我的同事，[艾玛·相户爱·伊沃，](https://twitter.com/Yuryu)，[刚刚公布了圆周率的小数值](https://cloud.google.com/blog/products/compute/calculating-31-4-trillion-digits-of-archimedes-constant-on-google-cloud)到 31，415，926，535，897 位。出于各种原因，这是一个惊人的成就，尤其是如何在几个月内成功地在许多机器上运行计算。谷歌计算引擎的[实时迁移](https://cloud.google.com/compute/docs/instances/live-migration)功能是保持其不间断运行的关键。

但是现在，一个不那么惊人的成就怎么样？我写了一个程序来扫描这些数字，寻找相同数字的游程。我从艾玛的结果中得到数字。她建立了一个网络服务，任何人都可以使用这个服务按需获取一堆数字。下面是几个结果后的技术细节。

在圆周率的十进制数值中，你要走多远才能找到两个相同的连续数字？结果只有几十个地方。“33”出现在位置 25 和 26(将圆周率中的第一个“3”计为位置 0，小数点计为位置 1，依此类推)。想在一行中找到三个相同的数字吗？从 34 号位置开始有一串 111。

有趣的是(至少对我来说)，超过三位数的第一次运行在一行中有六个相同的数字:“999999”，从位置 763 开始。想跑七圈吗？你必须到位置 710，101 去找‘3333333’。跑八圈怎么样？我没有答案。我停止了我的程序，在扫描了大约 10，000，000 个位置之后，没有找到那么长的运行时间。

我编写了一个简单的 Python 程序，一次向 web 服务请求 1000 位数字(它最多能为每个请求提供 1000 位数字)，并扫描长串的数字。我说这很简单，但我至少做了十几次调整才让它正常工作。尽管如此，它唯一的特殊之处在于它是如何获取数据的:它向`https://api.pi.delivery/v1/pi?start=0&numberOfDigits=1000`发出 HTTP GET 请求(0 和 1000 被替换为实际的起点和您想要的位数)。响应是一个 JSON 对象，其中有一个名为`content`的字段。该字段的值是包含数字的字符串。

这是一个不错的小编程练习。你自己试试，看看在你让它工作之前，你能不能犯和我一样多的错误。