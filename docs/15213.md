# 比较多种编程语言中的值和引用

> [https://dev . to/campus MVP/比较-多种程序语言中的 y 值和参考 cin-1n7n](https://dev.to/campusmvp/comparando-valores-y-referencias-en-varios-lenguajes-de-programacin-1n7n)

> 写于[校园 MVP](https://www.campusmvp.es/recursos/post/Comparando-valores-y-referencias-en-varios-lenguajes-de-programacion.aspx) 中的【eduard tommas】

在这篇文章中，我们将看到不同的语言是如何解决比较价值观和参考的问题的。或者，这同样适用于确定两个变量是包含同一对象还是包含两个不同但相同的对象。参照比较通常称为“按参照比较”，如果两个对象相等(但不一定相同)，则比较称为“按值比较”。

同样地，如果我们只在乎一个人的价值，而不在乎他的身份，我们就说他有价值语义。完全应用价值语义可确保对象的不变性:对对象的任何修改都会生成该对象的“”副本，就像赋值运算符一样。

这是一个看似简单的问题，但与这个充满激情的发展世界中的几乎所有事情一样，它所涉及的不仅仅是表面上的问题。我们从 Java 开始-我...。

## Java

Java 是最简化这个问题的语言。相等运算子(==会比较参照。即给定以下代码:

```
MyClass m1 = new MyClass();
MyClass m2 = new MyClass();
boolean eq = m1 == m2; 
```

eq 变量的值为 *false* ，因为 m1 和 m2 包含两个不同的对象。不管这些是相同的，重要的是它们是两个不同的物体。事实上，Java 中最常见的错误之一是使用比较运算符比较字符串:

```
boolean areEqual = "Hola" == "Hola"; 
```

在 Java 中，字符串是一个对象，每次使用文字时都会创建一个新对象，因此 areEqual 将值为 *false* :我们有两个相等的字符串，但它们仍然是两个对象。好吧，在你跑去 Eclipse 复制这个代码之前，看到 areEqual 是 *true* (而不是 *false* ，我会告诉你，这是因为在某些情况下 Java 编译器可以做出优化，看到两个字符串实际上是一样的，所以才真正创建一个但这是编译器的优化，而不是语言的优化。在编译器无法检测到这种情况的其他情况下(例如读取文件中的该字符串)，areEqual 将值为 *false* 。

Java 引入了按值比较的机制:在 Object 类(Java 中所有类的基类)中定义的 equals 方法。必须在必须提供按值比较语义的所有类中重新定义此方法。所以 Java 中比较字符串的正确机制是:

```
boolean areEqual = oneString.equals(anotherString); 
```

栋德一个字符串 y 另一个字符串子变量 de tipo 字符串。

在 Java 中，简单类型(int、boolean、double、-我...。)不是类，在这种情况下，使用比较运算符时总是按值进行比较。Java 中的简单类型具有值语义。

## C#

在 C#中事情变得更有趣了。C# Java 相同概念的一部分:比较运算符(= = =)按引用进行比较，而对于按值进行比较，则存在在 Object 类(c#中所有类的超类)中定义的 Equals 方法。与 Java 的区别主要有三点。

第一个 C#(通常为. NET)允许使用值语义定义类型。在 C#中，struct 用于定义语义为“按值”的类型。只是一个细节:C#中的结构并不是一成不变的(虽然我个人的建议是，如果你创造它们，*使它们不变*。在 C#中创建 struct 时，必须提供==运算符的实现。如果你不这样做，你就可以用这个运算符来比较它们！

P.例如，我们可以使用以下代码定义结构:

```
struct Foo
{
    public int Bar { get; set; }
    public static bool operator !=(Foo one, Foo other)
    {
        return !(one == other);
    }
    public static bool operator ==(Foo one, Foo other)
    {
        return one.Bar == other.Bar;
    }
} 
```

> 注意:如果重新定义相等运算子，C#也会强制我们重新定义非相等运算子(！=。

segundo c#可让您重设比较运算子(=)。这意味着，即使我们有一个类，我们也可以通过重新定义==来实现价值比较语义。重置(=运算符)只应在创建其对象不可变的类时执行此操作。

最后，在 C#中，“简单类型”实际上并不存在:它们都是物体。C#中的所有“简单类型”(int、bool、float)都是. NET Framework 类型的别名(例如，int 是 Int32 的别名)。这些类型是使用值语义(即 structs)实现的。

所以，在 C#中，机会成倍增加。通常，使用==比较类时会按引用进行比较，使用 Equals(如果已重新定义)时会按值进行比较。但我们可以有一个类在使用==时与 valor 进行比较(不进一步的话 String 是一个类，而不是一个结构，并且具有运算符==过载)。

例如，当你有以下代码时:

```
var eq = "Hola" == "Hola" 
```

他正在比较两个 String 对象，所以这应该是先验返回 *false* 。但类中包含运算符==过载以按值进行比较，因此 eq 值为 *true* 。另一方面，该守则如下:

```
var eq = 1 == 1; 
```

正在比较 Int32 对象。Int32 是一个结构，因此(=运算符按值比较(∞实现良好！页:1。于是 eq 又值了 *true* 。最后在此代码中:

```
var f1 = new Foo() {Bar=10};
var f2 = new Foo() {Bar=10};
var eq = f1 == f2; 
```

没什么好说的。如果 Foo 是一个类，并且没有运算符(= eq overload)则等于 *false* ，因为它是按引用进行比较的。另一方面，如果 Foo 是我们之前定义的结构，那么它应该返回 *true* ，因为这时运算符==按值比较。

## JavaScript

在 JavaScript 中，事情要简单得多:除了简单类型(布尔型、数字型和字符串型)之外，没有按值比较，总是按引用进行比较。在其他情况下，==运算子会指出两个参照是否指向相同的物件。

因此，以下代码为:

```
var a={};
var b={}
var eq = a==b; 
```

最后 eq 的值为 *false。*

如果我们要按价值进行比较，我们必须手动实施这些比较。事实上，在 C#和 Java 中，我们必须同样执行此操作(我们必须重新定义 Equals 或 Equals)，但至少这两种语言都给我们提供了一个“放置”点，用于按值比较代码(尽管这具有副作用，即任何对象都具有 equals 或 equals 方法，即使未重新定义这些方法，因此按值比较也是不正确的)

但是 JavaScript 引入了一个新的附加比较运算符。三倍等于(==)。该运算符与两倍相同，但有一个基本的区别:它不执行类型约束。类型约束是自动将一种类型的数据转换为另一种类型的数据的功能。尽管很多人相信，类型强制与语言是动态的(如 JavaScript)还是静态的无关。事实上 C#是一种静态语言，强烈的类型化，支持类型约束。JavaScript 中的问题是强制非常广泛，因此有时与==进行的比较会返回看似错误的数据(从开发人员的角度来看，当然)。

所以代码:

```
1 == "1" 
```

返回“*true”*，因为“1”被类型约束转换为数字。是转换为数字的字符串，因为左边的类型是数字(约束始终从右边的类型应用于左边的类型)。另一方面，以下代码:

```
1 + 1 == 1+"1" 
```

返回 *false* 。因为 sum 运算子会将所有引数转换为字串(如果有的话)。因此，1+“1”等于“1+“1”，等于“11”。然后，在比较之前，字符串“11”转换为数字(11)，并与 2(左侧 1+1 的结果)进行比较。

为了避免这些结果，有时“不合逻辑”的是“三重等于”运算符。事实上，除非你有明确的理由不这样做，否则你应该总是在 JavaScript 中使用==。该运算符比较值，但禁用类型约束。如:

```
1==="1" 
```

返回 false，因为类型(一方面是数字，另一方面是字符串)不匹配。

## 雨燕

Swift 在比较主题上有什么可补充的？没什么我们以前没见过的。但是它的语法可能会让那些来自-我...。任何其他语言。

原因是 Swift 与 JavaScript 一样，有两个比较运算符:两个等于(==)和三个等于(==)。但它的使用与 JavaScript 无关。简单地说:

1.  ==运算符按值执行比较(等效于 C#或 Java equals 方法)。
2.  ==运算符按引用执行比较(等效于 Java = =运算符，通常与 c# =运算符相同)。

当我们在 Swift 上创建自己的类时，如果我们希望按价值比较它们的对象，我们必须提供==运算符的实现:这与在 C#中重新定义 Equals 方法类似:

```
@infix func == (left: Vector2D, right: Vector2D) -> Bool {
    return (left.x == right.x) && (left.y == right.y)
}
@infix func != (left: Vector2D, right: Vector2D) -> Bool {
    return !(left == right)
} 
```

但是，与 C#一样，Swift 区分参考类型(类)和价值类型(结构)。将 struct 变数指定给另一个变数时，会复制整个物件，因此最后会有两个不同的物件(与 C#)。在这种情况下，当比较两个 struct 类型的变量时，即使它们包含两个完全相同的对象，运算符===总是返回 false。

与 Swift 一起，我们结束了这一旅程，了解各种语言是如何实现“比较两个变量:”这样简单的先验目标的

> Post 原件:https://www . campus MVP . es/resources/post/compare-values-and-references-in-various language-de-programming . aspx