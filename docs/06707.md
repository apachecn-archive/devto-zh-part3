# 每个操作系统维护的最重要的任务

> 原文:[https://dev . to/yukiinoue/the-most-important-task for-every-OSS-maintainer-11pi](https://dev.to/yukiinoue/the-most-important-task-for-every-oss-maintainer-11pi)

就是每当新的特性或 bugfix 合并到主版本中时就发布这个库。

更确切地说，在现代开发环境中，OSS 通常托管在 Github 上。如果是这样的话，他们很可能会(明确地或隐含地)[采用 Github flow](https://guides.github.com/introduction/flow/) 的开发流程。在这种开发风格中，对主分支的每个提交都是一个发布候选。既然它是一个发布候选，如果语言库生态系统所采用的版本系统支持[语义版本](https://semver.org/#spec-item-10)，它总是可以作为`pre-release`版本发布。

当图书馆维护者不断发布合并到`master`中的内容时，图书馆用户需要做的是根据他们的需求系统地管理图书馆。由于语义版本化定义了每个发布版本的线性排序，人们可以期望每种语言的库管理工具(例如`npm`、`gem`)很好地完成这些管理。另一方面，当一些功能/错误修复被合并到开发中但尚未发布时，库用户通常需要处理“源位置以获取特定的库”(例如，git url 以及 branch/tag/ref)。由于所有其他库都通过一些约束来指定它们对已发布版本的依赖性，这意味着库用户现在将管理那个库的`versioning`和`source location`。我相信这是任何图书馆用户都不想要的。

我知道维护开放源码软件，还有许多其他任务。但是，如果制定了释放策略，释放操作可以很容易地完成。例如，根据提交的内容，将每个新的主提交发布为新的主要/次要/补丁发布；重大变更时发布主要版本，新特性时发布次要版本，修复 bug 时发布补丁，如果不确定提交不会破坏任何东西，则作为预发布发布。如果制定了这样的策略，那么通过自动化部署过程，维护人员需要做的事情就可以变成一个简单的命令。通过这样做，它可以为该图书馆的所有用户带来好处...所以，我真诚地希望每一个 OSS 维护者定期发布他们精彩的库。