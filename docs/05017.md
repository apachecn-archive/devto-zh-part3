# 广义斐波那契存储器分配器

> 原文：<https://dev.to/naens/generalized-fibonacci-memory-allocator-2fja>

内存分配器[https://github.com/naens/mem_alloc](https://github.com/naens/mem_alloc)的工作描述

# 目录

1.  [简介](#org6644e5f)
2.  [内存分配](#org460254b)
3.  [广义斐波那契分配](#orge4a9451)
4.  [实施原则](#org90f2cf9)
    1.  [块](#orga4cf155)
    2.  [自由列表数组](#org84186c8)
    3.  [好友](#org12be711)
    4.  [动态数组](#orgf6b61d3)
5.  [实施细节](#org9cbdf3c)
    1.  [数据结构](#orgace6bdd)
    2.  [来自操作系统的分配](#org99bde96)
    3.  [数组中的第一项](#orgc17ec59)
    4.  [好友系统](#org4ad8258)
    5.  [分配和释放](#orgf16c4f2)
    6.  [数组初始化](#orgeab01ef)
6.  [便携性和测试](#orgd476250)
    1.  [测试的操作系统](#org9dd4744)
    2.  [Makefiles](#org8ac1b69)
7.  [总结和再见](#orgc63942a)

\分页

# 简介

你好。在这篇文章中，我将描述一个我写的内存分配器。内存分配器的主要目的是了解它如何工作，并且有一种方法为我用汇编语言为 CCP/M-86 编写的
汇编程序分配和释放内存。
的目标是用汇编语言编写它，但是为了确保我能
拥有可以工作的东西，我决定用 C 语言在
中做一个测试版本，以确保我理解它是如何工作的。

# 内存分配

现在我将描述为什么我需要一个内存分配器。需要
能够获得内存的某个部分，以便存储动态数据
结构，例如字符串。如果用户有可能
输入一个字符串，我们不能预先知道它的大小，所以我们得到一个
大缓冲区。但是一旦我们知道了，最好只储存
需要的东西。因此，例如，如果我们有许多不同
长度的字符串，根据字符串的
长度分配内存会更好。

当然，还有许多其他例子说明为什么需要内存分配器。许多数据结构，像树和列表，通常是通过使用动态内存分配来实现的。

其他用途是能够存储临时的中间数据。对于
示例，我们读取一个文件并从中生成一个字符串列表。然后
我们可以过滤或连接它们，最后将结果插入
哈希表或写入文件。在所有这些操作中，
我们可能需要生成一些中间数据结构。因此，在
中，为了能够再次重用已经被这些
结构使用过的内存，释放不再使用的内存
是有用的。

这正是内存分配器所做的:你可以分配你需要的内存空间量
，一旦你不再需要它，你可以
将它返回给分配器，这样它就可以用于其他的
分配。

# 广义斐波那契分配

在阅读了几种不同类型的内存分配器之后，我
决定使用广义 Fibonacci
序列的分配器对我的目的来说是好的:它不会浪费大量的
内存(平均大约 82.2%的内存被使用)并且
看起来不会太复杂而无法编码(只是一些数字和内存地址的加减
)。

那么什么是广义斐波那契数列呢？常见的斐波那契数列，在关于编程语言的书籍中非常常见，是由公式 a<sub>n</sub>= a<sub>n-1</sub>+a<sub>n-2</sub>描述的数列。因此，广义斐波纳契数列是指最后一项的数字大于 2。在我的分配器中，我使用由 a<sub>n</sub>= a<sub>n-1</sub>+a<sub>n-4</sub>生成的序列。最主要的好处是数字之间的差别不是那么大，这使得它更有效地使用内存空间。另一种常见的内存分配器使用公式 a <sub>n</sub> = 2 * a <sub>n-1</sub> ，这在某种程度上也是广义的斐波那契数列。

# 实施原则

## 区块

我的分配器以 8 字节的块来指定它所分配的项目的大小。主要原因是能够在项目的大小字段中存储三个附加标志位
。这对空间
效率很重要:否则我会为每次分配丢失一些字节，而且
我也想让返回的区域对齐以满足
操作系统的需求，我们不知道:如果用户决定使用它来存储一个
结构或多字节变量，它最好是对齐的。因此，如果操作系统返回对齐内存，我的分配器也将返回对齐内存。否则没关系。

## 自由列表数组

内存分配器使用一个自由列表数组。自由列表是一个由相同大小的条目组成的
链表，它是一个来自
广义斐波那契数列的数字乘以块的大小。
它不是用户可以使用的区域:它还包括标题，
，它包含了项目的总大小。

在数组中，项目按升序存储。在我的
实现中，数组中包含的
结构被称为*单元*。它们包含一个指定
对应空闲列表大小的字段，以及一个指向
空闲列表头部的指针字段。

## 好友

这是一个伙伴内存分配器，对于广义的
斐波那契数列来说很方便:我们可以通过简单地将
与另一个较小的项目组合来创建一个较大的项目。

这就是伙伴系统的工作方式:我们首先从操作系统中分配一些内存
,并将其放入数组中一个合适的
空闲列表中。当用户需要一些内存时，我们可以将可用的内存
分成几个伙伴，每个伙伴的大小是序列的数量乘以块中的字节数。在
拆分后，我们可以将不再使用的好友插入到其
空闲列表中，因为它也有合适的大小。

在释放的时候，发生的是相反的情况:我们想把
buddy 返回到自由列表，但是如果它的 buddy 没有被使用，我们可以先把
和它的 buddy 合并，把合并后的块插入到
对应的自由列表中。广义的斐波那契数列
保证我们无论何时拆分或合并项目，我们都有一些
有相应的空闲列表。为了知道如何合并和
如何找到伙伴，我们使用标志，这将在后面解释。

## 动态数组

如果需要分配更多的
项，包含空闲列表的数组必须能够增长。这就是我使用动态数组的原因。当需要添加更多项目时，其
容量会增加。在这种
情况下，分配了另一个足够容纳数组的区域，并在该区域创建了一个
新数组，它是旧数组
的副本，但具有更大的容量。旧数组被释放。数组的好处是它只使用分配器:它不需要特殊的操作系统调用。

# 实现细节

在这一节中，我将更详细地描述一切是如何工作的。

## 数据结构

### 项

这个条目是一个结构，它是自由列表的节点，一个双
链表。物品有两种存在方式:免费和二手。
当它空闲时，它在空闲列表中，包含指向
上一项和下一项的指针。当它被使用时，它包含区域
而不是指针。

但无论是什么模式，总有一个头。它包含一个指针大小的
单字段。该字段包含块中项目的大小
和 3 个标志:`lr_bit`、`inh_bit`和`in_use`
位。`in_use`位告诉我们该物品是否被使用。为了知道如何合并
好友，需要
`ls_bit`和`inh_bit`:好友可以是左好友或右好友，所以我们
可能需要向右或向左才能找到
好友。

该物料不是 C 结构。这是一个类型为`*void`的区域，用于
使用哪些存取函数。下面是一些
访问函数的例子:

```
uintptr_t
item_get_size(void *item)
{
    uintptr_t size_field = ((uintptr_t*)item)[0];
    return size_field >> 3;
}

void
item_set_size(void *item, uintptr_t size)
{
    uintptr_t size_field = ((uintptr_t*)item)[0];
    uint8_t flags = size_field & 7;
    uintptr_t new_size_field = flags | (size << 3);
    ((uintptr_t*)item)[0] = new_size_field;
} 
```

下面是获取和设置项目大小的函数。如
所示，它位于该项的最开始，索引为
0，占据了
字段的`sizeof(uintptr_t) - 3`高位。

这是另一个例子:

```
boolean
item_get_inh_bit(void *item)
{
    return (((uintptr_t*)item)[0] & 1) != 0;
}

void
item_set_inh_bit(void *item, boolean in_use)
{
    uintptr_t size_field = ((uintptr_t*)item)[0] & (~(uintptr_t)1);
    uint8_t tmp = in_use ? 1 : 0;
    uintptr_t new_size_field = size_field | tmp;
    ((uintptr_t*)item)[0] = new_size_field;
} 
```

现在我们需要设置一个单独的位。它是
字段中最小的位，所以我们在这里使用 1。

另一个重要的东西是面积。该区域是返回给用户的
项的一部分。我们是这样做的:

```
void*
item_get_area(void *item)
{
    return &((void**)item)[1];
} 
```

当用户将区域返回给我们时，使用`mem_free`函数，
我们需要获得项目的地址:

```
void*
item_from_area(void *area)
{
    return &((void**)area)[-1];
} 
```

我们假设用户没有作弊，也没有在这个区域之外写东西，
这意味着我们信任他，我们的数据仍然是我们离开时的样子。这是合作的概念，在
编程领域经常出现。

### 细胞结构

现在我们来谈谈下一个结构，它包含条目，即
单元格。下面是它的定义:

```
struct cell {
    uintptr_t size;
    void *items;
}; 
```

它包含空闲列表第一项的大小和指针。正如您所看到的，在单元格结构中有一个 size 字段，正如
以及项目标题中的 size 一样。只要
项目在空闲列表中，它就必须匹配。这种复制是必要的，因为
列表可能是空的，这意味着我们需要一种方法来知道它的大小。
同样，当项目不在空闲列表中，当它们被使用时，我们
需要知道在哪里归还它们。

### 本阵

```
struct array {
    struct cell *data;
    unsigned int size;
    unsigned int capacity;
}; 
```

其实数组也是一个结构，数组是它的
字段之一:`data`。这里也没什么复杂的。正如我已经
解释的，有一个容量，它告诉多少元素可以
存储在数组中，还有一个`size`，它告诉它当前的大小。

### mem <sub>列表</sub>

当我们从操作系统中获得一些内存块时，我们
将它们组织成一个链表，以便能够在需要的时候释放它们。所以，每次我们使用收到的
内存区的第一个指针大小字节来存储下一个块的地址。这种
方式，如果操作系统要求我们在退出应用程序之前释放所有分配的
内存，我们通过使用这个链接的
列表来释放它。

下面是实现这一点的代码行:

```
while (mem_list != NULL)
{
    void *tmp = mem_list;
    mem_list = *((void**)mem_list);
    free(tmp);
} 
```

## 从操作系统分配

我们需要一个记忆的来源来给用户。为此，我们使用操作系统的内存分配器。但是我们不知道它有多好，也就是说，我们不应该太依赖它
。我们应该只在需要一些内存的时候使用它，并且只用于大块的内存。

为此，我决定实施以下规则:

*   我们应该向操作系统要求一个最小量，它是指针大小的 64 倍。
*   我们要求的时候，要求的量要比上一次大。
*   我们直到最后才把内存归还给操作系统，也就是在应用程序结束时释放所有内存。

这样，我们就不会假设操作系统的内存分配器是好的或者高效的。我们的工作就是让内存分配发挥作用。操作系统的内存分配器可以非常简单
。它甚至可以根本不是一个分配器，而只是大量内存中的一个
指针，因为我们不需要任何复杂的
功能。很可能是 CP/M-80 的过渡程序区
(TPA)。

## 数组中的第一项

数组中的前四项不能拆分，因为没有比它们更小的了。这意味着，如果我们需要分配大量的
小件物品，为了不浪费空间，最好让这些不可拆分的物品尽可能的小
。

因此，让我们来计算最小大小，这将是数组中第一个空闲列表的 items
的大小。

对于 64 位，我们有 8 字节的块和 8 字节的指针。一个
项目必须包含一个标题、一个下一个指针和一个上一个指针。总共有 24 个字节，可以存储在 3 个块中。因此
第一个尺寸将是 3。

对于 32 位，块是 8 字节(不变)，指针是 4 字节的
。三个指针大小的字段需要 12 个字节，我们可以
把它放在 2 个块中(16 个字节)。也就是说，32 位
操作系统的最小尺寸是 2。

对于 16 位操作系统来说，情况类似。指针为 2 字节，
块为 8 字节。我使用 2 个字节作为指针，因为我不希望
使用段使事情变得复杂。所以我们可以把 6 个字节的
(3 个字段)放到一个单独的块中。这使得
物品 1 的尺寸最小。

## 好友系统

当我们分配内存时，我们得到一块内存，me 可能有
分发给好友，只有一个好友会返回给用户
。

当我们释放内存时，我们在数组中插入一个项目，如果好友不在使用中，我们可能不得不递归地将它与好友合并。

所以主要的问题是找到物品的伙伴。为此，我们使用
两个标志:即`lr_bit`和`inh_bit`。`lr_bit`告诉我们
好友是左好友还是右好友。`inh_bit`用于
恢复父好友的`lr_bit`和`inh_bit`，如果
合并，就知道是左好友还是右好友。

拆分一个条目时，我们将左边子条目的`inh_bit`设置为父条目的
`lr_bit`，右边子条目的`inh_bit`设置为父条目的
`inh_bit`。这使得我们在分割时不会丢失信息
:当我们合并时，我们只是从存储它的地方
取回这些信息。

这里有一个例子:

```
*--+--[/|/]
   |
   +--[L|95]--+--[L|69]--+--[L|50]
              |          |
              |          +--[R|19]--+--[R|14]
              |                     |
              |                     +--[L|5]
              |
              |
              +--[L|26] 
```

在这幅图中，我们看到了一些例子，说明了
继承和`lr_bit`是如何从子代中恢复的。
继承位用字母 L 或 r 表示

我们来看节点 69。这是一个右孩子与左继承
位。分割时，*右*属性作为
继承位传给左孩子，左属性作为
继承位传给右孩子。当孩子合并回来时，
`lr_bit`和`inh_bit`都可以恢复。

当我们拆分大小为 19 的节点时，也会发生同样的情况。它是一个
左孩子，这个属性由左孩子作为它的
左右位保存。节点 14 是正确的子节点，它保留了
继承位。

图片上的根节点实际上并不存在。它在
顺序中显示到*假右*节点的连接，它不包含
的任何区域。它的`in_use`位被设置为*真*,以便当它的左伙伴的孩子正在合并时停止
递归。

## 分配和释放

### 分配

这就是分配的工作原理。第一步是确定所需的
块数。我们被给定了字节，我们需要
块的数量。此外，我们不应该忘记标题，其大小
也包括在项目的大小。

一旦我们有了最小数量的块，我们就在数组中寻找合适的项目
。也许我们找到了，也许没有。如果我们没有找到
它，我们需要从操作系统中分配更多的内存。

然后，在我们拥有来自数组或来自操作系统的项目后，我们需要尽可能地分割它，以便根据我们的需要占用尽可能少的内存。

最后一件事是设置`in_use`标志并计算该区域的
地址(实际上是该项的地址加上
头的大小)。重要的是，用户不能访问
标题！所以我们归还这个区域。

### 释放

释放或多或少与分配相反:我们计算
该项目的地址，将`in_use`位设置为假，将
项插入到数组中，并将该项与尽可能多的
空闲伙伴合并。重要的是要保证无论何时我们给用户一个项目
，当它被
释放时，我们在数组中有一个位置来放置它。

## 数组初始化

该数组是一个动态数组:当它达到其最大容量时，它通过分配一个更大的数组并将旧数据复制到新数组中来扩展，之后旧数组所占用的区域被释放。

关于数组的一件重要的事情是我们的分配器是用来扩展数组的。为此，我们必须确保
数组包含一个空闲列表，当我们
需要分配一个新数组时，它能够“接受”我们的数组。在扩展数组之后，我们还
初始化新数组的单元格，以便能够将
插入到它的空闲列表中，但这并不是一个真正的问题，因为如果旧的
数组可以为旧的数组包含足够的字节，那么两倍大的
数组更有可能拥有足够大的单元格，因为数组的
大小线性增长，而空闲列表的大小
有类似斐波那契的增长，这是指数增长。

现在我将展示我是如何为数组的初始化
计算*定义*的。64 位，32 位，16 位都一样，所以我
只展示 64 位。

<colgroup><col class="org-right"> <col class="org-right"> <col class="org-right"> <col class="org-right"> <col class="org-right"> <col class="org-left"></colgroup> 
| 指数 | flsz | 容量 | 数组字节 | 区域-字节 | 商店本身 |
| --- | --- | --- | --- | --- | --- |
| Zero | three | one | Sixteen | Sixteen | 真实的 |
| one | four | Two | Thirty-two | Twenty-four | 错误的 |
| Two | five | four | Sixty-four | Thirty-two | 错误的 |
| three | seven | four | Sixty-four | Forty-eight | 错误的 |
| four | Ten | eight | One hundred and twenty-eight | seventy-two | 错误的 |
| five | Fourteen | eight | One hundred and twenty-eight | One hundred and four | 错误的 |
| six | Nineteen | eight | One hundred and twenty-eight | One hundred and forty-four | 真实的 |
| seven | Twenty-six | eight | One hundred and twenty-eight | Two hundred | 真实的 |
| eight | Thirty-six | Sixteen | Two hundred and fifty-six | Two hundred and eighty | 真实的 |
| nine | Fifty | Sixteen | Two hundred and fifty-six | Three hundred and ninety-two | 真实的 |
| Ten | sixty-nine | Sixteen | Two hundred and fifty-six | Five hundred and forty-four | 真实的 |

正如我已经描述过的，数组中的第一个大小是 3。
列名 *flsz* 代表*自由列表项块大小*。

*capacity* 列表示数组包含多少个单元格。和
*数组-字节*列在字节上是一回事。

*area-bytes* 列是在给定的
索引处一个空闲列表可以包含多少字节。并且当该值大于或等于
*area-bytes* 值时，列*store-self*指示*为真*。
否则为*假*。

因此，在索引 6 之后，数组始终可以存储自身。我们可以确定这一点，因为自由列表的增长大于容量的增长。

但是我决定避免分配少量的内存空间。
对于 64 位，它是 512，对应于具有*索引* 10 的行。
正如我们从这个表中看到的，为初始数组
分配 544 字节是完全可能的，这就是我所做的。下面是代码表单
文件`mem.c`:

```
/* 64-bit OS */
#if defined(__x86_64__)
#define MIN_SIZE 3
#define SIZE_1 4
#define SIZE_2 5
#define SIZE_3 7
#define DATA_INIT_BLOCKS 69
#define ARRAY_INIT_SIZE 11
#define ARRAY_INIT_CAPACITY 16 
```

仅供参考，这是我为 32 位和 16 位系统所做的工作:

```
/* 32-bit OS */
#elif defined(__386__) || defined(__i386__) || defined(__DJGPP__)
#define MIN_SIZE 2
#define SIZE_1 3
#define SIZE_2 4
#define SIZE_3 5
#define DATA_INIT_BLOCKS 36
#define ARRAY_INIT_SIZE 10
#define ARRAY_INIT_CAPACITY 16

/* 16-bit OS */
#elif defined(__I86__) || defined(__86__)
#define MIN_SIZE 1
#define SIZE_1 2
#define SIZE_2 3
#define SIZE_3 4
#define DATA_INIT_BLOCKS 19
#define ARRAY_INIT_SIZE 9
#define ARRAY_INIT_CAPACITY 16

#else
#error Unsupported Operating System, sorry.
#endif 
```

# 可移植性和测试

为了不完全依赖于仅仅一个操作系统，
并且为了知道我在`mem.c`
中定义的事实实际上服务于他们的目的，并且因为我打算为 16 位操作系统在汇编中重写这个
程序，我决定在不同的操作系统上编译和测试
这个分配器。

幸运的是，Linux 可以编译 64 位和 32 位二进制文件，并通过 Valgrind 运行它们。这非常重要，因为它让我或多或少地确定至少 64 位和 32 位版本能正确运行
。

我还将一些生成的内容添加到带有
校验和的分配区域，以确保它不会被破坏。这种
方式，即使我不能在 16 位操作系统上使用 *Valgrind* ，它
不报错的事实已经是一个好的迹象。

## 操作系统已测试

这些是我测试代码的操作系统:

*   带 GCC 的 64 位 Linux
*   带 GCC 的 32 位 Linux
*   带 OpenWatcom 的 32 位 Linux
*   带 GCC 的 32 位 Hurd
*   采用 OpenWatcom 的 32 位 ArcaOS
*   使用 OpenWatcom 的 32 位 DOS
*   带 OpenWatcom 的 16 位 DOS

## makefile

为了编译这个项目，我使用了两个编译器:GCC 和 OpenWatcom。OpenWatcom 编译器使用 C 语言的旧版本，
，其中变量声明必须在块中的第一位，在任何
代码之前。所以为了编译，我不得不在很多地方修改很多东西。

最后，我决定为两个编译器创建两个 makefiles，
,因为它们非常不同，并且为了在每个文件中保持一些一致性。第一个文件是 GNUmakefile。它是用于
GCC 的，所以它不读取 makefile。不幸的是，
OpenWatcom 没有自己的 makefile 名称，所以我不得不使用
“makefile”。

# 结论和再见

所以，这是我的小项目，我试图学习一点关于内存分配的知识，并实现一个通用的 Fibonacci 内存分配器。不幸的是，这还不足以被认为是一个真正的
内存分配器。内存分配器必须能够处理
多线程，这不是这个项目的主要目的。对于
这个原因，我不能将它与真实的内存分配器进行比较，也不能找到一个
测试套件来判断它的好坏。但是对于我的
目的，即更熟悉内存分配，以及
准备好为 16 位单线程
环境编写内存分配器，这正是我所需要的。

下次见，再见。