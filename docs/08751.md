# 版本控制，不再仅仅是代码了！

> 原文:[https://dev . to/tch UPP/version-control-not-just-for-code-more-5a1k](https://dev.to/tchupp/version-control-not-just-for-code-anymore-5a1k)

嘿伙计们！最近我一直在开发一个应用程序，我想就我的一个架构想法获得一些反馈。

### [](#background)背景

想象你正在构建一个内容管理系统(CMS)；比方说，用于托管项目文档或电子商务产品描述。

您客户的简单用例侧重于能够发布、编辑和删除他们站点的内容。只要客户乐于立即发布新内容，这可以通过相当简单的 CRUD 操作来解决。

*   发布新内容(创建/更新)
*   编辑现有内容(检索/更新)
*   移除内容(删除)

这里的数据模型不是非常重要，它可以根据您拥有的内容类型而改变。让我们把它变得非常简单:

```
{
    content: "this is nice"
} 
```

> 注意:示例数据模型使用`javascript`作为表示，这不一定是这个实现的目标语言。

现在，假设您想要提供拥有内容的“草稿”和“已发布”版本的能力；并允许在任何时候将“草稿”版本升级为“已发布”版本。工作流看起来类似于:

1.  创建初稿
2.  编辑草稿(x 次)
3.  将内容从“草稿”提升到“已发布”
4.  编辑草稿(y 次)
5.  将新内容从“草稿”提升到“已发布”

这里的数据模型*稍微*复杂一些，因为我们需要跟踪“草稿”和“已发布”的区别:

```
{
    draft: { content: "this is great!" },
    published: { content: "this is nice" }
} 
```

要发布，我们只需从“草稿”中取出内容，放入“已发布！”

```
{
    draft: { content: "this is great!" },
    published: { content: "this is great!" }
} 
```

这太棒了！只要我们的客户不会意外发布...

许多公司在发布前也有审查流程，有些公司甚至想对内容进行 A/B 测试。有这些用例的客户可能希望能够跟踪多个版本，而不是一个固定的数量。

这正是我的想法适合的地方。我想为客户提供迭代内容的能力，而不用担心失去以前的工作。

### [](#proposal)提议

当我们想要提供引用许多不同版本的能力时，问题就复杂了。

让我们把前面例子中的“draft”和“published”想象成*标签*。我们不想在 CMS 中硬编码可能的*标签*，相反，我们希望为客户提供“标记”他们自己版本的能力；类似于 git 标签的操作方式。

让我们建立一个可能的工作流程:

1.  创建初始版本

    *   内容将被赋予一个独特的版本号，类似于 git 提交
    *   可以使用名为“最新”的标签访问内容
2.  通过创建新版本进行迭代，直到满意为止

    *   新内容将有独特版本的 slugs
    *   最新的内容可以通过“最新”标签访问
3.  用“已发布”标记当前的“最新”

    *   先前的“已发布”版本仍然存在，但只能通过其版本号访问
4.  通过创建新版本进行更多迭代

    *   “已发布”标签将继续指向同一版本
    *   可以针对“最新”版本进行测试，而不影响当前“发布”的内容
5.  审查过程是针对“最新”版本进行的

    *   或者，可以将一个版本标记为“review-1”
6.  测试完成后，将当前的“最新”标记为“已发布”

#### [](#data-model)数据模型

这里的数据模型要复杂得多。

首先，我们必须跟踪每一个版本，并给它们唯一的 id。散列法是一种非常简单的方法来分配一个令人信服的唯一 ID，可以很容易地被验证。

```
versions: {
    "asdf": {
        content: "this is great!"
    },
    "tyui": {
        content: "this is nice"
    }
} 
```

其次，我们必须跟踪版本历史。这需要是一个严格有序的列表，因此作为一个单独的集合存储是有意义的。(我们不能保证映射的键是严格排序的，所以我们不能依赖于`versions`映射的键集)

```
history: [
    "tyui",
    "asdf"
] 
```

第三，我们必须跟踪用户定义的标签。标签一次只能引用一个版本，我们可以有很多个。这里，`tag`是键，值是`version`。

```
tags: {
    "draft": "asdf",
    "published": "tyui"
} 
```

最后，我们必须随时跟踪“最新”版本。因为“latest”是一个保证一直存在的标签，所以将“latest”作为一个显式字段来跟踪是有意义的。

```
latest: "asdf" 
```

总之，数据模型(如 JSON)看起来应该是这样的:

```
{
    latest: "...",
    history: [...],
    versions: {...},
    tags: {...}
} 
```

每次添加新版本时，都会发生一些事情:

1.  新版本被添加到`versions`地图中，ID 作为关键字
2.  “最新”标签用新的 ID 更新
3.  新的 ID 被附加到`history`列表的末尾

有了这个数据模型，我们能够支持许多不同的操作！

*   创建初始/新版本
*   正在检索最新版本
*   按 ID 检索特定版本
*   通过标签检索特定版本

我们遗漏了一项非常重要的行动。如果我们想恢复以前的版本呢？如果我们想“取消发布”呢

我们如何实现“恢复”一个特定的版本？

#### [](#rollback)回滚

有几种不同的回滚策略，但它们都需要遵循两个目标:

1.  避免丢失版本数据
2.  避免创建孤立版本

假设我们的数据模型看起来像这样:

```
...
history: [
    "tyui",
    "asdf",
    "ghjk"
]
latest: "ghjk" 
```

当我们想要回滚到最近的版本时，我们实际上是将“最新的”标签从`latest: "ghjk"`改为`latest: "asdf"`。

所以最大的问题是:我们如何处理最新的版本？

如果我们从历史中删除最新版本，即:
`history: ["tyui", "asdf", "ghjk"]`
- > `history: ["tyui", "asdf"]`
，那么我们必须决定如何处理版本条目。

如果我们删除条目，我们将违反我们的“不删除版本”规则。如果我们留下版本条目，我们将违反“没有孤立版本”的规则。

这两种选择都行不通...

唯一的选择是将我们正在回滚的版本附加到我们的`history`的末尾。

`history: ["tyui", "asdf", "ghjk"]`
->-`history: ["tyui", "asdf", "ghjk", "asdf"]`

我们根本不需要改变`versions`条目，因为`asdf`已经存在了！

### [](#result)结果

留给我们的是一个可以处理创建、更新、标记和恢复数据版本的数据模型。

每个版本都有一个不可变的、唯一的 ID，我们可以通过它的 ID 来访问每个版本。或者，我们可以标记特定的版本，并以这种方式访问它们！我们总是可以使用自动更新的“最新”标签来访问最新的版本。

保证历史严格有序；如果需要，我们可以恢复以前的版本！

你觉得怎么样？

您会在自己的项目中使用这种模式吗？我忘记解释什么了？
你会有什么不同的做法？
有没有一个特定的数据库可以用于持久性？

在下面的评论里分享吧！