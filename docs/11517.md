# “pip 安装”的工作原理

> 原文:[https://dev.to/alexbecker/how-pip-install-works-323j](https://dev.to/alexbecker/how-pip-install-works-323j)

跑`pip install <somepackage>`会怎么样？比你想象的要多得多。Python 的包生态系统相当复杂。

首先`pip`需要决定安装哪个`distribution`包。
这对于 Python 来说比许多其他语言更复杂，因为 Python 包的每个版本(或*发布*)通常有多个`distributions`。有 7 种不同的发行版，但目前最常见的是*源发行版*和*二元轮*。源代码发行版就是它在 tin 上显示的内容——包开发人员编写的原始 Python 和潜在的 C 扩展代码。二进制轮是一种更复杂的归档格式，它可以包含编译后的 C 扩展代码。这对用户来说很方便，因为从源代码编译 *numpy* 需要很长时间(在我的桌面上大约 4 分钟)，而且包的作者很难保证他们的源代码能在其他人的机器上编译。但这是有代价的——编译的代码是特定于架构的，通常是编译它的操作系统，所以大多数带有 C 扩展的包将构建多个 wheel 发行版，并且`pip`需要决定哪个(如果有的话)适合你的计算机。

为了找到可用的发行版，`pip`请求`https://pypi.org/simple/<somepackage>`，这是一个充满链接的简单 HTML 页面，其中链接的文本是发行版的文件名。文件名对版本、发行版本的种类进行编码，对于二进制轮来说，还包括它们所兼容的架构和操作系统。这种格式非常复杂，足以涵盖两种不同的 pep:

*   版本方案由 [PEP 440](https://www.python.org/dev/peps/pep-0440/#version-scheme) 覆盖。
*   二进制轮文件名兼容性标签是 [PEP 425](https://www.python.org/dev/peps/pep-0425/) 的主题。

为了选择一个发行版，`pip`首先确定哪些发行版与您的系统和 python 的实现兼容。对于二进制轮子，它根据 PEP 425 解析文件名，提取 *python 实现*、*应用二进制接口*和*平台*。python 实现可以像`py2.py3`一样宽泛(意思是“python 2 的任何实现”。x 或 3。x”)或者它可以指定一个 python 解释器和主要版本，比如`pp35`(意思是 PyPy 版)。应用程序二进制接口本质上是 C 扩展代码兼容的 CPython 的 C-API 的版本，如果有的话。解释兼容性标记的平台部分更加困难。它可以相对明显，像 32 位 Windows 的`win32`，但我通常安装`manylinux1`轮。哪些 Linux 发行版与`manylinux1`兼容是`distutils`邮件列表上激烈争论的话题。幸运的是，源代码发行版的过程更简单——所有的源代码发行版都被认为是兼容的，至少在过程的这一步是如此。

一旦`pip`有了兼容发行版的列表，它就按版本对它们进行排序，选择最新的版本，然后为该版本选择“最佳”发行版。如果有二进制轮子的话，它会选择二进制轮子，如果有多个轮子，它会选择最适合安装环境的轮子。这些只是`pip`的默认偏好——它们可以用像`--no-binary`或`--prefer-binary`这样的选项来配置。“最佳”发行版要么从本地缓存下载，要么从本地缓存安装，在 Linux 上，本地缓存通常位于`~/.cache/pip`。

确定这个发行版的依赖项也不简单。理论上，可以只使用来自`https://pypi.org/pypi/<somepackage>/<version>/json`的`requires_dist`值。然而，这依赖于包作者上传正确的元数据，而旧的打包客户机不这样做。所以实际上`pip`(以及任何想知道一个包的依赖关系的人)必须下载并检查它。

对于二进制轮子，依赖关系列在一个名为`METADATA`的文件中。但是对于源代码发行版来说，依赖项实际上是当你用`install`命令执行它们的`setup.py`脚本时安装的东西。除非你去尝试，否则无从知晓，而这正是`pip`所做的！具体来说，它利用`setuptools`来运行`install`，直到它知道要安装哪些依赖项。然而，由于运行`install`可能*本身*需要依赖关系，这可能会更加复杂。在 Python 包中指定这一点的标准方式是将一个`setup_requires`参数传递给`setuptools.setup`。通过`setuptools`，`pip`将运行`setup.py`刚好足以发现`setup_requires`，安装那些依赖项，然后返回并再次执行`setup.py`。自然，这是疯狂的，并且`setup_requires`不应该被使用。

一旦`pip`有了一个需求列表，它就为每个所需的包重新开始整个过程，并考虑其版本上的任何约束。它以这种方式构建了一个完整的包树，直到它找到的每个发行版的每个依赖项都已经在树中。如果存在依赖循环，这个过程当然会中断，但它总是会终止——毕竟，python 包的数量是有限的！

但是，如果`pip`找到的一个发行版违反了另一个发行版的要求，例如，如果`pip`首先找到了`idna`版本`2.5`，但随后又找到了需要`idna<=2.4`的发行版，会发生什么呢？嗯，它忽略了这个要求，还是安装了`idna`！为`pip`添加一个真正的*依赖解析器*还有一个[长期未解决的问题](https://github.com/pypa/pip/issues/988)，有许多错误的开始和部分实现，但没有一个真正成功。当然，这在很大程度上是由于确定 python 包的依赖关系的复杂性——当确定单个*候选对象的依赖关系需要下载和执行潜在的数兆字节的代码时，很难构建一个高效的依赖关系解析器！*

接下来`pip`必须实际构建和安装软件包。如果它下载了一个源代码发行版，并且安装了`wheel`包，它将首先从源代码中专门为您的机器构建一个二进制轮。然后它需要决定将软件包安装在哪个库目录中——系统的、用户的还是虚拟的？这由`sys.prefix`控制，而后者又由`pip`的可执行路径以及`PYTHONPATH`和`PYTHONHOME`环境变量控制。最后，它将 wheel 文件移动到适当的库目录中，并将 python 源文件编译成字节码，以便更快地执行。

现在你的包已经安装好了！我真的只是触及了表面——有几十个改变`pip`行为的选项，许多其他发行版类型和平台限制的极限情况，我甚至没有触及安装多个包(它的处理方式不同于具有多个依赖项的包)。但我希望这是信息，如果不是有用的。