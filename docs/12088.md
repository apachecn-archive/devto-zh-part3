# 没有路径的 GoLang(Go 模块简介)

> 原文：<https://dev.to/dizveloper/golang-without-a-path-47jp>

### 用围棋模块把你自己从你的围棋之路中解放出来

我们收到了 Go 模块的礼物，有 Go 1.11。Go 模块很棒有几个原因，但是我最喜欢的原因是它允许你在你的 GOPATH 之外运行你的 Go 代码(T2)。我们来谈谈如何使用它们。

#### 从头做起

要启动一个新项目作为 Go 模块:创建项目目录，编写一个简单的 main.go(你可以在 [**上找到一些简单的例子 gobyexample**](https://gobyexample.com/) )，然后运行

`$ go mod init <project-name>`

现在你就有一个 go.mod 文件了。如果你熟悉 npm，当你使用 npm 时，我基本上认为这是你的 package.json。这是指定模块需要的所有导入的地方。它将被初始化，你的新模块被声明在它的顶部。现在，在新模块中运行下面的命令。

`$ go build`

现在，它实际上不在你的 **GO_PATH** 中也能工作。它还将获取所有需要的模块，并将它们列在您的 **go.mod** 文件中。如果没有另外指定，它将使用最新版本的包。此外，您将实际看到构建过程的输出，而不仅仅是可执行文件。如果您查看 mod 文件，您会看到它还列出了您的模块正在使用的间接依赖项。运行 **go build** 还将创建一个 go.sum 文件，我们将在下一节详细讨论。另一个需要记住的非常重要的命令是

`$ go mod tidy`

当您运行 **go build** 时，它不会将您的测试正在使用的依赖项应用到您的 go.mod 和 go.sum 文件中。运行 **go mod tidy** 将确保包括测试依赖在内的所有依赖都被考虑在内。

现在，您的 go.sum 文件包含了您构建的依赖版本及其散列。同样，如果你熟悉 npm，你可以把它想象成你的 package-lock.json。你不一定要提交你的 go.sum 文件，但是我强烈建议你这样做。散列确保如果您正在导入版本 1.2.3 的模块，特定的发布没有被篡改。维护者/贡献者方面可能会出现混乱，一些更改被强行推进到完全相同的版本中，导致该版本损坏。你的神会保护你不受伤害。

Go.sum 还可以跟踪您使用过的软件包的历史记录。如果您在已经使用了 v1.2.3 之后决定使用 v1.2.2，go.sum 将添加 v1.2.2 的版本散列，并仍然保持 v1.2.3 的散列。这样做是为了如果您决定退回到更高的版本，您将能够继续使用您以前依赖的同一软件包。

> **注意:**如果其他人需要/想要在他们的项目中使用你的模块，只要他们使用的是 Go 1.11 或更高版本，它就能为他们工作。一些以前的版本**可能**也没有任何问题。如果你想确保它**能**在旧版本上工作，你必须**供应商**你的依赖项。您正在使用的所有依赖项应该本地存储在您的 **GO_PATH** 中类似/go/pkg/mod/的目录下。为了确保根据您的模块为其他模块安装所有这些依赖项，请在您的模块内运行下面的命令
> 
> `$ go mod vendor`
> 
> 。现在你会看到你的模块中有一个**供应商**文件。

#### 不使用模块或 go deps 的现有项目

所以现在你想知道如何将一个现有的 Go 项目移植到一个模块中。在你现有的项目上运行 **go mod init** ，现在它差不多是一个模块，但还没有完成。只有一点整理工作要做。接下来，跑**去拿。/…** 它将把你所有的项目依赖项组装到你的 mod 文件中。最后运行 **go mod tidy** 来获得项目中所有的依赖项。

#### 从使用 go deps 的现有项目

如何从使用 go deps 迁移到只使用模块？运行 **go mod init** 将使用您的 Gopkg.lock 构建您的 go.mod 和 go.sum 文件。然后运行 **go mod tidy** 来收集所有的测试依赖项。然后，您可以从项目中移除 Gopkg.lock、Gopkg.toml 和您的旧供应商文件。然后跑**去拿。/…** 最后，作为健全性检查，运行 **go test。/…** 确保一切仍按预期运行。

同样，你可以在这两种情况下运行 **go mod vendor** 来继续支持那些运行旧版 go 的软件。

在 [**Twitter**](https://twitter.com/dizdarevicedvin) <上访问我 3