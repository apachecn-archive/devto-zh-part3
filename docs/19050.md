# C++的无意义联网:介绍 kissnet，一个 K.I.S.S .套接字库！

> 原文:[https://dev . to/ybal rid/no-废话-networking-for-c-introducing-kiss net-a-k-I-s-s-socket-library-3bg 8](https://dev.to/ybalrid/no-nonsense-networking-for-c-introducing-kissnet-a-k-i-s-s-socket-library-3bg8)

*本文最初发表于 blog.ybalrid.info*

有时候我想知道为什么有些东西在 C 和 C++标准库中，而有些却没有。

据我所知，我会不厌其烦地阅读实际的“标准”文件(这些文件大部分是用*legalize*写成的，而不是用你我都能理解的英语)。这些语言是针对“抽象机器”定义的，它们在实际存在的计算机上的实际实现应该遵循为该事物描述的行为，模*一些实现细节*。

除了在“独立环境”中使用这些语言的特定情况(意味着编写的代码实际上不依赖于在操作系统中执行，而是直接在裸硬件上运行)，一些概念，如操作系统具有“文件系统”，其中文本路径可以指向可以打开、读取和修改的文件，这似乎是非常标准的。

奇怪的是，如果文件和文件系统的概念是 C 和 C++标准库的一部分，(从一开始就存在)网络套接字在这两种语言中都不存在。直到 2011 年，C++才有了创建多线程执行的概念，并在其标准库中操纵它们。

所有这些概念:文件、线程和套接字，都是特定于操作系统的构造。例如，在 Linux 上打开一个文件与在 Windows 上打开一个文件有很大的不同。但是标准库提供了一种单一的、独特的、可移植的方式来实现这一点。

这三样东西存在于过去几十年使用的所有操作系统中(至少从 70 年代开始？).我觉得很奇怪，C 标准库只包含文件。由于 C++现在也有线程，我认为这不是问题。所以我们来谈谈另一个…

## [](#a-song-of-files-and-sockets)一曲档案与插座

我想花一些时间来讨论用 C++编写一些底层网络代码。我们今天所知的从网络获取数据的当前接口正在使用一个叫做**套接字**的概念。

由于缺乏更好的类比，一个**套接字**可以被认为是某种“神奇的文件”,当被写入时，它将在网络上发送已被写入的字节，当接收字节时，它们将通过读取所述文件而被访问。这个概念来自 UNIX 世界，在那里一切实际上都是一个文件。这没什么不好，实际上这是一种非常简单、直接的做事方式。

今天*重要的大多数操作系统*都在使用这个类比。当我说今天重要的操作系统时，我想到的是现代的 UNIX 衍生产品(Linux、macOS 和 BSD 家族的其他产品)。和微软视窗系统。

Windows socket API 大部分都是从 BSD 借来的，如果你去掉一些奇怪的东西，比如一些重命名的函数，一些改变的数据类型和增加的初始化过程，Windows sockets 就相当于你在 Linux 上的 sockets。

## [](#100-nonstandard-code)100%非标准代码

但是，在这些语言的标准库中没有这些东西。当你在 Linux 上做 socket 编程的时候，你不是在调用库函数，你是在执行 Linux 内核系统调用，你是在处理文件描述符和字节。

在 Windows 上，您正在调用 Win32 API 的一部分(称为 Windows 套接字 API 的 WSA)。这种情况很不幸，因为这意味着**我**，作为一个 C++程序员，我需要确保我的代码在 Linux 和 Windows 下都能工作。没有一个单一的网络 API，我可以在任何地方使用，而不用考虑它。当然，80%相似，或者 90%相似，但是，如果我需要加上

```
#ifdef WIN32 
```

在我的代码中，一些基本的东西*比如在 2018 年向网络中的另一台计算机发送字节，我们正在做一些错误的事情。*

此外，所有这些操作系统级的 API 都是用 C 实现的，而不是 C++。这意味着你所拥有的一切都是功能和结构。当描述套接字配置时，您正在填充结构并将它们传递给函数。当你必须引用一个特定的套接字时，你需要保留一个小的令牌，并把它交给一个函数。当你需要读取数据时，你需要准备一个有正确字节数的缓冲区，给一个函数一个指针和一个包含缓冲区大小的变量，并确保不要把它们混在一起。

基本上，你是在做 70 年代水平的计算机科学。这对于最底层的代码来说没问题，但对于应用程序的代码来说就不一样了。

## [](#unnecessary-added-complexity)不必要的增加复杂性

有一些解决方案可以解决这个问题，有些甚至在 C++语言内部实现标准化的道路上走得很远，比如 Boost.Asio。但是，以我的拙见，Asio 本身有一个根本问题:它是作为 io 的**。**

对于那些不熟悉 Asio 的人来说，它的名字代表"**作为**同步 **i** nput 和**o**output "。这是一个库，一个好的库，顾名思义:以异步方式进行输入和输出。为了做到这一点，Asio 作为多个上下文和结构来处理多线程和非阻塞调用，以及谁执行它们，以及何时执行它们。

问题是:如果我只是想连接网络和交换数据，我需要担心 *io-context* 和*处理程序、*和*执行程序*吗？**大概不会。**

## [](#keep-it-simple-stupid)保持简单，愚蠢。

在 C++的世界里，我们努力让简单的事情变得简单。来自 **Boost** 项目的库集合就是一个很好的例子。不要误会，这些都是高质量的，经过同行评审的 C++库。它们是由聪明人编写的好代码，带有其他聪明人认可的印记。

它们展示了当你想推动语言发展时你能做些什么。它们包含许多有用的通用代码，您可以重用它们。自 2011 年以来，boost 的许多真正重要和有用的东西终于进入了 C++标准库，如*智能*指针、*超时空*、*数组*、lambdas，以及可能更多类似的东西将从 Boost 上现有的东西跳到标准中实现。

而且，如果今天你要求推荐用什么东西来用 C++编写网络代码，我几乎可以肯定你会被指向 Asio，Boost 中的 Asio 版本，或者，基本上基于 Asio 的网络 TS(对标准的补充，可能会出现在 C++语言的未来版本中)。

正如你能猜到的…我并不是不喜欢 Asio，我发现它真的很有趣，而且可能很有用。但是我不确定这是我想要看到的标准化的东西。

如前所述，如果你只是要做一些 TCP/UDP 通信，Asio 会被包裹在*不必要的复杂性*中。

此外，你的操作系统附带了一个 socket API，但是在 C++中使用起来并不方便，而且如果不做那些难看的事情，它也不具备可移植性

```
#ifdef 
```

预处理器舞蹈。

几个月前，我一直在思考这种情况，并想为什么不把 os 库包装在一个漂亮的 C++17 接口中呢？T3】

## kissnet 简介

Kissnet 是我在夏天开始的一个小的个人项目，我不时地做一些调整，主要是为了好玩，但我觉得有些人可能会对这样的东西有一些用处。

kissnet 的设计目标非常简单:

*   成为一个单独的头文件库，没有链接对象
*   为所有支持的操作系统提供单一 API
*   使用 C++17 std::byte 作为表示非算术二进制数据的“安全”方式
*   尽可能成为操作系统上最轻/最薄的层
*   处理 TCP 和 UDP 套接字在 ipv4/v6 中可以做的所有(或大部分)事情
*   不需要用户担心网络层的端序。
*   只传输字节，不做任何其他事情
*   隐藏操作系统特有的怪异
*   可选的异常支持(您可以选择用程序中止或调用您自己的错误处理程序来代替抛出异常)
*   **保持简单**

Kissnet 只实现 3 种对象:

*   套接字类。socked 的行为是围绕所使用的协议(TCP 对 UDP)和所使用的 IP 版本(ipv4 对 ipv6)而模板化的
*   一个端点类，允许您将主机和端口指定为一个字符串和一个数字，或者一个“hostname:port”字符串。
*   一个“缓冲”类，它只是 std::array 周围的语法糖

缓冲区是用来保存接收到的数据的，缓冲区知道自己的大小，并能为你读出正确的字节数。Kissnet 不关心发送什么数据，这不是 kissnet 的工作。

套接字是不可复制的(但可移动的)对象，它们具有可以应用于套接字实现的典型操作(绑定、侦听、接受、连接、发送、接收)。

如果需要的话，Kissnet 会自动管理底层套接字 API 的初始化/反初始化(就像在 windows 上一样)。这是通过利用 std::shared_ptr <>的引用计数来实现的。这是保存套接字“文件描述符”(=一个简单的整数变量)的唯一开销。

我只在几个玩具程序中使用过 kissnet，没有在真正的项目中使用过，然而，我已经认为我更喜欢这个简单的，金属的，但是类型安全的，跨平台的库，就像使用 Asio 一样。Asio 感觉就像用火箭筒打死一只苍蝇。我听到了一些和我一样的观点。这就是为什么我把这个小实验项目放在 GitHub 上，在许可的麻省理工学院许可下。