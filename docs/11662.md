# 用 bs-socket 实现 ReasonML 中的实时通信

> 原文:[https://dev . to/decudio ly/real-time-communication-in-reason ml-with-bs-socket-1p5l](https://dev.to/deciduously/real-time-communication-in-reasonml-with-bs-socket-1p5l)

在这篇文章中，我将使用 [ReasonML](https://reasonml.github.io/) 在一个简单的应用程序中演示一些实时通信。如果你是一个全新的推理者，JavaScript 中一些假定的基本舒适应该是你所需要的，并且有一个方便的[备忘单](https://reasonml.github.io/docs/en/syntax-cheatsheet)让你开始。

我使用的是 [socket.io](https://socket.io/) 的 [bs-socket](https://github.com/reasonml-community/bs-socket.io) 绑定，这是一个广泛使用的 Node.js 实时引擎，它们的[示例](https://github.com/reasonml-community/bs-socket.io/tree/master/example)作为基础。

完成的应用程序将为每个客户端提供一组命名的按钮和一个添加新按钮的对话框，以及连接的客户端总数。点按按钮会将其从该组中移除，并且该组将在所有连接的客户端之间保持同步。

## [](#requirements)要求

这是一个[节点](https://nodejs.org/en/)的项目。如果你想准确地跟随，我将使用[纱线](https://yarnpkg.com/en/)。所有其他依赖关系将由节点处理。

## [](#setup)设置

首先安装 [BuckleScript](https://bucklescript.github.io/) 平台，如果你还没有的话请安装:

```
$ yarn global add bs-platform 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在我们可以使用`bsb`构建工具来创建一个基本项目:

```
$ bsb -init reason-buttons -theme basic-reason
$ cd reason-buttons/
$ yarn start 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这将在监视模式下启动编译器——您对文件所做的任何更改都会立即触发结果 JavaScript 的重新编译，就在源代码旁边。确认您看到了`Demo.re`和`Demo.bs.js`。在`reason-buttons/src`之下。将您的原因文件重命名为`ButtonServer.re`，并立即重新编译以反映差异- `Demo.bs.js`被移除，相同的内容现在填充到`ButtonServer.bs.js`。

向新生成的`package.json`添加一个脚本来执行这个文件:

```
//  ..  "scripts":  {  "build":  "bsb -make-world",  "serve":  "node src/ButtonServer.bs.js",  //  <-  here  "start:re":  "bsb -make-world -w",  "clean":  "bsb -clean-world"  },  //  .. 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我还将`start`重命名为`start:re`——尽管随意管理你的脚本是最舒服的。

我总是在 Node.js 应用程序中立即进行的一个更改是提取端口号，以便可以通过环境变量指定它。幸运的是，interop 非常简单！我们可以使用 Node 从环境变量中获取它。在`src/Extern.re`创建一个文件，内容如下:

```
[@bs.val] external portEnv: option(string) = "process.env.PORT";
[@bs.val] external parseInt: (string, int) => int = "parseInt"; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`[@bs.val]`语法是一个 BuckleScript 编译器指令。这里有各种语法的概述，指南的其余部分深入讨论了何时使用每种语法。在这篇文章中，我不会深入研究 JS interop 的具体细节，文档很全面，大部分代码都清晰易读。基本思想是关键字`external`有点像`let`，除了主体是指向外部函数的字符串名称。通过这种方式，我们可以逐步地强类型化我们需要的 JavaScript，并且有理由顺利地进行类型检查。

这段代码还将利用`option` [数据类型实用程序](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)来处理可空值，比如来自 [`Belt`](https://bucklescript.github.io/bucklescript/api/Belt.html) 的`getWithDefault`，这是 Reason 附带的标准库。将`src/ButtonServer.js`的内容替换为以下内容:

```
open Belt.Option;
open Extern;

let port = getWithDefault(portEnv, "3000");

print_endline("Listening at *:" ++ port); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我喜欢用`3000`作为我的默认值，当然你也可以使用任何你喜欢的。

在`ButtonServer.bs.js`中，编译后的输出非常易读:

```
// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var port = Belt_Option.getWithDefault((process.env.PORT == null) ? undefined : Caml_option.some(process.env.PORT), "3000");

console.log("Listening at *:" + port);

exports.port = port;
/* port Not a pure module */ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

让我们验证它的工作。打开一个单独的终端，输入`yarn serve`。您应该看到以下内容:

```
$ yarn serve
yarn run v1.13.0
$ node src/ButtonServer.bs.js
Listening at *:3000
Done in 0.09s
$ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

## [](#dependencies)依赖关系

关于如何手动使用 node 的`Http`模块的例子，请参见马切伊·斯莫林斯基的这篇文章。为了简单起见，我只对 [`bs-express`](https://github.com/reasonml-community/bs-express) 使用社区绑定。我们还将引入`bs-socket` :

```
$ yarn add -D bs-express https://github.com/reasonml-community/bs-socket.io.git 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后加到`bs-config.json` :

```
//  ..  "bs-dependencies":  [  "bs-express",  "bs-socket"  ],  //  .. 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

只要有问题的包有一个`bsconfig.json`，Bucklescript 就会处理剩下的部分。

## [](#messages)消息

然而，在我们实际实现我们的服务器之前，我们需要定义一些消息类型。这将帮助我们规划应用程序的范围。在`src/Messages.re`创建一个新文件，内容如下:

```
/* Messages */

type labelName = string;
type buttonList = list(labelName);
type numClients = int;

type msg =
  | AddButton(labelName)
  | RemoveButton(labelName);

type clientToServer =
  | Msg(msg)
  | Howdy;

type serverToClient =
  | Msg(msg)
  | ClientDelta(int)
  | Success((numClients, buttonList)); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这些是我们将来回发送的各种信息。这是与在 JavaScript 中使用`socket.io`的最大区别，在 JavaScript 中自定义事件是用字符串命名的。这里我们总是发出一个通用消息，但是使用 ReasonML 模式匹配来析构有效负载本身。该库目前不涵盖字符串类型的事件，尽管有一个问题是[询问它](https://github.com/reasonml-community/bs-socket.io/issues/9)。GitHub repo 上的 readme 简洁地指出:“这个 API 与 socket.io 的 API 略有不同，在道理上更符合习惯。一般比如 JavaScript 的`socket.emit("bla", 10)`在情理上就变成了`Server.emit(socket, Bla(10))`。

看一看`Messages.bs.js` :

```
// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

它们最终根本不会在我们的包中出现——这只是一个编译时的好处。整洁！

## [](#the-server)服务器

### [](#express)快递

好的——在我们写服务器之前的最后一步。回到`src/Extern.re`，在文件底部为`Http`添加以下类型:

```
module Http = {
  type http;
  [@bs.module "http"] external create: Express.App.t => http = "Server";
  [@bs.send] external listen: (http, int, unit => unit) => unit = "";
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在我们准备好了！回到`src/ButtonServer.re`中，让它看起来像这样:

```
open Belt.Option;
open Express;
open Extern;

let port = getWithDefault(portEnv, "3000");

let app = express();

let http = Http.create(app);

Http.listen(http, port |> int_of_string, () =>
  print_endline("Listening at *:" ++ port)
); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`|>`是管道操作员。简而言之，`a |> b`与`b(a)`相同。当链接多个函数时，可读性会更好。

只是为了验证它的工作，在`Http.listen()`线上方添加一个占位符`/`端点。我们会回到客户身上。

```
App.get(app, ~path="/") @@
Middleware.from((_, _) => Response.sendString("<h1>HELLO, REASON</h1>")); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

好吧，我撒谎了——这里还有一点语法。按照[docs](https://reasonml.github.io/api/Pervasives.html)`(@@)`是应用运算符——“g @ @ f @ @ x 正好等价于 g (f (x))如果你熟悉 Haskell，它就是`($)`，或者如果你熟悉...数学，我猜，是`g o f(x)`。

让我们确保我们准备好了:

```
$ yarn serve
$ node src/ButtonServer.bs.js
Listening at *:3000 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果你点你的浏览器，你应该会看到**你好原因**。

### [](#socketry)Socketry

现在是实时位！在您的`/`端点下面，但在您对`Http.listen()`的调用上面添加下面两行:

```
module Server = BsSocket.Server.Make(Messages);

let io = Server.createWithHttp(http); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在`socket.io`被配置为使用新定义的消息类型。为了跟踪当前的一组按钮和连接的客户端，我们需要一些状态:

```
type appState = {
  buttons: list(string),
  clients: list(BsSocket.Server.socketT),
};

let state = ref({buttons: ["Click me"], clients: []}); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

状态保存在一个可变的`ref`中。我们可以通过`state^`访问当前内容，并用赋值操作符`:=`对其赋值。当服务器启动时，它没有客户端和一个默认按钮。

这个助手函数也很方便，它向存储的每个客户机发送一条消息，除了传递的客户机:

```
let sendToRest = (socket, msg) =>
  state^.clients
  |> List.filter(c => c != socket)
  |> List.iter(c => Server.Socket.emit(c, msg)); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在，一切都已准备好，可以定义应用程序的真正内容了。从下面的大纲开始:

```
Server.onConnect(
  io,
  socket => {
    // our code here....
  },
); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

第一部分是如何处理客户端连接。将占位符注释替换为以下内容:

```
open Server;
    print_endline("Client connected");
    state := {...state^, clients: List.append(state^.clients, [socket])};
    sendToRest(socket, ClientDelta(1));
    Socket.emit(
      socket,
      Success((List.length(state^.clients), state^.buttons)),
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

为了方便起见，我们将在本地范围内打开我们的`Server`模块，然后调整我们的状态以包含新的客户端。我们使用`sendToRest`函数向可能已经存储在`state.clients`中的每个人发送`ClientDelta`消息，最后发送回`Success`消息，告诉新连接的客户端当前的状态。

下一个任务是处理断开。在最后一个`Socket.emit()`的正下方调用 add:

```
 Socket.onDisconnect(
      socket,
      _ => {
        print_endline("Client disconnected");
        sendToRest(socket, ClientDelta(-1));
        state :=
          {...state^, clients: List.filter(c => c == socket, state^.clients)};
      },
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

客户端从应用程序状态中退出，并且仍然连接的每个人都被更新了更改。剩下的部分就是处理我们在`Messages.re` :
中定义的`clientToServer`消息

```
Socket.on(
      socket,
      fun
      | Msg(msg) => {
          switch (msg) {
          | AddButton(name) =>
            print_endline("Add " ++ name);
            state :=
              {...state^, buttons: state^.buttons |> List.append([name])};
            sendToRest(socket, Msg(AddButton(name)));
          | RemoveButton(name) =>
            print_endline("Remove " ++ name);
            state :=
              {
                ...state^,
                buttons: state^.buttons |> List.filter(a => a == name),
              };
            sendToRest(socket, Msg(RemoveButton(name)));
          };
        }
      | Howdy => {
          print_endline("Howdy back, client");
        },
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

每当一个按钮被添加或删除，我们相应地调整我们的状态，并让其他人知道这一变化。服务器到此为止！

## [](#the-client)客户端

### [](#nuts-n-bolts)螺母‘n’螺栓

如果我没有在这个演示中使用 ReasonReact 库，我会感到失职。太棒了。首先，添加依赖项:

```
$ yarn add react react-dom
$ yarn add -D reason-react 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

另外在`bsconfig.json`上加上`reason-react`:

```
 "bs-dependencies":  [  "bs-express",  "bs-socket",  "reason-react"  ], 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

当我们在这里的时候，让我们激活 JSX。将以下条目添加到顶层:

```
 "reason":  {  "react-jsx":  2  }, 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

为了处理捆绑，我将使用[包](https://parceljs.org/)。这是不必要的-你可以使用任何你觉得舒服的东西。要跟进，添加依赖项:

```
$ yarn add -D parcel-bundler 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

还要向`package.json`添加一个脚本来运行它:

```
"scripts":  {  //..  "start:bundle":  "parcel watch index.html",  //..  }, 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们还需要创建那个`index.html`。把它放在你的项目根:

```
<!-- https://github.com/sveltejs/template/issues/12 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Reason Buttons</title>

    <script id="s"></script>
    <script>
        document.getElementById('s').src = "socket.io/socket.io.js"
    </script>

</head>

<body>
    <div id="app"></div>
    <script defer src="./src/Index.re"></script>
</body>

</html> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这个存根在头部包含一个[工作区](https://github.com/sveltejs/template/issues/12)，用于在客户端使用带有 socket.io 的包。还要注意，Parcel 理解 reason ml——我们可以直接传入`Index.re`作为入口点。一旦这个文件在这里，打开一个新的终端并输入`yarn start:bundle` -这可以保持运行，并会在需要时重新编译您的包。

我们现在需要告诉服务器提供这个文件，而不是占位符字符串。我们将使用更多的互操作性——将下面的内容添加到`Extern.re`中，这是从 [bs-socket 示例](https://github.com/reasonml-community/bs-socket.io/blob/master/example/ExampleServer.re)中提取的:

```
module Path = {
  type pathT;
  [@bs.module "path"] [@bs.splice]
  external join : array(string) => string = "";
};

[@bs.val] external __dirname : string = ""; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在将`ButtonServer.re`中的端点替换为:

```
App.use(
  app,
  {
    let options = Static.defaultOptions();
    Static.make(Path.join([|__dirname, "../dist"|]), options)
    |> Static.asMiddleware;
  },
);

App.get(app, ~path="/") @@
Middleware.from((_, _, res) =>
  res |> Response.sendFile("index.html", {"root": __dirname})
); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这将设置我们的静态文件服务，并在`/`而不是占位符字符串处提供由 Parcel 生成的`dist/index.html`。

### [](#code)代码

我们已经将包裹指向`src/Index.re`——在那里放一个文件可能是个好主意！用以下内容创建:

```
ReactDOMRe.renderToElementWithId(<ButtonClient />, "app"); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这就是 ReasonReact 安装到 DOM 的方式。我们终于准备好构建组件了。

在一个真正的应用程序中，理想情况下这将被分成几个部分——一个用于按钮，一个用于输入，可能还有一个单独的用于计数器。出于演示的目的，我只是把它们都放在一个组件中，但是如果这个应用程序要变得更大的话，把它分开可能是第一步。

在`src/ButtonClient.re`创建文件。首先，我们将在文件的顶部设置我们的套接字客户端:

```
module Client = BsSocket.Client.Make(Messages);

let socket = Client.create(); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

接下来，我们需要为组件定义`state`以及我们可以用来转换该状态的`action`，以便创建`reducerComponent` :

```
type state = {
  numClients: int,
  buttons: list(string),
  newButtonTitle: string,
};

type action =
  | AddButton(string)
  | ClientDelta(int)
  | RemoveButton(string)
  | Success((int, list(string)))
  | UpdateTitle(string);

let component = ReasonReact.reducerComponent("ButtonClient"); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这非常类似于`socket.io`消息，只是增加了一个`newButtonTitle`来允许客户端命名他们添加的按钮。

其余的组件将生活在这个框架中:

```
let make = _children => {
  ...component,
  initialState: _state => {numClients: 1, buttons: [], newButtonTitle: ""},
  didMount: self => {
    // socket.io message handling
  },
  reducer: (action, state) =>
    switch (action) {
      // actions
    },
  render: self =>
    <div>
      <h1> {ReasonReact.string("Reason Buttons")} </h1>
      <div>
        // Buttons
      </div>
      <div>
        // Add A Button
      </div>
      <span>
        // Current Count
      </span>
    </div>,
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们将分别查看每一部分。这里给出的`initialState`将用于立即呈现组件——一旦我们的客户端连接上，它将收到一个`Success`消息，该消息将覆盖这个值。

我们需要翻译传入的`socket.io`消息。我已经将它放在了`didMount`方法中，以确保我们的客户端已经成功加载。将占位符替换为:

```
Client.on(socket, m =>
      switch (m) {
      | Msg(msg) =>
        switch (msg) {
        | AddButton(name) => self.send(AddButton(name))
        | RemoveButton(name) => self.send(RemoveButton(name))
        }
      | ClientDelta(amt) => self.send(ClientDelta(amt))
      | Success((numClients, buttons)) =>
        self.send(Success((numClients, buttons)))
      }
    );
    Client.emit(socket, Howdy); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`Client.on()`部分是对传入的`serverToClient`消息进行模式匹配，并将其映射到适当的原因反应`action`。一旦成功加载，我们还会向服务器发回一条`Howdy`消息。

下一个事项是我们的减速器。我们需要定义每个`action`应该如何操纵我们的`state` :

```
switch (action) {
| AddButton(name) =>
  ReasonReact.Update({
    ...state,
    buttons: List.append(state.buttons, [name]),
  })
| ClientDelta(amt) =>
  ReasonReact.Update({...state, numClients: state.numClients + amt})
| RemoveButton(name) =>
  ReasonReact.Update({
    ...state,
    buttons: List.filter(b => b != name, state.buttons),
  })
| Success((numClients, buttons)) =>
  ReasonReact.Update({...state, numClients, buttons})
| UpdateTitle(newButtonTitle) =>
  ReasonReact.Update({...state, newButtonTitle})
}, 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`...` spread 操作符是一个巨大的帮助！这段代码还利用了一个叫做“双关语”的特性——例如，在`UpdateTitle(newButtonTitle)`中，`newButtonTitle`既被用作消息有效载荷的临时名称，也是应用程序`state`中字段的名称。如果它们的名字相同，我们可以用简写的`{...state, newButtonTitle}`来代替`{...state, newButtonTitle: newButtonTitle}`。

剩下要定义的就是 UI 了！按钮列表将把我们的`state`中的每个按钮名称呈现为一个按钮，当点击该按钮时，将发出移除该按钮的信号:

```
{ReasonReact.array(
  self.state.buttons
  |> List.map(button =>
       <button
         key=button
         onClick={_ => {
           self.send(RemoveButton(button));
           Client.emit(socket, Msg(RemoveButton(button)));
         }}>
         {ReasonReact.string(button)}
       </button>
     )
  |> Array.of_list,
)} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们将`action`发送给组件的 reducer，并将`clientToServer`消息发送给服务器，以确保它在任何地方都被删除。

接下来是设置新按钮名称的框:

```
<input
  type_="text"
  value={self.state.newButtonTitle}
  onChange={evt =>
    self.send(UpdateTitle(ReactEvent.Form.target(evt)##value))
  }
/>
<button
  onClick={_ => {
    let name = self.state.newButtonTitle;
    self.send(UpdateTitle(""));
    self.send(AddButton(name));
    Client.emit(socket, Msg(AddButton(name)));
  }}>
  {ReasonReact.string("Add button " ++ self.state.newButtonTitle)}
</button> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

提交后，组件会将字段重置为空字符串。

最后一位是连接的客户端总数:

```
{ReasonReact.string(
     (self.state.numClients |> string_of_int) ++ " connected",
 )} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

就这样结束了！让我们点燃它。假设您已经运行了`yarn start:re`和`yarn start:bundle`，打开一个新的终端，最后调用`yarn serve`。现在打开几个浏览器窗口，将它们都指向`localhost:3000`，当你添加和删除按钮时，你会看到它们保持同步。万岁！

完整的代码可以在这里找到[。](https://github.com/deciduously/reason-buttons)

封面图片被发现[在这里](https://blog.logrocket.com/what-makes-reasonml-so-great-c2c2fc215ccb)。