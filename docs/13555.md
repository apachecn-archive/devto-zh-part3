# 为什么是链表？]

> 原文:[https://dev.to/edisonywh/-elixir-为什么-链表- 1e9d](https://dev.to/edisonywh/-elixir--why-linked-lists--1e9d)

我一直认为数据结构很酷，但你知道什么更酷吗？在野外看到它们！

在浏览 Elixir 的文档时，我看到 Elixir 使用链表作为其线性数据结构。我认为这很酷，但我突然想到了什么；我理解数组和链表，但我不知道它与编程语言有什么关系，从那以后它就一直困扰着我，我*需要*去找出*为什么使用*链表，于是就有了这篇文章！

所以回到这篇文章，根据我目前的发现，有三个原因可以解释为什么 Elixir 会这样(我可能完全错了，请随时纠正我！).让我们一个一个来看:

## [](#immutable-data)不可变的数据

在 Elixir 中(实际上是大多数函数式语言)，数据是不可变的。这是理解为什么使用链表的重要的第一步，所以让我们来探讨一下。

> 不可变意味着一旦数据被声明，它*就不能再*被改变。

假设你知道数组是如何工作的(如果你想复习一下，可以看看我的另一篇文章)。让我们看看如果我们试图用数组实现不变性会发生什么！

数组被定义为一个连续的内存块。这样做的问题是，一个 5 个元素的数组仍然只是一个数组，当我们添加/删除一个元素时，我们是在改变它。那么我们如何对数组使用不变性呢？这不是不可能的，但是让我们看看为什么这不实际。

如果我们想在数组中实现真正的不变性，这意味着每次我们想在数组中添加/删除数据时，我们都需要制作旧数组的完整副本。

这意味着，如果您有一个大小为 5 的数组，如果您想向数组中添加一个新项，您的内存使用量会立即翻倍(因为您需要保持旧数组不变，还需要创建一个包含相同元素的新数组)。这只是空间复杂度，我们还需要考虑时间复杂度！

链表没有相同的约束，因为节点都单独存储在内存中，这意味着我们在添加/删除链表中的节点时，不需要担心空间/时间的复杂性。

这给了我们为什么使用列表的第一个原因，然而这并不是故事的全部——这是递归结构/尾部共享开始的地方，一切都变得有意义了。

## [](#recursive-structure)递归结构

你注意到链表根据定义是递归的吗？

比如`A -> B -> C -> D`是一个链表，但是`B -> C -> D`、`C -> D`等等也是，每个链表只是另一个链表的*子*结构！

这本身并不令人兴奋，但这对下一个谜题至关重要！

> 有趣的事实:递归的本质加上数据必须是不可变的这一事实(所以你不能有一个循环计数器)是函数式语言通常与递归联系在一起的原因——它们必须这样！

## [](#structuraltail-sharing)结构/尾部共享

所以，我们知道链表本质上是递归的。结合语言的不可变特性，我们知道数据永远不会改变。

这很有趣，因为现在我们可以自信地说`A -> B -> C -> D`是与`B -> C -> D`不同的列表(即使一个递归地包含另一个)，并且因为我们有这个保证(以及列表不能改变的事实)，我们不必两次定义相同的数据，并且**我们可以重用现有的链表！**这叫做**结构共享**。

太棒了，不是吗？让我们看一个例子。

例如:

```
list = [5,6,7,8]
list_one = [1 | list]
list_two = [2 | list] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在我们有三个不同的列表！`list`、`list_one`和`list_two`，但它们都共享同一个引用(尾部)，它们之间唯一的区别是头部指针。

这意味着内存中总共有 6 个元素。添加到列表具有较低的内存开销，同时保留了我们所期望的不变性。

可重复使用的宝贝！

[![Baby smiling gif](../Images/d9bd7617d7465a7536ad4d4ee3966e90.png)T2】](https://i.giphy.com/media/fqygzR9D6j2uc/giphy.gif)

如果你想读得更多一点，你可以看看 [Trie 树](https://en.wikipedia.org/wiki/Trie)，它们有完全相同的共享数据/前缀的概念！

### [](#garbage-collection-amp-caching)垃圾收集&缓存？

这两个我不太确定，但是我听说链表对 GCs 有好处，并且尾部共享是引用/缓存局部性的一个很好的候选(我不知道怎么做，因为它们不存储在同一个地方)。如果有人想插话，我将不胜感激！

## [](#closing-note)关闭注释

顺便说一句，实际上它不是关于 Elixir 的，因为它可以编译成 Erlang，但也不是关于 Erlang 的，因为所有的函数式编程都做几乎相同的事情，但这是促使我好奇的原因，也就是与 Elixir 的联系。

在写这篇文章的时候，我发现在我能够深入到灵丹妙药部分之前，我必须深入地写数组是如何工作的，所以我把它作为另一篇文章发表在这里；请务必阅读这篇文章，以便更好地理解什么是折衷！

[![edisonywh image](../Images/388d2736cc1db9d9adde421c4812f753.png)](/edisonywh) [## 数组的工作方式数组的工作方式

### 爱迪生 Yap 2 月 12 日 197 分钟阅读

#ruby #computerscience #c](/edisonywh/how-arrays-work-the-way-arrays-work-3bpg)

我也没有真正谈论大 O 符号，因为我觉得它们可能会给文章增加不必要的阅读时间和 T2 复杂度，但是它们对计算机科学非常重要和基本，所以我建议你稍微复习一下。

如果你是播客一类的人，有 CodeNewbie 的 [BaseCS](https://www.codenewbie.org/basecs) ，由 Vaidehi Joshi 和 Saron 共同主持。

如果你想读的话，Vaidehi Joshi 的 blogpost 版本(我相信这是播客的灵感来源)在 BaseCS 媒体上也很棒。

至于视频，[my deschool](https://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)是超越惊人的，实际上是我现在知道的一切，强烈推荐！

除此之外，希望你们喜欢这篇文章就像我喜欢写它一样！

## [](#sources)来源

[https://elixir-lang . org/getting-started/basic-types . html # linked-lists](https://elixir-lang.org/getting-started/basic-types.html#linked-lists)——这篇文章的灵感来源