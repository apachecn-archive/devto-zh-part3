# 为可延展性设计软件系统

> 原文：<https://dev.to/andrewhowdencom/architecting-a-software-system-for-malleability-2p7>

过去几年的软件开发给了我一个美丽的见解:

> 我不能预测未来

为了在个人层面上说明这一点，成为一名软件开发人员甚至不是我的计划。我本科学习的是运动生理学，我的目标是继续学习运动医学。然而，通过生活中固有的命运的各种曲折，我最终帮助建立和运输电子商务商店。

然而，生活的变幻莫测不仅仅发生在我身上。它们是生活固有的一部分。心理学家丹尼尔·吉尔伯特在他的演讲《未来自我的心理学》中说:

> 我们问人们他们期望在未来 10 年内改变多少，以及他们在过去 10 年内改变了多少，我们发现，嗯，…人们低估了他们的个性在未来 10 年内会改变多少。

所以，6 年前我不知道我会在这里，根据吉尔伯特的评估，我们不知道下一个 10 年我们会是谁。由此可见，很难预测我们的技术在未来 10 年应该向何处发展。我们可以通过回顾过去十年来评估这一点；

*   苹果应用商店、Chrome、安卓和比特币都是在 2008 年发布的
*   带 GPS 的地图在 2009 年进入安卓系统
*   iPad 和 car2go(短期即时租车)都是在 2010 年发布的
*   2011 年，Google+推出，Adobe 开始淘汰 Flash
*   Windows 8、4k 电视、Windows phone、火星上的好奇号、谷歌眼镜、802.11ac 和飞往国际空间站的 Space X 都是在 2012 年
*   Oculus Rift、智能手表和触控 ID 于 2013 年登陆
*   自动驾驶汽车在 2014 年开始出现
*   Apple Pay、Project Loon 和 2015 年发布
*   IOT 在 2016 年开始认真出现
*   自动驾驶卡车、强化学习(AlphaGo)和智能音箱在 2017 年取得了长足的进步
*   在手机上运行的廉价神经网络(张量流)、自动翻译的蓝牙耳机和 GDPR 是 2018 年的一部分

这让我们来到了 2019 年。这些技术都对市场产生了影响，极大地改变了各行业的力量平衡，并为那些足够幸运地找到人才、资本和动力来利用它们的人提供了新的机会。

从这些变化中吸取的教训是，世界变化的速度远比人们天真地想象的要快，在设计我们的软件系统时，我们应该将这种高变化率考虑在内，这样我们就不会让自己或我们的项目合作伙伴因试图围绕他们的下一个商业产品进行创新而陷入财务困境

## 已经成功适配的平台

显而易见，如果我们要评估如何设计我们自己的软件以最大限度地适应，我们应该看看其他人在过去已经成功适应行业变化的做法。

苹果、思科和英特尔都是硬件(除了软件)公司，所以出于我们的目的，我们将把它们作为目标公司。然而，谷歌、微软、脸书和 Adobe 都是主要的软件公司，所以可以作为如何建立系统的很好的教训。谷歌和脸书是众所周知的“互联网”公司，但 Adobe 和微软近年来都转向更多的互联网驱动。微软曾宣称 Windows 10 将是他们的最后一个 Windows 版本，Adobe 正通过“体验云”向互联网驱动的业务迈出重要步伐。

所以，这些公司正在向软件发展:

*   主要通过互联网交付
*   逐步开发并交付给用户，并根据用户反馈进行调整
*   通过“持续收入”模式销售，无论是订阅还是广告

这些公司的共同点是，他们的产品都是围绕软件设计的，这些软件在任意方向上都包含不断的变化。

## 软件设计要求

为了理解如何设计软件，首先有必要解释一下我们为什么要构建软件。一般来说，我开发软件是为了让计算机以一种可靠的方式解决一个问题，并从中得出某种有用的结果。程序可以简单到:

```
# Get a list of unique commands run on this machine
$ cat /var/log/auth.log | cut -d':' -f11 | sort | uniq 
```

Magento 1 的庞然大物 170 万行代码:

```
$ sloccount clean-magento-ee
Total Physical Source Lines of Code (SLOC) = 1,730,997
Development Effort Estimate 502.62 
```

不管怎样，软件程序是为某些人类目的而存在的；获取一些人类输入并返回一些人类输出(在某个时刻)。

### 为合理而设计

软件的效用是其可预测性的函数；我们对如何使用它来完成工作的理解。这方面最好的例子可能是名为 cat 的 Unix 实用程序:

```
$ cat foo
bar 
```

这个程序把文件“foo”的内容打印到屏幕上，显示“bar”。猫最特别的地方不是它的这种行为，而是:

*   它最初是在 1971 年设计的
*   它没有改变

这是可预测程序的本质。有一大批 unix 程序遵循这一趋势；Peter H. Salus 阐述如下:

> 写程序做一件事，并把它做好。

这种简约方法的智慧很难被夸大。容易预测并遵循“标准”方法的程序具有一些独特的优势:

*   理解它们并使它们适应我们的架构的时间是最少的
*   它们的潜在用例很大
*   它们与其他系统的互操作性很强

此外，保持特性集的有限性使得软件的维护变得更加简单，尤其是在保留它所用于的用例的知识的同时——包括那些最初设计的和那些随着时间的推移而积累的。

这极大地降低了维护一个软件的成本，也降低了这个特定软件随时间变化的可能性。

### 为可询问性设计

一般来说，我们不仅为自己设计软件，还代表他人解决问题(通常是为了一些金钱上的补偿)。这造成了以下方面的脱节:

*   我们如何理解问题，如何设计要使用的软件
*   软件的实际使用方式

John Allspaw 将此称为“线上/线下”，其中每个用户、开发者和其他利益相关者对软件如何“工作”有不同的概念模型。该模型只基于“现实”，通过询问
软件来确保它实际上按照最初的设计运行。为了做出关于软件应该如何进一步缩减、重构或替换的设计决策，我们需要知道软件是如何被使用的。

我们可以从审问 cat 开始这个过程。cat 是用 c 写的，运行在 unix 上。Unix(特别是本例中的 Linux)公开了一整套工具，允许使用 sysdig 等附加工具检查 cat 和其他应用程序，如 strace、ltrace、
perf。然而，尽管这些工具让我们非常清楚应用程序在特定调用中做了什么，但它们的运行成本太高。相反，我们需要转向粒度更小的工具。不幸的是，这是有代价的——我们需要提前猜测我们需要检测什么。

这样做有三种主要方式:

*   日志
*   韵律学
*   跟踪

在不深入细节的情况下，应用程序的设计应该公开理解其工作方式所需的细节。这有助于了解应用程序何时工作不正常，也有助于了解在正常情况下如何使用应用程序。

在选择如何检测应用程序时，最有用的特性可能是能够向软件提问——询问它。日志可能是做到这一点的最简单的方法，它允许我们在报告问题时检查内部程序状态。但是时间序列数据是非常接近的第二，并且允许查询应用程序随时间的行为。这允许对人们如何使用应用程序做出判断，而不仅仅是随着时间的推移拍摄应用程序的内部状态。Prometheus 文档解释了如何对应用程序进行检测，以最大限度地提高其可询问性。

通过理解如何使用它，我们可以修改我们的程序，使那些用例更容易或更有效。此外，我们还可以删除一些不再使用的功能，以保持程序的简单性，并降低维护成本和风险。

随着软件的使用越来越频繁，用户会更好地理解它。这也是软件工程师应该投入最多时间的地方，以确保软件以一种用户易于理解的方式设计，并且
为简单而设计的理由将进一步增加理解，形成良性循环，直到达到“最佳简单”的水平。

### 设计着眼于解决用户问题

运送软件的过程非常复杂，包括:

*   业务流程建模
*   UX 设计
*   总体建筑设计
*   软件组件设计
*   软件基础设施

这些学科中的每一个都是复杂的，涉及大量的研究、学科和长期的努力。因此，很有可能每个组件都有专家，每个专家都尽可能地做好自己的工作。

重要的是，在设计和实现这个系统时，目标是解决用户的问题。一个人可能会迷失在自己学科的细枝末节中，以整个系统和用户的问题为代价，创作出一件相关的艺术品。

为了解决用户问题，每个利益相关者都需要服从他们自己的理想解决方案，以支持有利于客户幸福的解决方案。为了在开发设计时保持这种关注，需要将客户置于所有决策的最前沿；每个决策都与该决策如何帮助客户解决问题有关。

通过这样做，虽然系统的每个组件对于构建它的人来说可能更复杂或更不优雅，但绝大多数用户将体验到一个更简单、更容易理解的系统。

### 设计不出意料的软件

“令人惊讶”的软件是不可预测的软件。不可预测的软件对用户来说更难使用，反过来以不可预测的方式驱动应用程序的使用。这种不可预测的用法意味着:

*   大量的重构使不寻常的机制成为标准用例
*   将用户转移到标准模型的大量重构

不管怎样，相当多的东西需要改变。因此，开发软件的目标应该是“最不令人惊讶”或“最不令人吃惊”。这个原则被称为“最小惊讶原则”:

> “人是系统的一部分。设计应该符合用户的体验、期望和心理模型。”

不幸的是，用户感到惊讶的是上下文特定的。在设计闹钟时，用户可能期望一旦他们关闭闹钟，闹钟就会消失，直到下一次发生，他们可能期望医院监视器在一段时间后将闹钟重新打开。因此，设计“用户期望的”软件需要深入了解用户，以及他们使用软件的环境。

这是非常难得的。软件开发的研究是如此复杂，它排除了对其他领域的深入了解。然而，人们可以采取两种策略来帮助设计软件:

*   按照已经建立的模式设计软件。像设计其他医院软件一样设计医院软件，像设计其他闹钟一样设计闹钟。
*   与用户密切合作，征求并整合他们的反馈

即使是最棘手的问题，也可以通过精心设计的软件来匹配他们的概念模型，从而变得更简单、更易于用户理解。

### 平衡设计软件

考虑到上述需求，也许最难做的事情是在它们之间取得平衡，并且相对于该项目的每个设计者或消费者来说，设计软件要简单。

例如，对我这样的开发人员来说可能很简单，但对我的祖母来说可能就不简单了。

每个涉众都有不同的软件模型:

*   用户根据他们试图解决的问题来建模
*   UX 团队针对用户对应用程序的使用进行建模和优化
*   业务逻辑团队试图在软件中为用户建模
*   企业主从投资回报的角度对其进行建模

这使得软件架构师很难让软件相对于所有用户都简单。然而，随着时间的推移，有一些方法可以决定如何发展软件以适应涉众。

随着软件的发展，涉众对彼此的了解越来越多，很明显，这些用户看待软件的方式存在共性。例如，在电子商务商店的情况下，用户、UX、企业
逻辑和企业所有者对“订单”或“货物”的需求都有大致相同的概念，尽管详细程度不同。

通过编写软件来有意识地与所有涉众交流它自己的本质，编写支持文档来清楚地解释软件，如果软件不能解释它自己，并且最小化软件拥有的
数量，软件本身可以保持简单，并且所有涉众有一个相似的软件模型。

一旦这些模式建立起来，继续重用它们，加强对软件的一致推理方式。

## 了解我们的设计

为了理解我们正在设计的东西，我们首先需要考虑我们正在解决的问题。

### 拳击

在过去的生活中，我花了相当多的时间训练成为一名拳击手(更确切地说，是一名泰国拳击手)。虽然这只是一个习惯，但这是一项我从根本上喜欢的活动。此外，还需要购买一些设备。要参与，我需要。

*   1x。16 盎司拳击手套
*   2x。护口器
*   4x 汗衫、短裤和外套
*   1x。腹股沟防护装置
*   1x。护胫(重型)
*   1x。护胫(轻型)

我们将考虑的软件之旅是希望把我和继续我的拳击职业所需的设备联系起来。

### 模拟购买和使用过程

在上述设备中，它没有什么特别好的风格、强调或其他不同的价值——在“拳击设备”的世界中没有什么时尚；它们本质上是商品。最重要的是，我会
奖励:

1.  功能的
2.  舒适的
3.  持久的

作为该设备的购买者，我可能会采取以下步骤:

*   当我加入(或重新加入)一家拳击馆时，我发现了对这种设备的需求
*   和同行讨论一套可靠的设备会是什么样的。如果网站上有，我可能会直接去那里买。
*   进一步研究可能有哪些设备可用，并寻找可以帮助我确定我想要什么品牌的设备的评论
*   购买该设备，并在培训期间使用一段时间
*   购买旧的或新的设备，一旦这些设备已经超出了它的效用。

这些组件中的每一个都在软件中有一些反映；从加入拳击俱乐部，到使用一段时间后对设备进行评估以便重复使用。

## 设计软件本身

鉴于我们对设计弹性软件所需原则的理解，让我们试着帮助我们的拳击手找到他们需要的设备。

### 启动并迭代

正如我们已经确定的，我们对未来的预测能力很差。所以为了理解我们的问题，我们需要开始解决它。

购买 journey 的用户最简单的方法就是在拳击馆进行现金交易。这是一个完全没有软件的解决方案，但作为一个过程，这是一个相当优雅的解决方案:

*   这很简单，并重用现有的基本要素(现金，设备)
*   它的成本极低，易于实施

这允许我们开始填写我们的业务流程。像“我们从哪里购买我们的商品”或“我们把商品存放在哪里”或“用户想知道我们商品的什么”这样的事情都开始出现，需要解决。

### 解决已解决的问题

鉴于我们的情况，我们的拳击馆一直持有设备，但正在努力了解哪些设备卖得好，哪些卖得差，还有多少库存。根据我们之前定义的原则，这个过程是不可质疑的。

在这种情况下，用例相当普遍，并且已经有解决方案在很大程度上解决了这些问题。

加入一个解决“足够”问题的解决方案通常是一个好的下一步。像 VendHQ、Square、Xero 这样的东西可以解决这些需求中的绝大部分，而在它们还没有解决的地方，人类的过程可以弥补差异。

这些解决方案在技术上可能不是最优雅的。然而，它们已经被用户需求所塑造，因此对我们的用户来说在概念上是最简单的——它们比我们自己更好地解决了用户的问题。

小心那些比现在需要解决的问题更能解决问题的解决方案。移除过程比添加过程更难，除非对某个特性有需求，否则它很可能是多余的。这增加了复杂性，因为
没有可识别的增益。

### 建筑附加服务

我们的拳击馆现在成功地向其会员销售了设备，但是健身房只有有限的员工，没有时间在课程开始前解释各种设备之间的权衡。

为了解决这个问题，他们需要一种软件，允许他们以某种可消费的格式列出他们的服务——事实上是在互联网上实现。

根据之前选择的软件，我们的拳击馆可以简单地“打开”与 Shopify 或 Magento 的集成，允许他们重用现有数据。如果是这样，这是这种情况下的最佳解决方案。健身房可以继续使用他们现有的服务，只需进行有限的额外学习，就可以在线列出他们的服务。

然而，如果这种集成不可用，那么就有必要开始重新评估整个业务堆栈，这样一个解决方案就可以解决所有问题。虽然这意味着更高的初始投资，但在学习、诊断和任何时间尺度上的任何进一步发展方面，这将是一个显著的低投资。

### 设计独特的服务

我们的拳击馆现在已经发展壮大，并在其健身房和网上销售设备。然而，它希望开发一个市场上不存在的新功能——直接从其他健身房销售设备的能力。

这个需求是如此的独特，以至于没有现有的软件可以用来模拟这个特殊的需求。要么必须重新调整现有软件的用途，要么必须设计新软件。

是重新调整现有软件的用途还是重新设计新软件，本质上取决于新软件所需的全部功能集。如果对业务有很好的了解并且需求有限，设计新软件会带来一些令人信服的好处:

*   该软件可以被设计成利用商业效率
*   该软件为实施团队所熟知
*   从绝对意义上来说，软件并不复杂

然而，这也带来了失去执行团队的重大风险。如果这个团队消失了，一个新的团队将需要重新学习整个业务。相应地，如果软件被外包出去，使用一个
“标准”的解决方案，加上最少的定制，就为与承包商的关系买了一份保险。

出于这个目的，我们将假设开发团队是内部的，并且对项目的成功感兴趣。

也许最好的办法是完全重建业务逻辑。这意味着失去商业或开放源码软件固有的许多特性，但也极大地降低了系统的绝对复杂性。这使得直接针对业务需求的开发速度更快。

结果是软件更简单，更有针对性，更好地控制业务——假设开发团队有能力进行这样的软件设计。

## 延展性软件的缺点

可塑性软件非常难以设计。它有一些明显的缺点:

### 昂贵

正如在拳击馆老板的例子中所描述的，从零开始设计软件是不经济的，直到业务需求使得不存在可以容易地移植到业务需求的软件。

从头开始设计软件是一项极其昂贵的工作。开发人员是一种稀缺资源，而由业务结果驱动的开发人员就更少了。

对于服务来说，重用现有的原语通常是一个更好的平衡，而不是跳到完全定制的、可延展的软件。定制的软件越多，维护起来就越贵。

### 难

理解、设计和实现软件的过程是一项极其困难的任务。它需要对问题有深入的了解，有耐心提出设计和修改设计，并有能力在软件中实现设计。

### 长期

具有延展性的软件确实会有回报，但这需要很长一段时间。前期投资是巨大的，只有在没有其他选择的情况下，才能通过渐进主义和向自托管解决方案的转变来更好地抵消。

然而，一旦解决方案的初始设计已经完成，并且假设维护成本不会过高，则更具延展性的解决方案将会带来更多商机。

## 总之

设计软件是一个复杂的过程，需要平衡所有利益相关者的需求，同时保持真实的愿景，它打算在很长一段时间内通过许多不同的手来解决。

然而，希望这篇文章已经提供了一些关于软件如何以一种更具延展性的方式设计，从而降低长期成本的一般背景。