# 探索 Ruby:什么杂凑？

> 原文:[https://dev.to/dabrorius/what-the-hash-快看-红宝石-哈希-陷阱-4cg](https://dev.to/dabrorius/what-the-hash---a-quick-look-at-a-ruby-hash-pitfall-4cg)

不久前，我偶然发现了一段让我有点困惑的 ruby 代码。

假设我们需要一个散列，其中每个值都有一个数组。创建一个使用空数组而不是 nil 作为默认值的散列是合理的，对吗？

好吧，让我们试试这个:

```
hash = Hash.new([])
hash[:foo].push "Bar"
hash # => {} 
```

嗯好的。这似乎不太管用。我们在那个键里存了什么东西吗？

```
hash[:foo] # => ["Bar"] 
```

等等，它在那里？

```
hash # => {} 
```

它不见了。什么卷心菜？

让我们检查一下关于 [Hash.new](https://ruby-doc.org/core-2.6.2/Hash.html#new-method) 的文档。

> 返回一个新的空哈希。如果该哈希随后被与哈希条目不对应的键访问，则返回的值取决于用于创建该哈希的新的样式。在第一种形式中，访问返回 nil。如果指定了 obj，这个对象将用于所有默认值。

因此，如果我们将一个对象指定为默认值，那么对于未知的键，将总是返回这个实例。如果我们修改该实例，那么将返回修改后的版本。

所以当我们这样做的时候:

```
hash[:foo].push "Bar" 
```

我们访问并修改了默认对象。但是我们从来没有为`:foo`键设置值。即使设置了默认值，从哈希中读取值也不会修改哈希本身。这就是为什么我们得到一个空散列。

然而，如果我们访问`:foo`键，我们得到的数组中有“Bar”字符串，因为这是新的默认值。实际上，如果我们访问任何其他不存在的键，我们将得到相同的数组。

```
hash[:fiz] # => ["Bar"] 
```

因此，对于这个特定的用例，我们应该在创建新散列时使用第三个选项，那就是使用块。根据 Ruby 文档，这应该可以正常工作。

> 如果指定了块，将使用哈希对象和密钥调用它，并且应该返回默认值。如果需要，将值存储在散列中是块的责任。

```
hash = Hash.new { |hash, key| hash[key] = [] }
hash[:foo].push "Bar"
puts hash # => { :foo => ["Bar"] } 
```

在这种情况下，我们仅仅通过访问缺省键来为它分配一个新值，这就像预期的那样工作了。

然而，这可能不是一个非常明智的想法，当有人试图读取一个值时修改散列似乎是一种非常意外的行为，可能会使您的开发伙伴或未来的您感到困惑。