# 代理设计模式[结构]

> 原文:[https://dev . to/its coders life/proxy-design-pattern-structural-4nhc](https://dev.to/itscoderslife/proxy-design-pattern-structural-4nhc)

代理设计模式背后的核心思想是控制对对象的访问。我们定义了代表另一个对象或远程服务的占位符或代理对象。客户端使用这个代理，而不是真正的对象。代理根据需要将客户机请求转发给实际的主体。

*   代理模式充当另一个对象的代理，并控制对它的访问。
*   代理还可以执行优化，推迟底层对象的实例化，或者保护资源免受未经授权的访问。
*   我们可以在以下情况下使用代理:
    *   远程代理允许访问远程资源，比如 RESTful 服务。远程代理充当远程对象的本地占位符。客户端可以调用该本地代表的方法，该方法又将请求转发给远程对象。
    *   虚拟代理可用于管理昂贵资源的创建和计算密集型操作的执行。我们可以通过推迟昂贵的操作，直到真正需要它们时，来提高性能和内存使用。
    *   保护代理控制对敏感对象的访问。surrogate 对象检查调用方是否具有使用受保护资源所需的适当权限。

> 代理模式为另一个对象提供了一个占位符，以控制底层资源的访问方式。代理引入了额外的交互级别，以支持受控、远程或延迟访问。

示例:考虑是否只有当用户执行特定操作时，您才必须从网络获取和显示数据。创建一个 NetworkDataProxy 类对象，设置 URL 和完成处理程序。这本身不应该下载/获取远程内容。只有当特定的用户动作被触发时，代理对象才会被获取。这仅在需要的基础上推迟了内容的下载。

使用 ImageProxy 类也可以做到这一点，它可以用于按需下载图像，而不是在了解用户需求之前预先下载。

有用的场景:

*   允许访问远程资源，如 RESTful 服务。远程代理充当远程对象的本地占位符。客户端可以调用该本地代表的方法，该方法又将请求转发给远程对象。
*   管理昂贵资源的创建和计算密集型操作的执行。
*   我们可以通过推迟创建昂贵的资源直到它们被第一次访问来提高性能和内存使用率。
*   控制对敏感对象的访问。surrogate 对象检查调用方是否具有使用受保护资源所需的适当权限。

*如果这些情况*都不适用，你就不应该使用代理模式。

缺点:

代理对象应该用于对它所代表的资源执行所有必需的操作。如果客户端可以绕过代理并直接使用基础类型，代理模式的好处就变得毫无用处。