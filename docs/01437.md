# 为什么估计总是一种猜测

> 原文:[https://dev . to/scotthannen/why-estimation-is-always-a-guess-36 G7](https://dev.to/scotthannen/why-estimation-is-always-a-guess-36g7)

我们能够为非平凡的开发提供的最佳估计总是基于善意的有根据的猜测。下面是我们为什么称估计为“估计”的部分解释

为了尝试一个完全精确的估计，我们需要做一部分开发工作——也就是被估计的工作。这项工作的一个重要部分将包括阅读和理解现有的代码，经常理解不同系统之间的交互，以及计划变更。不管我们估计与否，我们都必须做这些事情。估计的准确性将取决于我们预先做了多少。

预先做这样的研究和计划通常是有意义的，但是我们这样做通常是为了帮助我们得到一个更有根据的猜测，而不是产生一系列完美详细的开发步骤。我们越是精确地计划每一个步骤，以至于我们可以估计它们需要多长时间，我们实际上执行的开发工作就越多，这是对工作的估计*的一部分。*

考虑这意味着什么:我们可以要求开发人员花时间*尝试*提供详细、准确的评估，但是现在评估工作将包括开发工作的一部分。结果呢？我们将不得不问开发商需要多长时间来产生估计。没错，该估的估。

在这一点上，我们离完成实际的工作以产生一个评估只有几步之遥。我们生产出想要的软件，它需要整整七个月，现在，零剩余工作，我们可以准确地“预测”开发需要七个月。

我是在夸大其词还是在玩文字游戏？一点也不。如果我们希望为非平凡的开发提供完全准确的“估计”来满足一组特定的需求，那就是我们要去的兔子洞。这就更容易理解为什么我们没有做到这一点，而是满足于一个消息灵通的、真诚的猜测。

但是假设我们没有。荒谬的是，我们试图计划出预期开发的每一个细节，预先解决每一个问题，以便我们确切地知道做出相应的修改需要多长时间。这能成功吗？

不会。每一个计划的开发步骤都依赖于在前面的步骤完成后对系统的确切状态的了解。这将要求我们的计划能够准确模拟开发过程。这几乎是不可能的，不值得一试。实际的开发包括过程修正、重构，以及我们意识到如果没有额外的修改，我们就无法编写出我们认为可以的代码。我们必须修改现有的代码来适应我们的意图，或者改变我们的意图，或者两者兼而有之。

我们不会通过更仔细地研究我们的代码和计划来克服这种不确定性。这不是问题。我们在开始工作时就认识到这种不确定性，并在问题出现时用我们的技能去解决问题。知道我们的发展很少会沿着一条可预测的道路直线前进，我们尽最大努力将这些障碍纳入我们的估计。

假设我们决定尝试一个完美的评估，并花费大量的时间预测每一个修改，并完美地可视化每一个修改的结果如何适应下一个修改，所有这些都不需要编写代码。产生评估违背了它自己的目的，因为它花费了很长的、不可预测的时间来准确地预测剩余的工作。接下来会发生什么？

*   有人生病或退出。
*   有人犯了一个错误-就一个。
*   需求变化。

实际上，我们可以排除改变需求的可能性。我们可以对调整需求进行完美的估计或预留，但不能两者都有。如果精确的估计不够不切实际和荒谬，我们还愿意锁定需求吗？当然不是。如果我们愿意锁定时间和需求，那么软件开发对我们来说可能是陌生的。除非，我们大量填充估计值，使其不太准确。

另外两个呢？我们无法计划人为因素和其他未知因素。我们只能通过增加估计数来解释它们。

不仅仅是试图产生一个完美的评估会弄巧成拙，而且即使成功了，它也会被不可预测的人为因素和锁定需求的不可接受的牺牲所击败。

我们该怎么做？这超出了本文的范围，但是这里有一些方法:

*   如果我们的时间表是固定的，我们会对需求进行优先排序，这样项目的成败就不会依赖于最后每个特性的实现。如果我们的开发过程交付了工作的、有价值的软件的增量，那么在一个固定的时间线的末尾，我们将总是有值得使用的软件。
*   在某些情况下，我们必须灵活掌握时间表。自动驾驶汽车什么时候能准备好？当他们准备好的时候。
*   如果我们没有发布“完整的”软件——也许我们正在开发一个网站——那么也许我们可以更多地关注稳定的有用功能，而不是试图预测一个预先确定的“大爆炸”何时会出现。即使是用户必须安装的软件，偶尔也会通过增量更新来添加功能。

我并不反对估算的存在。(有些人会，我的观点也不是不同意他们。)但是，如果我们必须提供它们，每个相关人员都必须了解它们准确性的限度。填充估计可能更可靠——尽管情况并不总是如此——但从定义上来说，它们不太准确。

为什么我要考虑所有这些？因为有些人不同意持续地、迭代地交付工作软件的想法，因为它不会导致在可预测的时间线上产生大的增量。不可否认，在某些情况下，预计会有大量的预定交付。但是经验表明，以增量的方式交付软件会产生更有价值的软件，而浪费的时间更少。在同样的时间内你会得到更多。我们是希望有更多的软件，在完成时交付，以满足用户不断变化的需求，还是希望有更少的为昨天的需求而构建的软件按时交付？