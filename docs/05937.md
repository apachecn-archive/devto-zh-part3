# 面向未来软件的封装和抽象

> 原文:[https://dev . to/rcosteira 79/encapsulate-and-abstract-for-future-proof-software-59 B3](https://dev.to/rcosteira79/encapsulate-and-abstract-for-future-proof-software-59b3)

变化总是会影响你的软件。无论是领域、用例、开发人员，甚至是用户。在软件开发中，变化是永恒的。

这是著名的[头部优先设计模式](http://shop.oreilly.com/product/9780596007126.do)的作者提出的第一个主题之一。他们认为这是设计模式重要性的一个原因。

“不管你设计的应用程序有多好，随着时间的推移，应用程序必须成长和变化，否则就会消亡。”
—头首设计图案，第 1 章，第 8 页

除了设计模式，作者还介绍了一系列设计原则。虽然模式超出了本文的范围，但我想重点讨论前两个原则:

*   **概括变化。**
*   编程是为了接口，而不是实现。

第一个原则是所有设计模式的基础，大多数设计模式也利用了第二个原则。第一条规定，如果你有不断变化的代码，把它拉出来并隔离。第二个原则通过使用接口对此进行了补充。

现在，给你提个醒。正如瓦西里·祖卡诺夫在[这篇评论](https://medium.com/@techyourchance/i-havent-read-head-first-design-patterns-yet-but-i-heard-that-it-s-a-worthy-book-b53f72e9b495)中解释的那样，这个“接口”并不是指某些 OOP 语言中出现的*接口*结构。嗯，可以指代，但是有更广泛的含义。这里，“接口”指的是组件的外部交互点。它是其他组件可以用来与特定组件进行交互的东西。所以，这个“接口”可以是一个*接口*，一个抽象类，一个普通类，甚至是一个函数。它可以是任何东西，只要它充当与组件的通信点。有了它，我们不需要知道组件的内部细节。它让我们**从组件的实现中抽象出**。所以，每当有变化时，你只需要重构相应的代码。外部代码甚至不会注意到它。该原则的目的确实是关注代码做什么，而不是如何做。

## [](#a-ticking-time-bomb-android-libraries)一颗定时炸弹:安卓库

Android 开源社区棒极了。不管你需要的东西有多复杂，实现它的库可能已经存在了。这不仅使我们的工作更容易，而且让我们专注于真正的业务逻辑问题。

然而，事情变了(我知道)。图书馆变得过时了。有时，新版本会引入突破性的变化。需求改变了，我们不再需要一个库。外部变化迫使我们改变我们的代码。留给我们的是一个庞大的代码库，其中充满了不赞成使用的依赖项或围绕它们构建的代码。这就是上面提到的设计原则派上用场的地方。

假设您需要以 JSON 格式在磁盘上存储/检索配置对象。您在以前的项目中有使用 Gson 的经验，所以您使用它。您将配置定义为: