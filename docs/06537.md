# 构建弹性服务

> 原文：<https://dev.to/__namc/building-resilient-services-35j2>

原始文章发表于: [namc.in - Retries、Timeouts 和 Backoff](https://namc.in/2019-04-15-retries-timeouts-backoff)

分布式系统很难。虽然我们在制造高可用性系统方面学到了很多，但我们经常忽视系统设计中的弹性。

当然，我们听说过容错，但是什么是“弹性”呢？就我个人而言，我喜欢将其定义为系统处理并最终从意外情况中恢复的能力。有几种方法可以让你的系统从失败中恢复过来，但是在这篇文章中，我们将重点关注以下方法

*   [超时](#timeouts)
*   [次重试](#retries)
*   [回退](#backoffs)
*   [分布式系统中的幂等性](#idempotency-in-distributed-systems)

## 超时

简单地说，超时是两个连续数据包之间不活动的最长时间。

我想我们曾经使用过数据库驱动和 http 客户端。所有帮助您将服务连接到外部服务器的客户端/驱动程序都有一个超时参数，该参数通常默认为零或-1。这意味着超时是未定义的，或者无限的。

eg -参见`connectTimeout`和`socketTimeout`定义 [Mysql 连接器配置](https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html)

大多数对外部服务器的请求都应该附加超时。当服务器没有及时响应时，这一点非常重要。如果没有设置这个值，默认为 0/-1，您的代码可能会挂起几分钟甚至更长时间。发生这种情况是因为当您没有收到来自应用服务器的响应时，由于您的超时是不确定的，或者是无限大的，连接池保持打开。随着越来越多的请求进入，越来越多的连接打开，这些连接永远不会关闭，从而导致连接池耗尽。这将导致您的应用程序出现级联故障。

因此，当您配置您的应用程序使用这样的连接器时，请在它们的配置中设置一个明确的超时值。

还必须在前端和后端都实现超时。也就是说，如果一个读/写操作在 rest api 或 socket 上停留的时间太长，就会引发一个异常，连接就会被中断。这应该会通知后端取消操作并关闭连接，从而防止无限期地打开连接。

## 重试次数

我们可能需要了解一点关于**瞬时故障**的知识，因为我们会经常使用这个术语。
简单地说，你的服务中的短暂故障是暂时的小故障，例如网络拥塞、数据库过载。如果有足够的冷静期，这也许是正确的。

**如何判断故障是否为暂时性的？**

答案在于 API/服务器响应的实现细节。如果你有 rest API，返回一个 [503 服务不可用](https://tools.ietf.org/html/rfc7231#section-6.6.1)而不是其他 5xx/4xx 错误消息。这将让客户端知道超时是由“临时过载”引起的——而不是因为代码级错误。

重试虽然有用，但如果配置不当，就有点臭名昭著了。以下是如何找出使用重试的正确方法。

**重试**

如果从服务器收到的错误是暂时的，例如网络数据包在传输时被破坏，应用程序可以立即重试请求，因为失败不太可能再次发生。

然而，这是非常咄咄逼人的，可能会对您的服务造成损害，您的服务可能已经满负荷运行，或者完全不可用。它还会降低应用程序的响应时间，因为您的服务会不断尝试执行失败的操作。

如果您的业务逻辑需要这种重试策略，最好限制重试次数，以防止更多的请求发送到同一个源。

**延迟后重试**

如果故障是由连接故障或网络上的过量流量引起的，应用程序应该在重试请求之前根据业务逻辑添加一个延迟期。

```
for(int attempts = 0; attempts < 5; attempts++)
{
    try
    {
        DoWork();
        break;
    }
    catch { }
    Thread.Sleep(50); // Delay
} 
```

当使用连接到外部服务的库时，请检查它是否实现了重试策略，允许您配置最大重试次数、重试之间的延迟等。

您还可以在服务器端实现重试策略，方法是在响应头中设置一个 [Retry-After](https://tools.ietf.org/html/rfc7231#section-7.1.3) 。

记录操作失败的原因也很重要。有时这是由于缺乏资源，可以通过添加更多的服务实例来处理。其他时候，这可能是由于内存泄漏或空指针异常。因此，添加日志并跟踪应用程序的性能是非常必要的。

## 退避

正如我们在上面看到的，我们可以给重试策略增加延迟。这种延迟通常被称为*线性补偿*。这种方法可能不是实现重试策略的最佳方式。

考虑这样一种情况，由于数据库过载，您的服务可能会出现故障。经过几次尝试后，我们的请求很可能会成功。也有可能后续的请求会增加数据库服务器的过载。因此，服务处于过载状态的时间要长得多，并且需要更多的时间才能从这种状态中恢复过来。

有几种策略可以用来解决这个问题。

**1。[指数退避](https://en.wikipedia.org/wiki/Exponential_backoff)T3】**

顾名思义。取代重试之间的周期延迟，比如说 5 秒，以指数方式增加请求之间的延迟。我们这样做，直到达到最大重试限制。如果请求继续失败，让客户端知道请求已经失败。

您还必须设置延迟的上限。指数回退可能会导致设置非常大的延迟，从而使请求套接字无限期打开，并使线程“永远”休眠。这将耗尽系统资源，从而导致连接池出现更多问题。

```
int delay = 50
for(int attempts = 0; attempts < 5; attempts++)
{
    try
    {
        DoWork();
        break;
    }
    catch { }

    Thread.sleep(delay);
    if (delay < MAX_DELAY)      // MAX_DELAY could depend upon application and business logic 
    {
        delay *= 2;
    }
} 
```

在分布式系统中可以看到指数回退的一个主要缺点，其中**同时请求回退，也同时重试**。这导致了呼叫的聚集。因此，我们现在引入了没有客户竞争的时间段，而不是减少每轮竞争的客户数量。固定的指数级回退不会减少太多的争用，并且会产生负载峰值。

**2。[回退带抖动](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)T3】**

为了处理指数补偿中提到的尖峰负载，我们将*抖动*添加到我们的补偿策略中。抖动是一种去相关策略，它增加了重试间隔的随机性，并分散了负载。这避免了网络呼叫的群集。

抖动通常不是任何配置属性的一部分，需要由客户端实现。它唯一需要的是一个函数，可以增加随机性，并动态计算重试前等待的时间。

通过引入抖动，失败请求的初始组可以聚集在非常小的窗口中，比如 100ms，但是随着每个重试周期，请求的集群扩展到越来越大的时间窗口中，从而减小给定时间的尖峰大小。当请求分布在一个足够大的窗口中时，该服务可能能够处理这些请求。

```
int delay = 50
for(int attempts = 0; attempts < 5; attempts++)
{
    try
    {
        DoWork();
        break;
    }
    catch { }

    Thread.sleep(delay);
    delay *= random.randrange(0, min(MAX_DELAY, delay * 2 ** i)) // just a simple random number generation
} 
```

在**长期瞬时故障**的情况下，任何类型的重试可能都不是最好的方法。这可能是由于连接故障、断电(是的，它们确实存在)等原因造成的。客户端最终会重试几次，浪费系统资源，进一步导致跨多个系统的级联故障。

因此，我们需要一种机制来确定故障是否是长期的，并实现一个解决方案来处理它。

**3。[断路器](https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern)**

断路器模式通过确定服务的可用性，防止客户端重试必然会失败的请求，从而有助于处理服务的长期瞬时故障。

断路器设计模式要求在一系列请求中保持连接状态。让我们看看这个由故障保护
实现的[断路器](https://github.com/jhalterman/failsafe#circuit-breakers)

```
CircuitBreaker breaker = new CircuitBreaker()
  .withFailureThreshold(5)
  .withSuccessThreshold(3)
  .withDelay(1, TimeUnit.MINUTES);

Failsafe.with(breaker).run(() -> connect()); 
```

当一切按预期运行时，没有输出，断路器保持闭合状态。

当执行失败达到阈值时，断路器跳闸并进入**打开**状态，这意味着所有后续请求将继续失败，而不经过重试逻辑。

经过一段延迟(如上所述 1 分钟)后，电路将进入**半开**状态，只是为了测试网络呼叫的问题是否仍然存在，从而决定电路应该闭合还是断开。如果成功，电路复位到**闭合**状态，否则再次设置为**打开**。

这有助于避免在长期故障期间执行大量重试，从而节省系统资源。

虽然这可以在状态变量中本地维护，但是如果您有一个**分布式系统**，您可能需要一个外部存储层。在多节点设置中，应用服务器的状态需要在所有实例间共享。在这种情况下，您可以使用 Redis、memcached 来记录外部服务的可用性。在向外部服务发出任何请求之前，从永久存储器中查询服务的状态。

## 分布式系统中的幂等性

当客户端可以重复发出相同的请求，同时产生相同的最终结果时，服务就是等幂的。虽然该操作会在服务器上产生相同的结果，但它可能不会给客户端相同的响应。

对于 REST APIs，您需要记住-

*   **POST** 不是等幂的- POST 导致在服务器上创建新资源。“n”个 POST 请求导致在服务器上创建“n”个新资源。
*   **GET** ， **HEAD** ， **OPTIONS** 和 **TRACE** 方法从不改变服务器上的资源状态。因此，它们总是幂等的。
*   **PUT** 请求是幂等的。“n”个 put 请求将覆盖相同的资源“n-1”次。
*   **DELETE** 是幂等的，因为它最初会返回 200 (OK ),在后续调用中会返回 204(无内容)或 404(未找到)。

**为什么要关心幂等运算？**

在分布式系统中，有几个服务器和客户端节点。如果您从客户端向服务器 A 发出请求，但请求失败或超时，那么您希望能够简单地再次发出请求，而不用担心之前的请求是否有任何副作用。

这在许多组件独立运行的微服务中极其重要。

幂等性的一些主要好处是-

*   **最小的复杂性** -不需要担心副作用，任何请求都可以简单地重试，并且达到相同的最终结果。
*   **更容易实现**——你不需要在你的重试机制中添加逻辑来处理先前失败的请求。
*   **更容易测试** -每个动作的结果都一样，没有意外。

## 期末笔记

我们经历了一堆方法，你可以建立一个更容错的系统。然而，这还不是全部。最后，我想补充几个要点供您参考，这可能有助于提高您的系统的可用性和容错能力。

*   在多节点设置中，如果客户端重试多次，请求很可能会到达同一个服务器。当这种情况发生时，最好给出一个失败响应，并让客户端从头开始重试。
*   剖析您的系统，让它们做好最坏的打算。你可能想看看 Netlifx 的混沌猴子——它是一个弹性工具，可以触发你系统中的随机故障。这让你为可能发生的错误做好准备，帮助你建立一个有弹性的系统。
*   如果您的系统由于某种原因负载过大，您可以尝试通过减载来分配负载。谷歌做了一个出色的[案例研究](https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons)，可以作为一个很好的起点。

* * *

资源-

*   [分布式系统的模式](https://www.dre.vanderbilt.edu/~schmidt/patterns-ace.html)
*   [重试模式-微软](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)
*   [马丁·福勒断路器](https://martinfowler.com/bliki/CircuitBreaker.html)

谢谢大家！❤