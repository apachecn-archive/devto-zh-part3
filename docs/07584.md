# 温泉:拥有你的宝藏，并吃掉它

> 原文:[https://dev . to/James Thomson/spas-have-your-cache-and-eat-it-too-iel](https://dev.to/jamesthomson/spas-have-your-cache-and-eat-it-too-iel)

因此，您已经开发了一个非常棒的单页面应用程序，现在您可以开始运行它了。太棒了，干得好！但是等一下，伙计，在你扣动扳机发你的双关语 URL 之前，花点时间确保你的缓存策略到位。否则，下次你推送更新时，你可能会发现自己处于一个受伤的世界。

我是从个人经历来说的，以下是我所学到的...

在我开始之前，让我先说:我不打算深入了解如何设置一切的细节。每个开发环境都是不同的，需要不同的步骤。我想说的是，在你上线之前正确设置的重要性，因为如果你不这样做，你就很难把你的用户从陈旧的缓存地狱中挖出来。

TL；速度三角形定位法(dead reckoning)

*   永远不要缓存你的索引。用`expires 0`将标题设置为`no-store`。
*   使用捆绑器(如 [Webpack](https://webpack.js.org/guides/caching/) )实现哈希版本化文件名。
*   在你的 JS、CSS 和任何其他经常改变的文件上使用`no-cache`和`max-age`头。

# [](#never-cache-the-index)从不缓存索引

用`expires 0`将你的索引头设置为`no-store`。这可以确保你的用户每次启动应用程序时都能获得一个新的索引。这是非常重要的，因为你的索引引用了你所有的其他文件(js，css 等)。)并且我们希望确保提供正确的散列文件。

# [](#use-hashed-fingerprinted-filenames)使用散列(指纹)文件名

如果操作正确，这一步应该可以消除几乎所有的缓存问题。策略是当你在你的文件中改变一些东西时，bundler 也将通过用一个散列(例如 app.jgm315la0.js)重命名它来指纹化文件名。因为文件名是不同的，因为索引从不被缓存(还记得我在上一段说过的吗？)将使用最新的文件。

# [](#set-your-headers)设置您的标题

最后，但肯定不是最不重要的，如果你的文件设置你的头。使用 [`Cache-Control`响应头](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)可以定义用户浏览器如何处理缓存。这一步很重要，因为如果标题设置不正确，用户可能会得到过时的文件...永远！或者至少在他们清空缓存之前，没有多少用户知道这样做。通过设置正确的标题，您可以确保您的用户浏览器按照您的指示运行。

现在，这里没有硬性规定。每个 SPA 都是不同的，因此如何处理您的`Cache-Control`标题取决于您自己。这可能是多余的，特别是对于散列文件，因为当文件名改变时，它们应该被缓存，但是开始时，我建议在所有文件上设置`no-cache`和`max-age`(除了索引)。我这样说是因为您可以设置它们，然后在确认哈希文件按预期工作时更改/删除它们，但是如果它没有按预期工作，浏览器会死死抓住缓存版本不放，您就不能反其道而行之。

与它的名字相反，`no-cache`(听起来好像它不应该缓存)，指示浏览器总是询问服务器文件是否已经更改。如果没有，它将使用浏览器缓存的版本。这产生了发送请求的不幸效果，尽管请求非常非常小，但是确保了浏览器总是检查它是否应该使用缓存版本，而不是仅仅假设它应该总是使用缓存版本。

`max-age`给文件一个“到期”日期。当文件第一次下载时，它被赋予这个最长期限。一旦过期，该文件就被认为是过时的，将被再次下载。

当你对如何处理特定文件类型的头有疑问时，请参考[谷歌的`Cache-Control`策略决策树](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#defining_optimal_cache-control_policy)。

# [](#conclusion)结论

所以你有它。这绝不是一个权威的指南，关于缓存还有很多需要学习的地方，但是希望它可以帮助您避免我刚刚经历的痛苦的生产体验。最重要的是，如果你遵循这些最初的步骤，你应该能够很容易地调整你的标题，你的用户不会知道任何更好的，但如果你不这样做，他们会知道得太多。

编码快乐！