# EnqueueZero Techshack 2019-04

> 原文:[https://dev.to/soasme/enqueuezero-techshack-2019-04-2ah6](https://dev.to/soasme/enqueuezero-techshack-2019-04-2ah6)

# enqueue zero Techshack 2019-04

## 金丝雀分析:从谷歌和 Waze 吸取的教训和最佳实践

[cloud.google.com](https://cloud.google.com/blog/products/devops-sre/canary-analysis-lessons-learned-and-best-practices-from-google-and-waze)

投资 canary 部署将极大地增强您对部署过程的信心，减少影响用户的问题数量，提高您的速度，并有望降低您的压力水平！以下是需要注意的事项:

*   管道:配置->设置最新版本->烘焙 GCP(分配云资源)->金丝雀分析->人工判断->发送生产更新->部署红黑棋
*   金丝雀部署的先决条件:
    *   为金丝雀分析提供数据的外部监控系统。
    *   构建 SLO 来衡量服务的健康状况。
*   金丝雀最佳实践:
    *   将金丝雀与基线进行比较，而不是与产量进行比较
    *   运行金丝雀足够长的时间
    *   仔细选择要分析的指标
    *   创建一组可重复使用的标准金丝雀配置

## [](#the-night-of-a-cascading-failure)一个连锁故障的夜晚

[rachelbythebay.com](https://rachelbythebay.com/w/2019/01/20/quiet/)

真是悲剧！有人被一个 bug 绊倒了，提交的代码会产生一个为`size_t`类型计算的负数。不幸的是，当真实案例发生时，整个系统都瘫痪了，包括堡垒主机。说真的，几乎没有人可以登录数据中心并解决这个问题。

吸取的教训:

*   与其拆分字符串，不如使用正则表达式来匹配您真正需要的内容。
*   即使依赖项不可用，也要让服务活着，而不是让整个世界都死去。
*   想想失败注射的可能性。
*   善待你的同事。他们没有写 bug。他们只是绊了一下。

## [](#scaling-engineering-teams-via-writing-things-down-and-sharing-aka-rfcs)通过写下和分享来扩展工程团队——又名 RFC

[blog.pragmaticengineer](https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/)

如果您碰巧遇到以下问题，请查看该方法:

*   缺乏对其他人构建或已经构建了与我的团队相同的东西的可见性。
*   由于不同的团队构建非常不同的东西，无论是方法还是质量，技术和架构债务都在累积。

解决方法是采取以下步骤:

*   在建造新的东西之前做好计划。
*   将这个计划记录在一个简短的书面文件中。
*   在开始工作之前，有几个经过挑选的人批准了这个计划。
*   将这份规划文件发给公司的所有工程师。
*   让每个人都遵循上述步骤。

该方法鼓励在整个组织中评审和传播知识。此外，如果每个人都同意项目应该如何完成，那么写下方法应该是小菜一碟。

下面是两种不同类型的应用程序的潜在模板。

*   后端
    *   批准人列表
    *   摘要(项目是关于什么的？)
    *   架构变化
    *   服务 SLA
    *   服务依赖关系
    *   负载和性能测试
    *   多数据中心问题
    *   安全考虑
    *   测试和展示
    *   指标和监控
    *   客户支持注意事项
*   手机/网络
    *   批准人列表
    *   摘要(项目是关于什么的？)
    *   用户界面和 UX
    *   架构变化
    *   详细的网络交互
    *   库依赖性
    *   安全问题
    *   测试和展示
    *   分析学
    *   客户支持注意事项
    *   易接近

## [](#http3-explained)HTTP/3 解释道

[http3-explained.haxx.se](https://http3-explained.haxx.se/en/)

*   为什么是 QUIC？无等待、减少等待时间、始终安全、对抗僵化、无三次握手。
*   好极了！= IETF-QUIC。
*   HTTP/3 = HTTP-over-QUIC。
*   特点:
    *   QUIC 在 UDP 之上。
    *   QUIC 在 UDP 上增加了一层以引入可靠性，包括数据包的重新传输、拥塞控制、速度调整和 TCP 中存在的其他功能。
    *   QUIC 的特点是在物理连接中有独立的逻辑流。
    *   QUIC 连接是针对 UDP 端口和 IP 地址建立的，但是一旦建立，该连接就与其“连接 ID”相关联。
    *   QUIC 保证流的有序传递，但不保证流之间的有序传递。
    *   QUIC 提供 0-RTT 和 1-RTT 连接设置。

## [](#functional-programming-fundamentals)功能编程基础知识

[www.matthewgerstman.com](https://www.matthewgerstman.com/functional-programming-fundamentals/)

函数式编程(通常缩写为 FP)是通过组合纯函数来构建软件的过程。纯函数是给定相同的输入，总是返回相同的输出，并且没有副作用的函数。

你不应该改变输入。否则，结果是可以预料的。

编写声明性代码，而不是命令性代码。比如`lodash.keyBy(files, 'id');`比一个`for-loop`好。

如果你试图同时执行效果和逻辑，你可能会产生隐藏的副作用，导致逻辑上的错误。保持小功能。一次做一件事，并且做好。

计划作文。编写一些函数，其输出自然会作为许多其他函数的输入。保持函数签名尽可能简单。

不变性。真正不变的是变化。突变隐藏了变化。隐藏的变化表明混乱。因此，智者拥抱历史。

记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。

使用高阶函数:

*   接受函数的函数
*   返回函数的函数
*   接受函数并返回函数的函数
*   携带
*   部分应用

## UI 工程的要素

[反应过度](https://overreacted.io/the-elements-of-ui-engineering/)

作者为 UI 工程列出了几个有趣的问题。

*   一致性。我们如何在屏幕的不同部分保持相同的数据同步？我们如何以及何时使本地数据与服务器一致，反之亦然？
*   反应灵敏。人们只能在有限的时间内忍受缺乏对他们行为的视觉反馈。我们如何让我们的应用程序响应不同类型的输入？
*   潜伏。计算和网络访问都需要时间。我们如何优雅地处理延迟，而不显示“级联”的旋转器或空“洞”？我们如何避免“跳动”的布局？我们如何改变异步依赖关系而不用每次都“重新布线”我们的代码？
*   导航。我们希望用户界面在与它交互时保持“稳定”。我们如何设计我们的应用程序来处理任意导航而不丢失重要的上下文？
*   陈腐。我们如何正确处理缓存数据？
*   熵。我们如何驯服可能状态的组合爆炸，并使视觉输出可预测？
*   优先。我们如何让独立的小部件合作，而不是争夺资源？
*   可达性。我们能做些什么来使可访问性成为默认而不是事后的想法呢？
*   国际化。我们如何在不牺牲延迟和响应的情况下支持不同的语言？
*   送货。我们如何选择在哪个点引入延迟？我们如何基于使用模式优化我们的交付？最佳解决方案需要什么样的数据？
*   韧性。我们如何编写代码来隔离渲染和获取失败，并保持应用程序的其余部分运行？容错对于用户界面意味着什么？
*   抽象。我们如何创建隐藏特定 UI 部分实现细节的抽象？随着应用程序的增长，我们如何避免重复出现我们刚刚解决的问题？

从你喜欢使用的应用程序中想出一个不平凡的 UI 元素，并仔细检查这个问题列表。你能描述一下它的开发者选择的一些权衡吗？尝试从头开始重新创建一个类似的行为！

## [](#looking-back-at-postgres)回望 Postgres

[arxiv.org](https://arxiv.org/pdf/1901.01973.pdf)

这是对加州大学伯克利分校 Postgres 项目的回忆。这是一篇有趣的论文，介绍了 Postgres 的历史。

吸取的教训:

*   为可扩展性设计你的软件。有时候，一个成功的第一个系统无法跟进第二个系统，但这并没有发生在 Postgres 上。有了可扩展性作为架构核心，就有可能变得更有创造力，不再那么担心纪律:你可以尝试许多扩展，让强者成功。
*   一个尺寸适合许多人。

## [](#paper-review-serverless-computing-one-step-forward-two-steps-back)论文综述。无服务器计算:前进一步，后退两步

[muratbuffalo.blogspot.com](http://muratbuffalo.blogspot.com/2019/01/paper-review-serverless-computing-one.html)

当前 FaaS 产品的缺点:

*   有限的寿命。15 分钟后，函数调用被关闭。
*   I/O 瓶颈。Lambdas 通过网络接口连接到云服务，特别是共享存储。带宽相当小。
*   通过慢速存储进行交流。
*   没有专门的硬件。

当前的 FaaS 产品在效率和易于编程的按调用付费的自动伸缩功能之间进行权衡。
FaaS 致力于优化开发人员的工作效率和上市时间。
好的策略是在 Lambda 上做原型，然后“做对”。

## Noria:面向高性能 web 应用的动态、部分状态数据流

[usenix.org](https://www.usenix.org/conference/osdi18/presentation/gjengset)

Noria 是一个部分有状态的数据流模型。该模型使数据流对于构建长寿命、低延迟的应用程序(如 web 应用程序)变得可行。
它提供了比典型的 MySQL/memcached 堆栈更好的性能。
它提供了一个关系模式，一组参数化的查询，以及跨相关查询的共享状态。

## [](#keeping-calm-when-distributed-consistency-is-easy)保持冷静:当分布式一致性很容易

[arxiv.org](https://arxiv.org/abs/1901.01930)

现代分布式系统中的一个关键问题是避免协调的成本，同时保持一致的语义。平静是“作为逻辑单调性的一致性”的首字母缩写。

分布式系统理论被可怕的负面结果所主导，例如费希尔/林奇/帕特森不可能性证明、CAP 定理和两个将军问题。

CALM 表明，程序的一个属性——单调性意味着一致性，这是该程序的任何执行的输出的一个属性。虽然蛤蜊只是一个建设性的结果。系统构建者仍然需要回答两个问题:

*   他们试图解决的问题是否有一个单调的规范。
*   给定一个问题的单调规格说明，我如何在实践中实现它？

## 2019 年你还会挑仙丹吗？

[github.com](https://github.com/dwyl/learn-elixir/issues/102)|[news.ycombinator.com](https://news.ycombinator.com/item?id=18838115)

优点:简单易学，设计精美的语言，宏，内置测试，BEAM VM，错误处理，引入 aws lambda 支持等。缺点:市场上的人力资源很少。

## [](#resiliency-rate-limiting-retries-bulkheads)弹性:速率限制、重试、障碍

[medium.com](https://medium.com/dm03514-tech-blog/sre-resiliency-bolt-on-sidecar-rate-limiting-with-envoy-sidecar-5381bd4a1137)(限速)|[medium.com 重试](https://medium.com/dm03514-tech-blog/sre-resiliency-retries-in-action-using-js-8e4b7e7d4526)(重试)|[medium.com](https://medium.com/dm03514-tech-blog/sre-resiliency-bulkheads-in-action-using-js-453c02a940c0)(舱壁)

速率限制可以减轻贪婪客户端的 API 资源消耗。

重试是一种强大的弹性原语，它允许客户端提供比其依赖性更高的可用性。应该小心使用重试，因为未完善的重试策略可能会导致类似拒绝服务的攻击。

隔板是限制资源使用的有效方法。它们确保隔离，并通过防止过载来帮助减轻级联故障。隔板不是银弹，而是创建弹性高可用性应用程序的许多原始模式之一。

## [](#what-are-the-best-software-engineering-principles)最好的软件工程原理有哪些？

[开发到](https://dev.to/luminousmen/what-are-the-best-software-engineering-principles--3p8n)

*   测量两次，切割一次
*   不要重复你自己
*   奥卡姆剃刀
*   保持简单愚蠢
*   你不需要它
*   预先的大设计
*   避免过早优化
*   最小惊讶原则
*   神盾局。
*   德米特里定律

## PostgreSQL 的内部，面向数据库管理员和系统开发人员

[www.interdb.jp](http://www.interdb.jp/pg/index.html)

在本文档中，为数据库管理员和系统开发人员描述了 PostgreSQL 的内部结构。

## [](#mysql-high-availability-framework-explained-part-ii)MySQL 高可用性框架讲解–第二部分

[highscalability.com](http://highscalability.com/blog/2019/1/8/mysql-high-availability-framework-explained-part-ii.html)

这篇文章讨论了 MySQL 半同步复制的细节和相关的配置设置，帮助我们确保 HA 设置中数据的冗余和一致性。

半同步复制:主节点只有在收到至少一个从节点的确认后，才会将事务提交给存储引擎。

## 学习足够有用的 Docker 第一部分

[towardsdatascience.com](https://towardsdatascience.com/learn-enough-docker-to-be-useful-b7ba70caeb4b)

Docker 容器可以容纳东西，是便携式的，有清晰的访问接口，并且可以从远程位置获得。

## [](#operable-software)可操作的软件

[ferd.ca](https://ferd.ca/operable-software.html)

这篇文章涵盖了对简单性和复杂性的看法，人们实际上如何接近他们的系统并形成他们的心理模型，以及如果我们想让系统既可观察又可操作，我们应该如何构建事物。

*   一个简单的系统可以工作(但不能保证这样做)
*   一个复杂的系统可以工作，通常是从一个小系统发展而来的。第一次尝试发布一个复杂的系统通常不会很顺利
*   随着系统的扩展，复杂性是不可避免的；如果人们依赖一个系统来做严肃的事情，它将不可避免地变得复杂
*   一个简单的系统与一个大型系统的行为是不同的，即使两者提供相同的功能

要使一个软件具有可操作性，添加更多的组件是不可避免的。更重要的是，不要忘记解释这些组件信息的人。

> 因为当工具和自动化失败时，系统中的人总是解决问题的最后希望，我们应该投入更多的努力来支持他们，提供良好的操作体验。