# 用 C#编写本地库并在其他语言中使用它们

> 原文:[https://dev.to/mhmd_azeez/writing-native-libraries-in-c-3kl](https://dev.to/mhmd_azeez/writing-native-libraries-in-c-3kl)

> 注:Stefan Hausotte 已经把[这个小实验移植到 F#](https://secanablog.wordpress.com/2020/02/01/writing-a-native-library-in-f-which-can-be-called-from-c/) 上了。

最近我偶然发现了来自[的](https://twitter.com/MStrehovsky)这篇文章。这是对 CoreRT 的一个很好的介绍，它让我很好奇，你能用 CoreRT 编写本地库吗？答案是肯定的！

> ![Michal Strehovský profile image](../Images/a6112e6d426741a717a7d31dcd673fe4.png)米哈尔·斯特列霍夫斯基@ mstrehovsky![twitter logo](../Images/65e26e35707d96169ec8af6b3cbf2003.png)[@ mhmd _ aze ez](https://twitter.com/mhmd_azeez)[@ xoofx](https://twitter.com/xoofx)CoreRT 可以生成。dll/。所以/。迪利布和。lib/。一种导出 C#函数的文件，这种方式使得它们可以通过标准的 FFI 直接调用。一个样本预排在这里:[github.com/dotnet/corert/…](https://t.co/7N0ll44jMA)2019 年 05 月 02 日上午 07:58[![Twitter reply action](../Images/e5d6036ea29f7fc2ceecadd7806ec22d.png)](https://twitter.com/intent/tweet?in_reply_to=1123859217654460424)[![Twitter retweet action](../Images/045a8cb35300a0b869b6787434707687.png)](https://twitter.com/intent/retweet?tweet_id=1123859217654460424)0[![Twitter like action](../Images/1bf915c7b46baf6310d9eb9b48e72a89.png)](https://twitter.com/intent/like?tweet_id=1123859217654460424)3

我有一个小的库，我希望它能支持多种语言，所以我对它很感兴趣。所以我试用了[官方样品](https://github.com/dotnet/corert/tree/master/samples/NativeLibrary)，对结果很满意。

我用`dotnet publish /p:NativeLib=Shared -r win-x64 -c Release`编译了这个库，它产生了一个 4.52 MB 的 dll。在 Michal 的帮助下，按照本文中[的步骤，我能够将大小降低到 1.67 MB，对我来说已经足够好了。](https://github.com/dotnet/corert/blob/master/Documentation/using-corert/optimizing-corert.md)

官方示例中的[有一个类](https://github.com/dotnet/corert/blob/master/samples/NativeLibrary/Class1.cs)，它包含两个方法:`Add`和`WriteLine`，这两个方法演示了如何将原语和字符串作为参数。默认情况下，CoreRT 只允许原语作为参数类型，你必须封送任何更复杂的东西。然而，`System.Runtime.InteropServices.Marshal`确实有些有用的方法。

```
public class Class1
{
    [NativeCallable(EntryPoint = "add", CallingConvention = CallingConvention.StdCall)]
    public static int Add(int a, int b)
    {
        return a + b;
    }

    [NativeCallable(EntryPoint = "write_line", CallingConvention = CallingConvention.StdCall)]
    public static int WriteLine(IntPtr pString)
    {
        // The marshalling code is typically auto-generated by a custom tool in larger projects.
        try
        {
            // NativeCallable methods only accept primitive arguments. The primitive arguments
            // have to be marshalled manually if necessary.
            string str = Marshal.PtrToStringAnsi(pString);

            Console.WriteLine(str);
        }
        catch
        {
            // Exceptions escaping out of NativeCallable methods are treated as unhandled exceptions.
            // The errors have to be marshalled manually if necessary.
            return -1;
        }
        return 0;
    }
} 
```

用`NativeCallable`修饰的方法不能通过普通的 C#方法调用，但是可以通过 P/Invoke 调用😈。

为此，您必须:

1.  通过在其文件夹中运行`dotnet publish /p:NativeLib=Shared -r win-x64 -c Release`来构建本地库。
2.  创建一个新的控制台 app(我创建了一个 dotnet 核心控制台 app，不过没关系)。
3.  右键点击项目，点击`Add => Exisiting Item`。
4.  浏览到本地库项目的`bin\Release\netcoreapp2.2\win-x64\native`文件夹，然后选择 dll 并点击`Add As Link`。
5.  在解决方案资源管理器中右击 dll，然后单击属性。
6.  将`Copy to Output Directory`改为`Copy if newer`。
7.  将解决方案平台更改为`x64` ![Solutions Platform](../Images/9967af9c9a4523f2eda4e03d94259dab.png)
8.  然后将`Program.cs`中的代码修改如下:

```
class Program
{
    [DllImport("NativeLibrary.dll", EntryPoint = "add", CallingConvention = CallingConvention.StdCall)]
    public static extern int Add(int a, int b);

    [DllImport("NativeLibrary.dll", EntryPoint = "write_line", CallingConvention = CallingConvention.StdCall)]
    public static extern void WriteLine(string text);

    static void Main(string[] args)
    {
        var result = Add(1, 2);
        WriteLine(result.ToString());
        WriteLine("Hello World!");
    }
} 
```

现在运行控制台应用程序，您将得到如下输出:

```
3
Hello World! 
```

[![But Why?](../Images/9b141613943bd410baa7487f7357fcbe.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--57Z1LlF2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/84kbvfvss1xwiy7vnvbx.gif)

现在 p/调用这个库可能不是很有用，但是将一个类库编译为本机库为其他语言调用这个库打开了大门。

这是一个漫长而痛苦的过程，但我最终能够从 C++应用程序中引用这个库。这个[视频](https://youtu.be/or1dAmUO8k0)和这个[文章](https://docs.microsoft.com/en-us/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=vs-2019)超级有用。

下面是步骤:
1。向解决方案中添加一个空的 C++项目。

2 .添加一个源文件并粘贴到以下代码片段:

```
#include <iostream>
#include <NativeLibrary.h> using namespace std;

void main()
{
    int result = add(1, 2);
    cout << result << endl;
    write_line("Hello World!");
} 
```

3 .创建一个名为`NativeLibrary.h`(这是库的名称)的新头文件，并粘贴以下代码片段:

```
#pragma once extern "C" int __stdcall add(int a, int b);
extern "C" void __stdcall write_line(const char* pString); 
```

如你所见，我写了从`NativeLibrary`导出的函数的签名。

4 .右键单击 C++项目，然后单击 Properties。

5 .从`Configuration:`中选择`All Configurations`。这将确保更改适用于`Release`和`Debug`配置(以及您可能拥有的任何其他配置)。

6 .转到 General，将`Output Directory`改为`$(ProjectDir)bin\$(Platform)\$(Configuration)\`。这是不必要的，但我觉得这样更自在。

7 .转到`C\C++` > `Linker` > `General`，将`$(SolutionDir)NativeLibrary\bin\Release\netcoreapp2.2\win-x64\native`添加到`Additional Library Directories`。这允许链接器发现`NativeLibrary.lib`。

8 .进入`C\C++` > `Linker` > `Input`，将`NativeLibrary.lib`添加到`Additional Dependencies`列表中。

9 .转到`Build Events` > `Post-Build Event`，将这段代码粘贴到`Command Line` :

```
xcopy /y /d "$(SolutionDir)NativeLibrary\bin\Release\netcoreapp2.2\win-x64\native\NativeLibrary.dll" "$(OutDir)" 
```

每当您构建 C++项目时，这会将`NativeLibrary.dll`复制到输出目录中。

10 .构建并运行应用程序，您应该会看到以下输出:

```
3
Hello World! 
```

如果这不酷，我不知道什么是酷。

源代码[可在 GitHub](https://github.com/encrypt0r/CoreRTDemo) 上获得。