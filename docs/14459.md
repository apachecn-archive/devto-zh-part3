# 持续重构:避免此时此地的技术债务

> 原文:[https://dev . to/kendalmintcode/continuous-refactoring-avoiding-technical-debt in the here-and-now-1d 74](https://dev.to/kendalmintcode/continuous-refactoring-avoiding-technical-debt-in-the-here-and-now-1d74)

[![Rubber gloved hands scrubbing a toilet](../Images/6d573af51113f13bff69bdbf345dbd0d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--kLu1UJcf--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://robkendal.co.uk/static/1278951129570d3fbb5a8125f551df84/2b40c/rawpixel-783429-unsplash_o-1.jpg)

刚刚读了罗宾·伦德尔写的一篇关于 CSS 技巧的有趣文章，名为“[缓慢而稳定的重构](https://css-tricks.com/the-slow-and-steady-refactor/)”，我不得不分享我自己在改进代码方面的经验。

庞大、笨重的技术债务和臃肿、迟缓、性能差的代码一直是任何开发行业的问题。无论是从未整理过的代码，还是堆积在旧代码之上的新代码，甚至是过去的开发人员留下的被误解的黑暗艺术风格的代码，遗留技术债务都会导致各种各样的问题。

我将分享我最近用一个我称之为*持续重构*的概念来解决编码柜中这个怪物的方法。

然而，首先让我们看看我们是如何结束重构噩梦的...

*(嘶...如果你愿意，可以跳到持续重构部分)*

## [](#how-did-we-get-like-this)我们怎么会变成这样？

从某些方面来说，这篇文章的特征图像(正在擦洗的抽水马桶)很好地表现了大型开发项目通常会变得杂乱的电线:它们很脏，很难清理，通常是一个没有人愿意承担的吃力不讨好的任务(嗯，可能是一些更残忍的程序员)。

代码库越大，遇到的问题就越多:

*   它们变得更加难以维护
*   由于意大利面条式的代码或未知的依赖性，优化和改进是一个挑战
*   很难在不影响小部件“y”的情况下更改功能“x”
*   代码库有自己的一套错误，不用担心通过重构大部分代码会引入更多的错误

具体来说，项目如何在这种状态下结束，这不是任何人的错，但我们都有责任培养一种“快速完成任务，现在完成任务”的文化，而牺牲了“如何在未来轻松完成任务(T2)、顺利完成任务(T4)。

### [](#productivity-trumps-maintainability)生产力胜过可维护性

原因之一是我们越来越关注在更短的时间内建造更大、更好的东西。在我的职业生涯中，我看到开发团队受到越来越多的强调和压力，要“发布产品 x”，要“击败竞争对手”，像敏捷这样的实践融入到这种心态中，使“总是发布/发布”的心态成为可能。

当然，我并不是说这本身就有什么不好的地方，像敏捷、持续构建和部署等方法使我们能够在更短的时间内构建更好的东西，这**只会是一件好事**！

但是(总有但是...)为了让事情部署得更快，我们很容易找不到时间来重构我们的工作，重新审视和改进，消除粗糙——否则很容易将它推迟到未来某个神秘的时间，因此它成为后台的一个高耸的野兽。

### [](#shiny-and-new-trumps-wellplanned-and-robust)闪亮崭新胜过精心策划和稳健

当然，技术以令人恐惧的速度发展，但我们不应该让自己如此痴迷于“使用最新的东西”或“建设新脸书”，以至于牺牲了维护良好且易于扩展的软件。

很多时候，我们很容易被其他人使用的东西所诱惑，而没有真正理解*为什么、*一起编写东西，同时还在学习我们用来编写代码的工具或库。

同样，保持最新并没有错，但是不加思考地一头扎进去会导致更新的东西——希望在我们掌握我们正在使用的东西时充满最佳实践和学到的知识——被倾倒到旧的东西上，导致(可能)永远不会被解决的代码沼泽。

### 为别人在做什么而争吵

目前，在开发领域，Twitter 上有很多关于 CSS-in-JS 或我们都是如何做错 HTML 的争论。具有讽刺意味的是，很少有哪一方是对或错的，他们只是喜欢不同的方法。

例如， [CSS-in-JS](https://robkendal.co.uk/everthing-wrong-with-css-in-js/) 并没有什么可怕的不好(尽管我讨厌这个想法...*战栗*)，但是这些争论倾向于在人们如何处理一个共同的目标(在这种情况下，包括 CSS 到他们的最终输出)上产生分歧。

结果可能是团队混合匹配编码约定，这使得重构变得困难。它还会减缓新团队成员的入职速度，因为他们很难掌握以不同方式开发的同一应用程序的不同领域。

此外，陷入关于 CSS-in-JS 的争论，或者为什么 framework 'ThingyJS '比库' McGuffin.io '更好，而不是' T0 '更适合我们生产健壮、结构良好、可维护、我们可以快速改进、扩展和发布的代码，意味着你问了错误的问题。

## [](#enter-continuous-refactoring)进入持续重构

那么，我们如何解决和减少膨胀和技术债务的负担，并腾出时间来重构呢？简单，*持续重构*。

它真的可以像听起来一样简单:

> 通过稍微放慢我们的步伐，在我们编写代码时及时地重构我们的代码*，我们帮助我们未来的自己(和未来的团队)从一个更精简的代码基础中受益。*

当然，如果你想深入了解，还有更多的内容。以下是我这些年来经历的一些最好的方法，以及我现在试图培养的习惯，以确保代码尽可能的顶尖:

*   通过规划减少对大型反应堆的需求
*   小范围承诺，经常承诺
*   边走边重构
*   向你的团队寻求帮助
*   让重构约定就位
*   不要使用第三方，因为“这很简单”
*   文档文档文档

### [](#reduce-the-need-for-massive-refactors-with-planning)通过规划减少对大规模重构的需求

它在你接触 IDE 之前开始...

正如 [Robin 在他的文章](https://css-tricks.com/the-slow-and-steady-refactor/)中提到的，通过放慢速度并计划*我们如何*在开始之前创建一个代码库，就如何解决和减少代码混乱制定标准、惯例和指导方针，并简化事情*现在，*我们可以避开一些令人头疼的问题。

好吧，这不是真正的重构，但是通过在开始之前制定一个计划(如果你愿意的话，一个先发制人的重构)，可以减少重构的需要。

### [](#commit-small-commit-often)小犯，常犯

再次，对 Robin 的文章大加赞赏，他对 Git 版本的使用包括对存储库进行更频繁、更小的提交。这是一个很好的方法，原因包括:

*   记录您的决策过程
*   使回滚较小的更改变得容易，而不是提交大量文件

### [](#refactor-as-you-go)边走边重构

通常有一种方法，不管多小，可以改进你写的东西。你可以将一个函数从 15 行减少到 10 行(同时保持可读性),或者将一个长函数分成几个小函数。

无论你如何选择重构、返工或改进你的代码，你都应该在你写代码的时候或者至少在你提交代码之前*去做。通常，开发团队会完全推迟重构，希望他们能有一些时间来完成待办事项列表，或者减少他们多年来一直想做的讨厌的账户控制器。*

事实上，这一时刻永远不会到来。重构通常不会给产品增加价值，所以它通常被推到优先级列表的底部。因此，作为一名勤奋的开发人员，现在就应该在问题出现之前，做出改进，减少失误。

> 重构很少在短期内有助于产品的价值，但从长期来看，它总是有助于团队的生产力(和理智)

除非万不得已，否则不要试图推迟重构工作！

### [](#ask-your-team-for-help-make-everyone-accountable)向你的团队寻求帮助，让每个人都负起责任

代码审查应该是开发生命周期的重要部分。它们也不必是一件很正式的事情。例如，在 Bytemark，我们将合并请求作为一个机会来回顾彼此的工作，并获得对事物的另一种观点。

它们是在提交代码库之前进行改进的好方法，因为它们是获得反馈并让每个人(以客观的方式)对高标准负责的简单方法。

他们可以强调:

*   提高写作水平的方法
*   你可能忽略的问题
*   他人的经验有助于返工
*   在那里你可以修剪重复的工作(例如，类似的东西已经存在，以解决' xyz ')。

### [](#get-refactoring-conventions-in-place)让重构约定就位

这可能更像是一个计划的事情，但是后退一步，分析你正在做的事情，并就整个团队应该如何处理事情达成一些一致，这从来都不是一个糟糕的时间。

当谈到重构时，拥有一些记录在案的、一致同意的习惯和约定将帮助团队中的每个人认识到他们可以在哪里、何时以及如何更好地重构。

其中一些公约可能包括:

*   文件应该有多大(例如 300 行的 JS 文件太长)
*   什么时候应该将一个类分解成独立的模块？
*   在什么情况下，我们应该在一个常规的 React 组件类上使用一个功能性的无状态组件？
*   努力使用[箭头函数](https://robkendal.co.uk/arrow-functions-in-javascript/)而不是常规的“function()”声明
*   如何在 SASS 中嵌套 BEM 类

像 linters for CSS 和 JS 这样的工具可以在一定程度上帮助执行这些约定。

### [](#dont-use-third-parties-because-its-easy)不要使用第三方，因为“这很简单”

我们都看过关于 npm 包的漫画和迷因吧？你加载一个 20kb 的应用程序和 2gb 的 npm 依赖关系？嗯，这种夸张并不完全是错误的，npm 包可以迅速膨胀一个原本简单的项目。

但是这并不是 npm 机器固有的问题，你到处都可以看到这种事情:WordPress 开发者很快就可以在插件商店中找到一些他们自己可以快速轻松完成的东西(我们都经历过！);jQuery 项目可以找到越来越多的插件，这些插件可以被更新的浏览器功能所取代。

我明白了。有时候，你没有时间。你并不是唯一一个想以尽可能少的摩擦快速完成工作的人，而且有很多很好的理由使用外部插件、包和库——例如，一个健壮的、经过测试的套件，它可以做你需要它做的事情。

但是我们必须在抛弃另一个最终属于我们自己的依赖之前仔细考虑。T3】

当考虑在组合中添加第三方依赖时，问自己几个问题:

*   与在内部创建相同的功能相比，这将节省多少额外的时间？
*   会给项目增加什么额外的砝码？这样的交易值得吗？
*   第三方包是否普遍维护良好并定期改进/添加？
*   它会在网站/应用程序/等的任何其他区域引入任何错误或问题吗？-例如冲突？

### [](#document-document-document)文档文档文档

这是一个相当明显的补充，但是要记录所有的事情！对一个应用程序中神秘或复杂的部分做一个可爱的解释，找出它做了什么，为什么和如何做，永远不会没有用。

虽然不是严格意义上的重构措施，但重构的目的是让我们的开发生活更加轻松，并有助于创造新的和维护旧的。记住这一点，好的文档只会帮助我们。

## [](#how-do-you-keep-things-neat-tidy-and-smooth-as-butter)你是如何让东西像黄油一样干净、整洁、光滑的？

所以那就是*持续重构*。你有什么想法？你有什么好的想法和实践吗？请在评论中分享它们。让我们都努力成为更好的开发人员，杀死技术债务的野兽。