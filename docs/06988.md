# GraphQL 的秘密超能力

> 原文：<https://dev.to/hlship/graphql-s-secret-super-power-1g1c>

GraphQL 有一个几乎隐藏的特性，对我来说非常重要。文档中提到了这一点，但我认为许多人在 GraphQL 提供的其他东西的兴奋中浏览了这一页。

在我揭示这个特性是什么之前，让我解释一些我的个人历史以及它是如何相关的。

回到早期，我创建了一个开源的服务器端 Java web 框架， [Apache Tapestry](http://tapestry.apache.org/) 。我为 Tapestry 的许多独特特性感到自豪，这些特性在当时是前瞻性的，即使这些特性现在被认为非常重要。尽管如此，我还是经常在“电梯推销”中纠结 Tapestry 为什么如此有价值。

最终，我想出了 Tapestry 的四个基本方面，这四个方面驱动了它的设计，并突出了它独特的用处:*简单性*、*一致性*、*效率*和*反馈*。

当时的简单本质上是简洁，隐藏了一些必要的机制。多亏了里奇·希基，我对简单的准确定义也随之改变。

一致性涉及到能够在不同的相关领域使用相同的技术:在 Tapestry 中，创建一个页面、一个可以在同一个应用程序中重用的组件或者一个可以跨应用程序重用的组件实际上是相同的。

效率涉及使用框架的开销；本质上，Tapestry 的有益特性必须能够以非常好的性能交付。事实上，Tapestry(尽管比许多竞争框架做了更多的按请求工作)在性能方面总是处于顶层。

这就剩下**反馈**，以及它相当模糊的定义。在我看来，反馈涵盖了让开发人员的生活变得可以忍受的一般工作中的许多事情。一个方面是 Tapestry 支持对代码和模板的实时更改，从而简化了开发人员的反馈循环:能够在您刷新页面时立即看到更改，而不是在几十秒或更长时间(有时更长，更长)内看到更改，这是非常解放的，甚至在您等待时 Twitter 无处不在的干扰威胁到您的注意力之前。

但是，在它的核心，反馈是贯穿代码的一个承诺，捕捉常见的错误并尽可能详细地报告它们；以及一个内置的详细异常报告页面，该页面提供了大量信息，包括堆栈跟踪和组件模板中突出显示的源代码行。

其目的是当出现任何问题时，快速诊断问题所需的细节就在您面前。我在 Tapestry 培训和会议上花了很多时间触发异常报告并深入研究，然后快速修复问题并继续下一步。

那么，反馈(以及简单性、一致性和效率)与 GraphQL 有什么关系呢？

简单性:尽管 GraphQL 在查询和 JSON 的基础上增加了一个类型系统，但 GraphQL 的整体设计非常简单。如果简单性能让你容易理解系统的行为，那么 GraphQL 就赢得了高分。

一致性:实现 GraphQL 模式的所有要素都是一个字段(可能有参数)。疑问和突变？根查询或突变对象上的字段。订阅？仍然是一片田野。输入对象:仍然看起来像字段(没有参数)。单一类型系统定义输入对象和字段参数以及所有输出值。这一切都非常一致。

效率:这里有得有失；当然，解析和执行 GraphQL 查询在计算上比路由请求和抛出 JSON 要昂贵得多；同样，所有 GraphQL 查询都通过单个端点这一事实可能会阻碍传统的缓存方法。

然而，其中一些挑战可以通过利用服务器存储的查询(客户端发送查询的名称，而不是查询本身)来缓解，并且客户端仅请求实际需要的内容这一事实可以在实际吞吐量方面产生显著差异，特别是在将数据下载到移动设备方面。我们的 GraphQL 集成层允许来自后端系统的大部分内容在通过网络之前被过滤掉；充满无关数据的数千字节 JSON 有效负载被过滤成少数输出值，这些值以几十个字符而不是几千个字符计数。

剩下的就是反馈:GraphQL 因其自省能力而获得高分，这使得像 graph QL 这样的东西成为可能。但是促使我写这篇帖子的反馈的具体方面是 [*输入验证*](https://graphql.org/learn/validation/)；GraphQL 具体讨论了如何以及何时捕获 GraphQL 查询中的各种问题，以及如何将这些问题报告给客户端。这包括无法解析的查询文档、对未知操作、字段或参数的引用、省略必需的参数，甚至提供了错误的标量值(或格式不正确的标量值)。

在每种情况下，GraphQL 都可以提供一个错误，详细说明到底哪里出错了，并在查询文档中精确定位与失败相关的位置。

相比之下，我正致力于将我们应用程序的一部分与另一个团队基于 JSON 的 API 集成在一起。我们必须发送一个相当大的深度嵌套的 JSON 对象作为请求体。如果我们的代码省略了一个字段，包含了一个额外的字段，或者提供了*任何*不完全*API 所期望的*内容，我们会得到如下结果: