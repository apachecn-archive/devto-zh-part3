# 汽车和面向对象程序设计

> 原文:[https://dev.to/jckuhl/on-automobiles-and-oop-1k1k](https://dev.to/jckuhl/on-automobiles-and-oop-1k1k)

# [](#introduction)简介

站在任何一个街角，看一会儿车水马龙。一辆斯巴鲁 Crosstrek。一辆福特护卫者。现在道奇公羊。一辆发动机隆隆作响的斯巴鲁 WRX。一个被胶带和绝望绑在一起的南斯拉夫人。

所有这些都是汽车。它们有相同的基本结构。四个轮子，一个引擎，一个方向盘，靠汽油或柴油运行。然而，它们在颜色、马力、形状、特征，甚至可能使用的汽油种类上都有很大的不同。每条繁忙的街道都充斥着各种不同形状的汽车，然而我们看到的大多数车辆，每个人都会同意，都是汽车。是的，取决于你如何定义它，你的道奇公羊可以被认为是“一辆车。”

这反过来也是面向对象编程(OOP)的内容。对象是基于一些基本模板的单个属性的集合。每辆车都是基于一些基本模板的一系列独立功能。当然，有些模板是模板的模板。没有“基本汽车”，它是一个抽象的概念，是每个衍生汽车必须实现的属性和方法的集合，但每个衍生汽车都可以在抽象的范围内自由实现。我们对汽车是什么有一个大致的概念，然后扩展到不同类型的汽车。斯巴鲁傲虎是旅行车。一辆 GMC Yukon 就是一辆 SUV。福特 Fusion 是一款轿车，没有人真正知道本田飞度是什么。从这些类型，旅行车，SUV，轿车等，你可以找到更具体的想法，像我列出的车辆为例。最终，你会得到一个足够具体的抽象概念来制造一辆辆汽车。

```
Car
    Sports Utility Vehicle
        GMC Yukon
    Station Wagon
        Subaru Outback
    Sedan
        Ford Fusion 
```

这些被称为类。

# [](#classes)类

如果你走进一家斯巴鲁工厂，你不会发现一群疯狂的工程师试图胡乱组装一辆汽车。当然，这将是可笑的，低效的，并导致不一致的汽车的产生。

在艺术上，非一致性通常是有价值的，但在编程世界中，它会引起问题。对象不符合其所需的角色。测试几乎是不可能的，因此质量保证被抛到了九霄云外。大规模生产变慢了。

相反，你看到的是一条长长的程序装配线，工人们(现在大多数都是机器人)按照一套精确的指令，根据之前绘制的示意图制造汽车。

这个示意图正是一个类。类本身不是它们创建的对象，而是创建对象的模板。如果我拿出一辆 2017 款斯巴鲁傲虎的示意图，它会详细告诉我每个螺母和螺栓的位置，以及每个功能是如何工作和实现的。

# [](#constructors)构造函数

当然，每辆车的制造方式都有所不同。而出于某种原因，橙色的斯巴鲁 Crosstreks(我也喜欢开着南瓜在街上跑！)似乎主宰了高速公路，显然，人们在颜色和许多其他次要特征上有很大的余地。

构造函数设置属性并初始化它们。它允许我们为对象的单个实例设置单个细节。然后，它创建对象。

构造函数和初始化函数有许多不同的风格。在我继续之前，构造函数和初始化函数有明显的区别。构造函数在内存中创建对象(斯巴鲁工厂推出了一款新的 Outback ),初始化函数设置其属性(新的 Outback 被涂上了可选的插件)。)有些语言一次做这件事，有些分开做。

```
// Java
class MyObject {
    String param;
    MyObject(String param) {
        this.param = param;
    }
} 
```

```
// JavaScript
class MyObject {
    constructor(param) {
        this.param = param;
    }
} 
```

```
# Python class MyObject:
    self.__init__(self, param):
        self.param = param 
```

想想像斯巴鲁工厂装配线这样的建造者。你首先告诉机器人你想要什么颜色和特征(好吧，实际上在现实世界的工厂里可能不是这样的，但请耐心听我说)，然后机器人根据给他们的类模板，用你想要的参数建造汽车。

这条线的尽头是一个漂亮闪亮的内陆，有你想要的所有定制，但它有足够的内陆特征，它和你遇到的任何其他内陆一样多。即使是旧的块状的。

# [](#interfaces-and-abstract-classes)接口和抽象类

然而，并不是每个对象都需要构造。我之前说过，基本的汽车理念不是具体的物体，而是抽象的理念。基本车只是每辆车*必须*实现的功能列表。如果你不实现这些功能，无论你的建筑是不是一辆汽车。也许它有轮子和引擎，但它不是汽车。如果一辆半挂卡车从你工厂的另一端出来，它就不是一辆汽车，因为它有太多的轮子。如果一辆 M1 艾布拉姆斯主战坦克从另一端出来，它不是一辆汽车，因为它有履带，而不是轮子，国防部想知道你为什么要建造军用坦克。

接口是一个契约。它保证了从另一端出来的将是一辆车。

暂时放下汽车的比喻，想象你有一个函数，它把一个对象作为它的一个参数，在这个函数中，它调用这个对象的一个方法。

```
class Person {
    String name;
    Person(String name) {
        this.name = name;
    }
    public void greet() {
        System.out.printf("%s says 'Hello'", this.name);
    }
}

// assume we're in class main
public static void personGreet(Person person) {
    person.greet();
}

public static void main(String ...args) {
    personGreet(new Person("Jim"));
} 
```

在上面的例子中，我们有一个方法接受一个`Person`并调用它的`greet`方法。这当然很好，但是有一个问题。如果我有多种类型的人，而继承是一种对我不利的模式，该怎么办？如果我有`Employee`和`Dog`，它们可能都有问候语，但可能不作为 Person 的子类工作，该怎么办？`Employee`可能会，但是`Dog`不会！也许我的代码结构是这样的，即`Employee`使用组合比继承更好。我们可以确保这两个类都在带有接口
的`personGreet()`方法中工作

```
interface Greetable {
    public void greet();
}

class Employee implements Greetable {
    // ...
    public void greet() {
        System.out.printf(
            "%s says 'Hello', I work for %s as %s", 
            this.name, this.job, this.jobTitle
        );
    }
}

class Dog implements Greetable {
    // ...
    public void greet() {
        System.out.printf("%s barks 'Arf Arf!', this.name);
    }
}

// and back to the Main class
public static void personGreet(Greetable greeter) {
    greeter.greet();
} 
```

现在我们的 greet 类可以接受任何实现了`Greetable`的对象，因为我们可以确信它实现了所需的方法。

它对任何现代 IDE 都非常有帮助。如果 IDE 知道您的变量实现了 Greetable，它会在 Greetable 接口中提供有用的方法建议，因此您不必记住如何拼写它们或者方法参数的顺序。

> 像 JavaScript 这样的一些语言没有静态类型，对于这些语言来说接口是没有意义的。如果我想将一个对象传递给`personGreet()`方法，没有什么可以确保`personGreet()`有一个`greet`方法，除非我实际编写这样一个检查。接口是静态类型语言的亮点。如果您是 JavaScript 的粉丝，但也想要静态类型，请尝试 Typescript。

在《驾驶教育》中，没有人教你如何驾驶一辆特定的汽车。你被教导如何以一种非常普通的方式驾驶。我们都明白汽车实现了一个特定的接口。方向盘在左边(除非你是英国人)，油门在右边，它让车跑起来。向上轻拂信号灯表示右转，向下轻拂信号灯表示左转。汽车都实现了相同的接口。如果你能开一辆车，你就能开所有的车。

和任何需要特殊许可的车辆，它们可能实现 Car 接口，但是它们也实现一些用户需要知道的其他接口。一辆 semi 可以实现一些和汽车一样的细节。semi 毕竟是以相同的基本方式操作的，但也会实现一些其他接口，因为它的大小、重量、轮子的数量都会影响它的操作，使它成为一个不同的对象。事实上，将一些想法从汽车中提取出来(比如基本驾驶)并将其移动到车辆界面中可能会更好。

如果 car 是一个抽象类而不是一个接口，可能会更好，它实现了车辆接口，但也有自己的属性，如`hasFourWheels`和其他汽车特有的东西，但不是车辆特有的。

在 Java 中，您可以看到从 Servlet 接口到 GenericServlet 抽象类，再到 HttpServlet 抽象类，再到您自己的 Servlet 实现(继承自 HttpServlet 或 GenericServlet)的过程。

# [](#properties-and-methods)属性和方法

让我们回到我开始这篇文章的那条路上。我们开过所有的车，包括那辆糟糕透顶的橙色斯巴鲁 Crosstrek。(为什么都是橙色的？)虽然它们都继承了 Vehicle 和 Car，但看起来都非常独特。人们在形状、颜色、性能、收音机、机舱控制等等方面有广泛的选择。当您构造一个对象时，它是存储在内存中的唯一数据结构。你可以有任意数量的它们(当然直到内存用完)，它们可能有相同的基本形状，但它们都是独一无二的。

在我继续之前，属性在不同的语言中被定义为不同的东西。在 JavaScript 中，它们是属性。在 Python 和 Ruby 中，它们是属性。在 Java 中，它们是字段。为了清楚起见，当我说“财产”时，它适用于所有这些东西。

属性只是应用于单个对象的一些状态。例如，汽车的颜色或马力。

方法是单个对象可能执行的一些行为。当你在你的车上踩油门时，你调用`accelerate()`方法。即使每个物体都有相同的`accelerate()`方法，也不是每辆车都会立刻加速！只有叫自己的`accelerate()`的车才会开始加速，增加自己的`speed`属性。如果两辆车同时加速，只是修改了自己的内部状态。我按下车里的油门，只能让我的车跑起来。

# [](#static-vs-member)静态 vs 成员

当人们谈论静态方法和属性时，他们经常说一些晦涩的话，比如“静态方法属于类，而成员方法属于对象。”一旦你掌握了面向对象的概念，这个概念就不难理解了。但是对于一个编程新手来说，这可能有点令人困惑。毕竟，所有的方法和属性不都属于类吗？一个新的程序员可能还没有意识到类和对象是不同的。如前所述，类是一个示意图，对象是示意图设计的具体事物。

任何标记为“static”的东西意味着应用于整个类，应用于单个对象没有意义，从类中分离出来也没有意义。

为了解释它，我将继续汽车类比。想象你开车去公路旅行。因为你非常富有，你把你的车从美国渡过大西洋到欧洲。当你到了那里，你会发现喜欢简单的欧洲人使用公制。幸运的是，你的车有一个功能，可以将每加仑英里数显示转换为每升公里数。这样的公式对任何汽车都是有用的，但如果你开的是一辆斯巴鲁 WRX 或福特 Fusion 或一辆用胶带和绝望粘在一起的笨重的 Yugo，它不会改变。不管你开什么车，MPG 到 KPL 都是一样的功能。即使你开着一辆油老虎，单位转换也不会改变。那么，为什么要针对每辆车制定具体的方法呢？使它成为静态的，以便所有的汽车都可以共享它。

MPG 到 KPL 的转换不属于汽车。当然，一个人可能会构建一个方法来显示这种转换，但是数学的*实际实现*不属于汽车。相反，它可以作为所有汽车制造商和司机的常识储存起来。

```
class Car {
    final static double MPG_TO_KPL = 0.425144;
    public static double mpgToKpl(double mpg) {
        return mpg * MPG_TO_KPL;
    }
}

class Outback extends Car {
    public void displayMetricFuelConsumption() {
        double fuelConsumption = Car.mpgToKpl(this.mpg);
        System.out.println("Current fuel consumption in kpl: " + fuelConsumption);
    }
} 
```

正如您所看到的，单个对象本身可以调用自己的方法来显示转换后的单元，但是单元转换本身是静态的，保持在类级别。此外，`Outback`不必扩展`Car`就可以使用静态方法，任何对象都可以从`Car`类中调用它。

# [](#inheritance)继承

此时，您应该对什么是继承有一个大致的概念。总而言之，继承的思想是子类型继承其父类型的属性和方法。

旅行车是一种汽车，因此它有四个轮子，是为大众使用的。汽车又是一种交通工具，因此它有方向盘、油门和刹车踏板、某种活塞式发动机等等。

斯巴鲁 Outback 是一辆旅行车，因此它是一辆带有掀背车的汽车，后备箱有额外的空间。因为它是旅行车，所以它是汽车，因为它是汽车，所以它是交通工具。

# [](#polymorphism)多态性

但是并不是每个子类型都以与它们的父类型相同的方式实现方法！一辆斯巴鲁 WRX 和一辆斯巴鲁傲虎加速方式当然不一样！在任何 OOP 语言中，子元素都可以覆盖父元素的方法和属性。这是通过重写和重载实现的，尽管不是每种语言都支持重载。例如，JavaScript 就没有。

覆盖是当我们改变实现，但保持方法签名不变。在斯巴鲁 WRX 中，也许在我们的加速方法中有一种涡轮增压方法，这是你在内陆通常找不到的。

重载是指方法签名相同，但参数及其类型不同。只要用不同的参数和不同的参数类型重载一个方法，就可以多次重写它。但是，并不是每种语言都支持这一点。JavaScript 没有。

您可以在 JavaScript 中模拟重载，方法是使用`typeof`或`instanceof`关键字，并根据给定的参数以编程方式确定参数是什么以及实现做什么，但是不能有多个同名不同参数的函数。

你可以在 Java:

```
public static String add(String a, String b) {
  return a.concat(b);
}

public static int add(int a, int b) {
  return a + b;
} 
```

这两种方法名称相同，但签名不同。重载只是根据输入的内容来改变实现。

# [](#application-programming-interface)应用程序编程界面

在我继续之前，我想花一点时间解释一下什么是 API(应用程序编程接口)。API 是用户可以使用的面向公众的属性和方法的集合。

你的车有 API。有一个供它吸入气体的端口。有一个踏板使它前进，另一个踏板使它停止。有一个轮子可以让我驾驶。这些东西可以让你与汽车互动，以可控和可预测的方式改变它的状态和行为。

任何对象的 API 都可以归结为用户要使用的公共属性和方法。

# [](#encapsulation)封装

当我在路上开车时，当我的脚踩在刹车或油门上时，它会影响我的车的内部状态。我在减速或加速。这不影响我周围的其他车。我的车的内部状态被封装了。作为用户，我不需要知道引擎在做什么，我身边的人也不需要知道。我只需要知道什么是公共 API。当我与那个 API 接口时，我不需要知道内部发生了什么。如果我踩油门，我不需要知道在任何给定的时刻，哪些活塞必须上升，哪些活塞必须下降；引擎会替我处理。如果允许我在引擎运行的时候进去修改它，我可能会弄坏什么东西。

这就是封装。一个类的内部状态只能通过专门为外部用户设计的特定方法向外界公开。例如，singleton 使用封装来确保自身只有一个实例。该构造函数只能通过特定的公共方法访问，以确保它只能被调用一次。通常，它会检查实例是否已创建，然后要么创建实例，要么返回对该实例的引用，但是构造函数本身设置为 private，不能从外部调用。

# [](#abstraction)抽象

现在让我们再次回到驾驶课程。记住，你没有被教会驾驶一辆特定的汽车，而是一辆汽车的一般概念。我们知道你开的任何车都会继承 car 和 Vehicle，所以我们知道它会有加速器、刹车踏板、方向盘、转向灯和其他或多或少在相同位置和相同配置的东西(但对你们英国人来说可能在另一边！)

这些方法是如何实现的并不重要，重要的是它们是以可预测的方式实现的。抽象与封装相关，因为你不知道也不关心内部。你所知道的是，如果你调用一个方法，可预测的行为应该发生。如果我踩油门，车应该会向前开。如果我踩下油门，闪灯亮了，那。。。那会很奇怪。

你知道如何驾驶任何一辆车，因为你被赋予了一个抽象的概念，那就是什么是车，它的方法是什么。你知道每辆车都有这些方法在一个类似的 API 中，你可以使用。油门踏板或转向灯的实际执行或任何你不知道的事情。如果你想加速，就踩油门。没有必要去理解踩下那个踏板是如何使气体流入你的发动机的，这使得活塞上升和下降，并允许它们在进气、压缩、燃烧和排气系统中循环。当然，这对于维护来说可能很方便，但是你可以很容易地驾驶一辆车，而不知道引擎盖下那个大而响的金属东西实际上在做什么。

抽象隐藏了不必要的实现细节。它允许您将该实现打包成更有意义和可重用的东西。这降低了用户端的复杂性。以 JavaScript 的数组方法库为例。

```
const squares = [1,2,3].map(x => x**2);
//[1, 4, 9] 
```

> 虽然 JavaScript 是一种面向对象的语言，但它是基于原型继承方案，而不是传统的继承方案。这是需要记住的事情。也就是说，我在这里陈述的大部分内容也适用于 JavaScript，但可能不完全适用。

作为用户，我关心`map()`在引擎盖下做什么吗？不。我只关心它对每个元素都有某种功能。我不在乎*如何*。我不想每次想改变数组的元素时都实现一个映射函数。为什么不把它抽象成一个方法，这样我就可以在需要的时候重用它？

那是抽象。

# [](#conclusion)结论

面向对象的编程可能有点令人困惑，但是我发现如果你把对象看作是日常生活中的真实对象，这是最容易理解的。汽车是大规模生产的物体，具有相似的基本形状，尽管有令人难以置信的多种类型，从笨重的 SUV 到旅行车，到皮卡，到轿车和跑车。如果您考虑一下汽车在现实世界中是如何相互关联的，您就可以更好地理解对象在编程世界中是如何工作的。

我希望这有助于更好地理解 OOP 是什么，OOP 中涉及的基本概念和术语是什么。我并不打算真正深入 OOP 的实际语言实现，但是希望当你读到不同的语言是如何实现 OOP 的时候，有一些类似的东西将有助于使概念更加清晰。