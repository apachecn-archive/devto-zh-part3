# Haskell 中的递归函数

> 原文:[https://dev . to/lautarolobo/a-recursive-function-in-haskell-3 ldb](https://dev.to/lautarolobo/a-recursive-function-in-haskell-3ldb)

准备好被爆头了吗？好了，让我们定义一个简单的函数，将数字列表中的每个数字乘以 2。我们将这个函数命名为“by2”。

所以，你有一个函数，它把一列数字作为参数，在计算过程之后显示一列数字。这个用 Haskell 怎么写？嗯:

```
by2 :: [Int] -> [Int] 
```

括号代表一些东西的列表，在这个例子中是整数。这就是你如何在 Haskell 中定义一个*类型*，我在[的上一篇文章中谈到过。](https://lautarolobo.xyz/blog/first-haskell-function)

一旦定义了类型，下一步就是定义实际的函数。首先，你调用函数，用参数，然后你输入函数必须做的过程，最后，你应该有这样的东西:

```
by2 x:xs = (2 * x) : by2 xs 
```

[![What?](../Images/795e210f5b2c34f7466a325b5a41eb8e.png "What?")](https://res.cloudinary.com/practicaldev/image/fetch/s--GmCqZaLv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://lautarolobo.xyz/images/whatt-9950b372.png) 
嗯，我来解释一下那段代码是怎么说的，你有一个至少有一个元素的列表(这里是一个整数)，by2 取第一个元素，然后乘以 2，没什么新的，但是然后我把乘以 2 的元素包含在…没有第一个元素的函数里？似乎很奇怪？下一行也是最后一行代码，然后我会深入解释一些概念，你需要知道这些概念才能完全理解这个函数。

```
by2 [] = [] 
```

首先，我在使用*模式匹配*，这是一种定义函数的方法，它将函数定义中给定的模式与给定的参数进行比较。如果你想了解更多，请查看[这个](http://learnyouahaskell.com/syntax-in-functions#pattern-matching)。

还记得一开始我说的“一个简单的函数”吗？实际上，我可能错了，这个不太简单，因为引入了除模式匹配之外的一个重要概念，*递归*。by2 是一个递归函数，这意味着该函数应用于它自己的定义中。要使函数使用递归，必须使递归调用小于给定的参数。回到你的代码，你会看到，列表的第一个元素不再出现在 by2 的递归调用中。此外，你总是需要写你的基本情况，函数可能遇到的较小情况，在这种情况下是一个没有元素的列表，就像我展示的第二行代码一样。然后，递归调用将变得越来越小，直到给函数的参数将是…一个空列表！在那里，每个元素，按顺序，将被插入到这个列表中。

这很难理解，举个例子也许会更好些:

```
by2 [7,3,5]
[14,6,10] 
```

这里发生的事情是:

[![](../Images/5e733fdab365ec04b7a51b943bea1049.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--xnpBnR3D--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://i.imgur.com/lDAwKhN.png)

然后，解决乘法，每个数字回到原来的位置；10 进入空列表，然后是 6，最后是 14。

嗯，我想我们顺便解释了一些概念，模式匹配和递归。但是……你试过功能吗？打开终端，然后打开编译器，加载您的文件并测试 by2！

您可以尝试其他参数，如空列表或带单词的列表。开始到处玩，改变 by2 的定义，创造一个 by3，或者一个 plus2 接受更多不同参数的新函数，具有新的定义。

如果有任何问题，请在下面的评论中写下来，我很乐意帮助你解决！

你已经走到这一步了，孩子。令人印象深刻。不要停止学习！