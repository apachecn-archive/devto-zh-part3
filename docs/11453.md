# 事件循环和煎饼堆栈

> 原文:[https://dev.to/joe/event-loops-and-the-pancake-stack-5h1i](https://dev.to/joe/event-loops-and-the-pancake-stack-5h1i)

警告:在英国，煎饼更像薄饼

每当我向另一个不太熟悉 JavaScript 和 Nodejs 的开发人员提到它是单线程时，他们通常会遇到:

所有这些都是常见的反应，然而 JavaScript 驱动着我们每天使用的基础设施，如 Twitter 和网飞。

一个本来就不能同时处理多件事情的东西怎么可能有能力以高使用率支持这样的服务呢？

我打算在这篇文章中用节日主题画一幅画。

## [](#pancake-parallelism)煎饼并行

让我们想象今天是煎饼日。你已经向你最亲近的人承诺，每顿饭都是煎饼，而且会很隆重。你做好面糊，拿起平底锅，开始制作过程。

你很快就会意识到，虽然每个人都将在不同的时间吃他们的食物，使它更像一个开车经过的胰腺，而不是一个很好的社交餐。

这时你有了一个好主意，从橱柜里拿出另一个锅，把热量放在另一个炉子上，这样你就可以一次做两个煎饼。这样好多了。现在，最多两个人可以一起吃饭，这样他们就有时间一起谈论他们是如何喜欢美国风格的，而你则静静地哭泣。

决斗挥舞煎饼会变得很累，你需要确保他们没有燃烧，并适当翻转。你的客人仍然很饿，所以也许是时候拿第三个这样的锅来和你迅速减少的朋友们交换一些社会地位了。

一次三个煎饼比上帝要做的还要多，你的朋友要求不同的形状，你总是把它们弄混，整体质量在下降，因为没有在每个煎饼上投入必要的爱。

**这就是你放弃的地方**

这个故事的寓意是，做煎饼是相当费力的，而且我刚刚骗你学习了多线程如何在 CPU 使用和内存方面工作。

> 哈

玩笑归玩笑，我们怎么做煎饼？首先你可以在~~煎饼~~栈溢出*(对不起)*上问，它会告诉你需要你的一些朋友来帮助你做一些煎饼，这意味着你必须做的工作不那么紧张，会做得很好。

> 但是

如果你只有一个炉子呢？那你怎么可能满足你所有朋友的需求呢？也许你不应该让有更多空间做饭的人来主持。

> 不要！

你要像个英雄一样做煎饼，你要用...

## pancake creator 3000

烹饪煎饼是一个可以异步执行的过程，但我们以前面临的问题是，我们自己管理一切太困难了。

如果我们买一台机器，可以完美地烹饪大量的煎饼，几乎没有监督，会怎么样？你所要做的就是打开它，把煎饼拿出来吃。如果这样的机器存在，那就可以腾出时间和朋友们讨论为什么煎饼会有一个特殊的日子。然后你可以让所有人同时吃东西，把人们的食物从机器上放到盘子里可能会有几秒钟的误差。

这个神奇的机器正在做所有的工作，只要你正确地告诉它你想要它生产的煎饼，并在最后取出它们上菜。

**那就是事件循环。**

# [](#the-call-stack-and-callback-queue)调用堆栈和回调队列

要完全理解`Event Loop`,你需要对它的所有组件如何组合有一个基本的了解。

`Call Stack`是一个`Stack`,它将执行代码的任务推给它，当结果被计算出来时，它将弹出。

一些功能调用是异步的，并且与外部 API 交互。

在这里，它们被委托给各自的服务来处理它们，并在 API 完成处理请求时将响应添加到`Callback Queue`中。这个队列将处理回调，它们将按照被添加到`Callback Queue`的顺序被处理*，这被称为先进先出*。

*注意:回调队列也称为消息队列*

## [](#the-event-loop)事件循环

`Event Loop`是不断检查`Call Stack`的状态以确保它是空的。如果是，那么它将从队列的第一帧开始处理来自外部进程的响应，并将结果放回`Call Stack`。

> 重要提示:`Event Loop`只会在`Call Stack`上什么都没有的时候计算队列中的一个项目(因为 JavaScript 是单线程的)。

这就是 Nodejs 能够同时处理数千个数据库资源请求的方式。这里的瓶颈是数据库，而不是服务器，因为`Call Stack`只是对数据库说“嘿，你能帮我找到这个用户吗，完成后告诉我一声”。当数据库运行并成功(或失败)时，它返回并将帧添加到`Callback Queue`中，最终由`Event Loop`进行评估。如果您认为“这类似于承诺和异步/等待的工作方式”，那么您是对的，因为它们帮助您以一种让您利用`Callback Queue`提供的响应的方式执行这个过程！

你通常不需要直接考虑事件循环，但是如果你见过这样的代码...

```
// This works, dunno why, don't delete please
setTimeout(() => doThingThatIsDependantOnOtherThing(), 0); 
```

恭喜您，您已经发现了如何欺骗事件循环以“正确的顺序”做某事，实际上只是将它添加到队列的后面，以便它在任何其他异步请求回调被解决后执行它的回调。

尽管超时值为 0，但它仍然工作的原因是，在计时器执行完毕后，它会将`doThing...()`函数强制放在`Callback Queue`的后面，所以它不会解析，直到添加到`Callback Queue`的所有内容都由`Event Loop`处理。

## [](#why-isnt-everything-event-loop-based)为什么一切不是基于事件循环的？

在一些真实的情况下，你需要做一些不能被委派的事情。例如，复杂的浮点数学更适合多线程来帮助解决问题。

如果有人发现如何利用活动循环制作煎饼，请发电子邮件给我。

* * *

这篇文章的灵感来自于真的不能一次做足够多的煎饼...

以下文章也有很好的图表可供参考:

*   [https://medium.com/@gaurav.pandvia](https://medium.com/@gaurav.pandvia)
*   [https://blog . carbon five . com/2013/10/27/the-JavaScript-event-loop-explained/](https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/)

如果有任何不完全准确或可以澄清得更好的地方，请告诉我:)