# PHP 异常处理的最佳实践

> 原文：<https://dev.to/moxio/best-practices-for-php-exception-handling-j5i>

在创建健壮的 PHP 应用程序时，处理错误或其他非“快乐路径”的情况是必不可少的。虽然在 PHP 4 中[错误](http://php.net/manual/en/language.errors.php)是这样做的主要构造，但是[异常](http://php.net/manual/en/language.exceptions.php)从 PHP 5 开始就已经存在了。如今，它们应该被视为处理备选或异常路径的主要机制。然而，这些替代途径似乎并没有得到应有的关注。

正确的异常处理需要相当多的努力，但最终会产生一个更加稳定的应用程序。一个明智的异常处理策略清楚地表明应该预期什么样的异常(并因此得到处理！)在代码中的给定点。此外，它将保持您在面向对象设计中仔细应用的封装和抽象。最后但同样重要的是，它应该使调试变得轻而易举。

在本帖中，我将向您介绍我们在 [Moxio](https://www.moxio.com/home) 多年来采用的一套最佳实践。我们发现这些对我们非常有用，但是请记住，它们是我们的最佳实践*；您的里程可能会有所不同。下面的指导方针是针对 PHP 代码的，但是它们背后的基本原则(通过一些翻译)也适用于类似的语言。*

### 异常的类型

我们区分了 PHP [SPL 库](http://php.net/manual/en/book.spl.php)定义的两种顶级类型的异常。这些是 [`LogicException`](http://php.net/manual/en/class.logicexception.php) 和 [`RuntimeException`](http://php.net/manual/en/class.runtimeexception.php) 。文献中对这两种类型的解释各不相同。然而，我们赋予它们以下含义:

*   一个`LogicException`是一个异常，它需要代码的修正或改变。“代码”不仅仅指源代码，还包括开发人员管理的任何内容。这包括不由系统最终用户维护的配置和数据库内容。一个`LogicException`主要是内部的守卫或者断言。在完美编写和连接的代码中，不应该出现这种情况。
*   一个`RuntimeException`是一个异常，它也可能出现在被编写和配置“完美”的代码中。这种异常可能是由最终用户的输入或外部系统(与外部系统的通信)中的错误引起的。当抛出一个`RuntimeException`时，它应该不需要在代码中进行修复。但是，如果异常最终未被捕获，我们应该添加一些代码来处理它。这可能意味着记录错误、使用回退策略、向用户报告错误或其组合。

注意，这种解释不同于 Java 中的一般理解，在 Java 中，`RuntimeException`就是我们所说的`LogicException`。此外，在我们的标准中，我们将所有的异常分为这两类。我们不创建异常作为`Exception`的直接子类。

### 异常作为函数签名的一部分

我们看到了`RuntimeException`的可能变体，它们可以作为函数契约的一部分从函数中抛出或冒出来。这意味着这样的异常应该使用`@throws`在函数上进行注释。

如果该函数是接口实现的一部分，那么该接口应该指定在可能抛出异常的情况下(的超类型)。没有必要在实现中也注释这样的异常。实现接口的函数不应该抛出未在接口上声明的运行时异常。这种情况会违反里斯科夫替代原理。

相反，我们认为不同类型的`LogicException`不是函数契约的一部分。当然，我们假设一个完美的实现，但同时我们知道在某个地方总会有错误。因此,`LogicException`总是可以同时被预期和不被预期。因此用`@throws`来注释它是不可取的。另请参见下面的“捕获异常”。

### 创建异常子类

在这些指导方针下，在`RuntimeException`下创建子类型的层次结构是非常可取的。我们抛出的异常越具体(并作为契约的一部分进行注释)，我们处理它们的粒度就越细。然而`LogicException`的子类不是必需的。无论如何，这些都不是函数契约的一部分。

### 捕捉异常

对我们来说，一个`RuntimeException`是一个*检查过的*异常。当这样的异常可以从函数中抛出时，调用函数需要或者捕获该异常，或者使用`@throws`将其声明为可能的异常。当调用代码可以明智地处理异常时，或者当它可以在更好的抽象层次上重新抛出异常时，捕捉运行时异常是一个好主意(参见下面的)。至少在调用可能抛出异常的函数时，考虑这些异常的处理是很重要的。

逻辑异常不应该被捕获，至少不应该基于类型`LogicException`或其子类。在正确的实现中，这些异常不应该出现。因此，试图沿着这条线处理它们是没有意义的。相反，应该修复触发异常的逻辑。

在某些时候，可能有必要捕获*所有的*异常，包括`RuntimeException`和`LogicException`的变体。由于我们要求 PHP 7 的最低要求，我们在我们的`catch`-子句中使用了`Throwable`，而不是`Exception`。像这样的构造专门用于组件入口点，不应该对异常的具体原因或特征做出假设。因此，这样的代码永远不会包含特定的错误处理逻辑。相反，它们是用于记录或报告错误，或者向最终用户提供出错反馈的通用总括。

有时，像这样的总括也用于清理资源或关闭打开的连接。在这种情况下，`finally`块通常更好，尤其是当异常在 catch 块的末尾被重新抛出时。

#### 特例:调试信息

捕获`LogicException`的一个有效理由是用额外的调试信息来扩充它，这些信息在调用栈中更深处是不可用的。在这种情况下，我们直接抛出一个带有额外数据的新的`LogicException`，以及`$previous`中的原始异常。我们最好基于最通用的类型来捕捉这样的异常。这可能是给定代码段中可能出现的所有`LogicException`的公共基类或*标记接口*。

这种捕捉的替代方法是将调试信息传递给最终产生错误的被调用者。如果这样的信息只是用于将它传递到一个异常中，我们宁愿不这样做。

### 捕捉后抛出新的异常

在捕获一个异常之后，当然有可能抛出一个新的异常。事实上，对于明智的异常处理，这比我们想象的更需要。只需将新异常的`$previous`-参数设置为原始(被捕获)异常。这确保了仍然可以推导出异常的完整原因。由于`Exception`构造函数参数的顺序，通常需要指定一个`$code`。我们不使用这个参数，就把它设置为`0`。

#### 翻译到正确的抽象层次

捕捉和抛出通常是必要的，以确保一个异常在一个合适的抽象层次上表现出来。假设我们有一个由`DatabaseUserRepository`实现的`UserRepositoryInterface`。后者将用户存储在数据库中，如果具有给定用户名的用户已经存在，就会引发一个`DuplicateDatabaseKeyException`。根据前面描述的规则，我们应该使用`@throws`在接口上注释这个异常，但是这确实感觉有点奇怪。为什么一个旨在抽象存储机制的通用接口会知道特定于数据库的异常类型？解决方法是在`DatabaseUserRepository`内抓住`DuplicateDatabaseKeyException`，并在它的位置上扔一个类似`UserAlreadyExistsExeption`的东西。这个异常符合`UserRepositoryInterface`的抽象层次:它知道用户，但不知道他们是如何被持久化的。因此，它可以毫无问题地添加到该接口的签名中。

#### 从`RuntimeException`到`LogicException`

很有可能是一个`RuntimeException`的异常在某个时候被转换成了一个`LogicException`。这与我们在这一点上的具体知识有关，从这些知识中我们知道给定的异常应该是不可能的。这些知识在*调用栈*的更深处是不可用的。

为了说明这一点，假设我们有一个带有方法`getUniqueTagContents`的 XML 阅读器。该方法根据标记名从 XML 文件中读取一个唯一标记的内容。在这样的方法中，很多事情都可能出错:XML 文件可能格式错误，给定的标记可能不存在，或者它可能出现多次。这些都是`RuntimeException`的例子。不需要额外了解 XML 的来源(可以由用户上传)和标签名称，它们也可以出现在完美的编程应用程序中。但是有可能我们在一段 XML 上使用这个方法，这段 XML 是我们刚刚根据一个 XML 模式验证的，该模式强制执行给定标记的存在性和唯一性。在这种情况下，我们知道`getUniqueTagContents`不应该失败。当我们使用方法来读取我们自己放在 VCS 中的配置文件时，这同样适用，因此我们完全控制它。

在这种情况下，我们仍然必须捕捉“不可能的”运行时异常，因为我们认为它们是*检查过的*。在这个`catch`块中，我们抛出一个`LogicException`:这种情况永远不会发生。当然，我们通过`$previous`参数保存原始异常。

这是一种经常出现的模式。在*调用栈*的深处，没有更大的画面，许多错误都是 RuntimeException。随着异常的出现(无论是否被转换到另一个抽象层次)，它会到达一个我们知道不可能出错的点。在这一点上，它成为一个逻辑异常。请注意，反过来是不可能的:一个意想不到的错误不能突然预期。

### 灰色区域

`RuntimeException`和`LogicException`之间的区别并不总是 100%清楚。存在一个灰色区域，其中正确的异常类型取决于解释和函数的语义构造。举几个例子来说明这一点:

#### 查询中的语法错误

执行数据库查询的方法`executeQuery`可能会由于查询中的语法错误而失败。乍一看，这看起来像一个`RuntimeException`:我们不知道查询来自哪里，因此不能保证它的语法正确性。另一方面，如果用户输入(或来自我们无法控制的其他来源的输入)会导致语法错误，那就很奇怪了。有 SQL 注入的味道。因此，非常合理的说法是，调用`executeQuery`的代码负责查询的语法正确性。这使得异常成为一个`LogicException`。一个例外是，如果我们正在构建一个像 [adminer](https://www.adminer.org/) 或 [phpMyAdmin](https://www.phpmyadmin.net/) 这样的应用程序，我们应该预料到用户输入的 SQL 查询中的错误。

#### 未找到缓存项

假设我们有一个缓存类，它使用方法`get($key)`来检索缓存项。当然，用一个不存在的键调用 get 也是可能的。我们假设我们已经选择通过异常来传达这一点(备选方案是通过返回值或引用参数)。这样的异常是运行时异常还是逻辑异常？

答案可能取决于 cache 类上的其他方法以及我们期望如何使用它们。如果缓存有一个`has`方法，我们可以要求消费者在用 get 检索之前使用该方法检查缓存项是否存在。在这种情况下，a `LogicException`是合理的。根据缓存的实现，在调用`has`和`get`之间，缓存项可能会被删除。在这种情况下，即使完美的实现(首先检查存在)也不能完全防止错误。“正确的”异常类别在这里不是很清楚。现在，我们倾向于使用`LogicException`来处理这种罕见的边缘情况。

#### 数据库中的数据损坏

另一个灰色区域是只有在数据库损坏的情况下才会出现的错误。从纯粹的观点来看，这是一个`RuntimeException`的例子，数据库是一个外部因素。另一方面，不希望在代码中的任何地方都考虑到数据库损坏的可能性。如果只有应用程序，偶尔还有开发人员或系统管理员向数据库写入数据，这就更适用了。更实用的方法是将数据库损坏视为一个`LogicException`。损坏的数据很可能是由应用程序中的实现错误引起的。无论如何，需要开发人员或系统管理员的干预来手动修复数据。

### 重述

我们将代表固有“不可修复”情况的检查异常与代表编程错误的未检查异常区分开来。因此，我们知道在代码的每一点我们应该期待什么异常，从而处理。通过捕捉和重新抛出异常，我们确保它们处于适当的抽象层次，从而不会破坏封装。使用`$previous`参数链接原始异常可以确保没有调试信息丢失。

你在你的项目中尝试这些实践了吗？如果它们对你有用，如果你遇到了困难，或者你对这些指导方针有什么改进，请告诉我们。我们希望得到您的反馈！