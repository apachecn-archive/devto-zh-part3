# 不可测试的代码毫不留情

> 原文：<https://dev.to/scotthannen/untestable-code-knows-no-mercy-4n5i>

什么是不可测试代码？

*   它没有单元测试。
*   如果不修改代码，为它编写单元测试将是困难的或者不可能的。
*   公共属性包括全局状态、紧耦合和做很多事情的长方法。

另一方面，可测试的代码倾向于由更小的类和方法组成，具有明确定义的目的。它避免使用全局状态，并使用合理数量的抽象来避免组件之间的紧密耦合。

两者都不是一个全面的定义。它们足够让我在这篇文章的剩余部分抛出术语*可测试代码*和*不可测试代码*。

不可测试的代码是产生已知结果的原因。这些影响包括:

*   更多缺陷
*   修改更加困难，风险也更大
*   最终用户等待新功能和错误修复的时间会更长

相反，可测试的代码会导致这三者的减少。

我希望这至少对一些人来说是令人兴奋的好消息。我刚刚总结的问题不是不可避免的。它们是由原因产生的结果，我们可以控制这些原因。

为什么强调因果关系？因为有时我们理解它们，但不知何故认为它们不适用于某些情况。我们知道不可测试的代码会导致什么结果，但却表现得好像我们不知道。

在这篇博文中，我已经解决了一个这样的案例[。有时我们使用 IoC 容器使我们的代码更易测试，然后我们编写数百行甚至更多的不可测试代码来配置容器。最终，我们发现很难理解组成应用程序其余部分的代码。这是怎么发生的？因为不知何故，我们认为我们的依赖注册代码是我们通常为自己设置的所有规则的例外，所以我们将它放在几个大的方法中，并且我们不为它编写测试。这给我们带来了麻烦，因为没有测试的大型方法就是这样做的。](http://scotthannen.org/blog/2018/04/03/tame-your-dependency-injection-registration.html)

SQL 存储过程是不可测试代码的另一个问题领域。你有没有观察到团队在 C#中可以很小心谨慎，但在 SQL 中却变得很疯狂？这种语言天生倾向于优化而不是其他所有的问题，这并没有什么帮助。我们考虑如何处理单个记录，但是我们必须使用基于集合的操作对其进行编码。我们在内部和外部连接中表达行为，并使用出现在意想不到的地方的内联函数做出关键决策。这使得阅读复杂的代码和理解它做什么和为什么做变得更加困难。

我们不能在 SQL 中避免全局状态，因为表*是*全局状态。当我们被迫重复列的列表时，很难避免紧密耦合，因此在一个表中添加一列或更改数据类型会导致任何涉及它的语句发生级联更改。

有一些[测试框架](https://tsqlt.org/)可以解决这些问题，并且可以将大的过程分解成使用表变量传递数据的小过程。我还没有看到一个团队使用这两种方法。我确信可测试的 SQL 是可能的。我们只是不这么想。

我强调 SQL 存储过程是一个例子，因为它被滥用得很严重，但是我想到了任何一种情况，在这种情况下，我们觉得由于某种特殊的原因，我们必须或者应该编写大量复杂的、不可测试的、未经测试的代码。JavaScript 是另一个例子。在学习如何为它编写单元测试之前，我已经写了很多，并且我已经看到了大量对应用程序至关重要的 JavaScript 却没有一个测试。(没有类型安全的语言难道不需要更多的测试吗？)

鉴于这一原因，只有一个理由可以想象我们将会逃脱有害的影响:也许我们的代码会对我们仁慈。

我们不会那样说或那样想，但这不正是我们所期待的吗？也许我们的 600 行存储过程会表现出同情，意识到我们别无选择，只能这样写，并好心地免除我们的后果。我们代码中深思熟虑的内心独白可能是这样的:

> 这不是你的错。你不可能让我变得更小，更易读，或者给我单元测试，因为我是 SQL。让我给你同样的悲伤和痛苦是不公平的，因为类似的代码在任何其他情况下都会给你同样的悲伤和痛苦。所以我会对你仁慈。我将没有缺点。我是不可理解的，但我将是一个没人需要理解或修改的软件。

这听起来不合理，但这不正是我们希望发生的吗？我们不就是假装因果会给我们通行证吗？

无论是 SQL、C#、JavaScript 还是任何其他语言，编写不可测试代码的整体“单元”的后果是完全相同的。否则的话，就像养了一只灰熊幼崽，并认为它不会像野生的一样把我们咬死。熊不知道是不是野生的。它只是按照它的本性行事。我们的代码不知道为什么会有几百行或者几千行那么长，没有经过测试和不可测试，也不在乎。从周日开始，它会让我们悲伤和烦恼六次。我们最害怕的事情都会发生，然后是一些。

我们可以找到一种方法使其易于管理，或者做出明智的选择来接受风险，但是我们不能指望代码对我们仁慈。