# 通过 TDD 进行软件设计

> 原文:[https://dev . to/jessekphillips/software-design-through-TDD-4mi 7](https://dev.to/jessekphillips/software-design-through-tdd-4mi7)

在我的上一篇文章《超越静态类型》中，我在结尾投下了一枚炸弹，并发明了编译时运行的意识形态设计。但是我并没有真正深入到我的 TDD 问题中去。

有一个[流水账 af 福利](https://apiumhub.com/tech-blog-barcelona/advantages-of-test-driven-development/)。但是这个列表甚至没有提到它有助于生成可测试的代码。你知道吗，如果你想写测试来验证没有依赖的逻辑，你会构建一个不同于直接集成的设计。

现在，这听起来不像是一件坏事。尤其是当耦合了所有那些记录测试时，这些测试允许你理解期望的行为并抛弃代码，仅基于测试重写它。没有人期望这种情况会发生或者有用。

为了消除依赖性，可能需要抽象层，这也是一件好事。抽象会导致样板文件和更糟糕的混淆。 [TDD 是关于设计的](https://blog.jbrains.ca/permalink/tdd-isnt-about-testing-revisited)，但并不强制或检查好的设计。

考虑一下理想的情况，你会定义一个场景，给定一些情况，当一个请求进来时你处于一种状态，然后你会指定想要的结果。编译器会想出如何让这些元素排列起来并构建你的程序。这就是机器学习的逻辑范式。作为程序员，我们不能在这个层次上写代码，因为我们写代码是为了让其他人在这个层次上工作。

这意味着我们必须平衡我们用来扩展代码重用(用于修复和预防 bug)的抽象，同时维护足够的关于计算机正在做什么的信息，以便找到并修复 bug。

这就是 TDD 错误地将测试可读性置于代码可读性之上的地方。单元测试将有助于确信折射器不会破坏行为，但它不会告诉你错误在哪里，当你需要跟踪一个错误时，阅读代码，可能在调试器的帮助下，将会。

我不认为任何人都能够在任何情况下跨所有领域编写通用可读的代码。但是混淆过程以实现可测试性对于代码验证是有害的。我正在阅读您的代码，以找到您遗漏的那些边缘情况和不一致之处，使它对我和您未来的自己都变得容易。

如果你想拥有设计良好的代码，你就要决定你的受众，你的领域，以及更多关于你在现有代码库中实现的特定特性的因素。