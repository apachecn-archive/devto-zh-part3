# openpyxl 的一个小速度问题

> 原文:[https://dev . to/davep/a-little-speed-issue-with-openpyxl-3li 7](https://dev.to/davep/a-little-speed-issue-with-openpyxl-3li7)

*这摘自我今年早些时候写的一篇博文。我在这里转贴了一个版本，以便更好地了解这个网站。*

最近，我需要编写一个代码库来从 Excel 工作簿中加载数据。鉴于我目前做的绝大多数编码都是用 Python 写的，利用 [openpyxl](https://openpyxl.readthedocs.io/) 是有意义的。我写的最初原型代码运行良好，它很快成长为一个成熟的库，将在几个与工作相关的项目中使用。

但是有一件事一直困扰着我...只是没有我预期的那么快。我从中提取数据的工作簿并不是很大，但是读取数据却花费了相当多的时间，当我让代码在一个充满这样的工作簿的目录中尝试时...甚至机器上的风扇也会加速运转。

这似乎不太对。

我做了一点分析，发现代码大部分时间都在深入一些 XML 解析函数的内部。虽然我知道一个`xlsx`文件很大程度上是一个 XML 文档，但对我来说，花费如此多的时间和精力从中提取数据似乎很奇怪。

考虑到我还有其他代码要写，考虑到工作簿解析代码目前“足够好”，我暂时离开了。

但是，几周前，我有了一点空闲时间，决定重游。我对 openpyxl 和速度问题做了更多的搜索，我发现的几乎所有问题都表明，常见的问题是无法以`read_only`模式打开工作簿。这不可能是我的问题，因为我从一开始就在这么做。

最终我在某个地方看到了一个帖子(抱歉，我现在已经把它弄丢了——我会试着再找一遍),该帖子指出，如果你一次读取一个单元格，而不是使用生成器，那么 openpyxl 从工作簿中读取会非常慢。建议是每次你从一个单元格中取出一个值，它必须解析整个工作表直到那个单元格。另一方面，生成器允许在一次解析中访问所有单元。

这对我来说似乎有点不太可能——我本以为代码会缓存解析结果之类的东西——但这也解释了我所看到的情况。所以我决定测试一下。

[`openpyxl-speed-issue`](https://github.com/davep/openpyxl-speed-issue) 是我编写并运行的测试版本，它们绝对显示了逐单元访问与发电机访问之间的巨大差异。

代码是这样的:

```
for row in range( 1, sheet.max_row + 1 ):
    for col in range( 0, sheet.max_column ):
        value = sheet[ row ][ col ].value 
```

*比*慢得多吗

```
for row in wb[ "Test Sheet" ].rows:
    for cell in row:
        value = cell.value 
```

这里有一个时差的例子，在我的 iMac 上看到的:

```
$ make test pipenv run time ./read-using-generators
        1.59 real         0.44 user         0.04 sys
pipenv run time ./read-using-peeking
       25.02 real        24.88 user         0.10 sys 
```

如您所见，逐个单元的方法比生成器方法慢 16 倍。

在大多数情况下，生成器方法无论如何都是最有意义的，在任何其他情况下，我可能会使用它，但从来没有注意到这一点。然而，我需要从中提取数据的工作簿的性质意味着我需要“提前查看”来决定我在做什么，所以更传统的带索引的循环更有意义。

我可以很容易地“修复”这个问题，方法是使用生成器方法构建一个二维的单元格数组，通过生成器获取；所以我仍然可以做我想做的事情*和*从使用发电机中获益。

总结:鉴于我发现很难找到关于我的速度问题的信息，鉴于我看到的一个即席评论表明这并不容易找到，我想我也应该把它都写下来，并[创建一些测试代码的存储库来说明问题](https://github.com/davep/openpyxl-speed-issue)。希望将来会有其他人从中受益。