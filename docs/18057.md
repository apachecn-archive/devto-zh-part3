# 不要试图变得如此干燥，而是每件事都写两遍(湿的)

> 原文:[https://dev . to/wuz/stop-trying-to-so-dry-instead-write-everything-two-wet-5g 33](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33)

作为开发人员，我们经常听到像[“不要重复自己”](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)这样的陈词滥调。我们接受这样的想法，并付诸实践，有时有点过火。

退后一步，评估我们为什么做这些事情是有帮助的。所以今天，让我们来看看干编程的另一种思想。

# [](#dont-repeat-yourself-dry-programming-defined)不要重复自己(干)的编程，已定义

干燥的定义(根据维基百科)是:

> 每一项知识都必须在系统中有一个单一的、明确的、权威的表示。

其中一些可能有点迂腐，但在考虑这类事情时会有所帮助。让我们来分解一下这里的语法部分。

## [](#every-piece)每一块

什么是“每一块”？我们可以永远不重复变量名吗？一个 HTML 实体？

好吧，好吧。所以我们可以毫无问题地重复`<div>`的话，我不认为有人会因此而生气。但是这确实带来了一个问题——我们什么时候决定某样东西已经成为“知识”?在 React 中，一个很好的例子可能是一个组件——但是它是指`PrimaryButton`和`SecondaryButton`还是广义的`Button`类？答案通常被认为是“无论你的组织选择什么”，但是这仍然会给我们选择抽象什么留下一点模糊性。

## [](#knowledge)知识

这又是一个模棱两可的点——我们对知识的定义是什么？考虑使用一些原子类和 React 的样式化按钮元素。如果一个高级开发人员花了 10 秒钟来创建，他们可能不认为这些知识值得抽象。但是对于一个不太了解系统的初级开发人员来说，这些知识可能是一个很好的抽象。否则，他们可能不得不寻找这些类，提醒自己按钮是如何工作的，并找出`onClick`的语法。知识是相对的，在定义中使用它会增加模糊性。

> *更新:*史云光在下面留下了以下评论。我认为那篇文章很好地解释了“知识”应该意味着什么。
> 
> [![xtrasmal profile image](../Images/244e5462f827a5c46fc67243faedbfff.png) ](/xtrasmal) [ Xander ](/xtrasmal) • [<time datetime="2018-12-19T11:46:18Z"> Dec 19 '18 </time> • Edited on <time datetime="2018-12-19T11:46:47Z">Dec 19</time>](https://dev.to/xtrasmal/comment/7jhn) 
> 
> 只是想把这个留给感兴趣的人。
> 
> "干是关于知识，代码复制不是问题."
> [verraes.net/2014/08/dry-is-about-k...](http://verraes.net/2014/08/dry-is-about-knowledge/)

## [](#single-unambiguous-authoritative-representation)单一的、明确的、权威的表述

一个“单一”的代表留下了许多需要。从 devops 工程师的角度来看，单个表示可能就是他们需要部署的整个应用程序。对于前端开发人员来说，这可能是一个组件。对于后端开发人员来说，这可能是一个类或 API 端点上的方法。这条线划在哪里？

我们也有“明确”这个词——但是正如我刚刚指出的，这句话的其余部分定义了更多的模糊性。“权威”是有意义的——你的干代码应该准确地定义它做什么，并忠实于这个定义。然而，这并不明确局限于干代码。

## [](#system)系统

最后，我们有了世界“系统”——这又回到了我们刚才讨论的“单一”陈述。什么是“系统”？在 React 中，它可能是一个组件或 Redux action/component/reduce。在容器化的软件中，我们可以谈论整个容器或者仅仅一个实例。

在一天结束时，DRY all to 通常会促进预优化，这是不必要的，有时实际上会损害您编写代码的能力。有时，修改抽象的组件以适应特定的用例更加困难。你增加了很多复杂性，或者你把那个组件分解成新的东西——这不是超级枯燥的。你不可能在第一天就知道组件的每个用例。

# [](#an-alternative-write-everything-twice-wet-programming)一个替代方案——把所有东西都写两遍(湿)编程

相反，我建议湿编程。对我来说，定义应该是:

> 你可以问自己“我以前不是写过这个吗？”两次，但从来没有三次。

有了这个定义，焦点就从过早的优化上移开了，取而代之的是允许你多次重复类似的代码。这也将焦点转移到了更本能的反应上。它允许您基于您正在查看的确切用例做出决策。如果你正在构建一个 web 应用程序，你可能想把你的按钮抽象成一个组件，因为你会用到很多按钮。但是如果有一个页面有一些特殊的样式(可能是定价页面？)，那么你就不需要太担心抽象出那个页面上的组件。事实上，在这个系统下，如果你需要一个与那个特殊页面相似的新页面，你可以复制/粘贴并修改你需要的代码。然而，当这种情况第三次发生时，是时候花点时间抽象出可以抽象的部分了。

我还想补充一点(湿式和干式编程):

> 你必须评论你的抽象

任何时候你抽象出一些东西，你都是在重新排序你的应用程序的地图。如果你不发表评论来讨论你抽象的原因，你就是在伤害你的团队(和你未来的自己！).

你怎么想呢?这符合你的发展吗？