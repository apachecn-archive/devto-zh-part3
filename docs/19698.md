# 一个关于还没死的 JavaScript 的故事

> 原文:[https://dev . to/areknawo/a-tale-about-not-so-do-dead-JavaScript-FHA](https://dev.to/areknawo/a-tale-about-not-so-much-dead-javascript-fha)

如果你对这个 JS 生态系统感兴趣(鉴于你正在阅读这篇文章——我想你是的)，你一定/应该听说过类似 WebAssembly 或简称 WASM 的东西。据说对于像 C 这样的语言来说，这是一种新的编译格式/语言/标准，因此可以在 web 上自然运行。这个新标准最大的卖点是它的速度。据说比 JavaScript 的速度快了 **X** 倍。

[![via Giphy.com](../Images/492887c32f61299e96f6a6181396a145.png)T2】](https://i.giphy.com/media/lRnUWhmllPI9a/giphy.gif)

这个速度因素对于现代性能饥渴的网络应用和游戏尤为重要。因此，这鼓励了许多有争议的讨论、展示和标题，这并不意外。其中，最受关注的是“ *WebAssembly 和 JavaScript 的死亡*”。哦，我真的很震惊！这是否意味着所有的 JS 开发人员会突然被 C 语言编写人员取代，只有那些懂其他低级语言的人会在这种变化中幸存下来？-开玩笑的！当然不是！

# [](#javascript-is-still-with-us)**JavaScript 仍然伴随着我们**

JS 及其庞大的生态系统不会很快消失。为什么会这样？首先，WASM(目前)是一个 MVP，代表最小可行产品。因此，尽管它确实是可用的跨浏览器标准，但在它被宣布完全完成(或类似的东西)之前，还有许多变化和升级要做。其次，WASM 旨在与 JS 合作(至少目前是这样)，最后——是的——**生态系统**😎；所以 JS 不会去任何地方——每个人(JS 开发者)都满意吗？

[![via Giphy.com](../Images/3e818476cd8a6931518965491aaf18ef.png)T2】](https://i.giphy.com/media/xHMIDAy1qkzNS/giphy.gif)

是啊，太好了！现在，我们已经消除了这个误解...

# [](#lets-talk-performance)**让我们谈谈表演**

是的-表演，但首先是事实。WASM 旨在成为 C 或 Rust 等低级语言的编译目标/格式。Rust 已经提供了这种内置的功能。对于 C(当然还有 C++)来说，它是在 [Emscripten](https://github.com/kripken/emscripten) 项目的帮助下提供的，该项目也允许其他基于 LLVM 的编译语言使用这一功能(信不信由你——有很多这样的语言)。当然，如果你不喜欢这两个解决方案中的任何一个，并且想利用 WASM 的*性能*(稍后会有更多介绍)你可以使用它自己的非常低级的[格式](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format)。所以我们来看看 Emscripten 编译的 C 与 JS 的性能！

[![via Giphy.com](../Images/6c54a87941e759fcc93225a10817b86c.png)T2】](https://i.giphy.com/media/3aGZA6WLI9Jde/giphy.gif)

或者更确切地说，为了保持事情的简单、干净和美好——只要去[这个页面](https://takahirox.github.io/WebAssembly-benchmark/)就可以了，它包含了对 JS 和 WASM 的恰当比较，当然，它是开源的。因为我去过&我已经做过了，下面是一些结果:

***斐波那契***

 *| 结果 | (平均值[毫秒]) |
| --- | --- |
| Java Script 语言 | 711.6200 |
| web 程序集 | 325.7500 |
| JavaScript/web 程序集 | 2.1846 |

结果非常简洁，正如预期的那样——比 JS 提高了 2 倍！

***乘双***

| 结果 | (平均值[毫秒]) |
| --- | --- |
| Java Script 语言 | 2909.2600 |
| web 程序集 | 592.4600 |
| JavaScript/web 程序集 | 4.9105 |

耶- **4X** 提升！现在，让我们尝试一些不同的东西...

***图像回旋***

| 结果 | (平均值[毫秒]) |
| --- | --- |
| Java Script 语言 | 43.3000 |
| web 程序集 | 84.4600 |
| JavaScript/web 程序集 | 0.5127 |

耶- **1/2X** 提升！等等-什么？那**比 JS 减少 50%** ！为什么会这样？好了，女士们&先生们，让我向你们介绍这个问题(如果你们还没有从测试代码中推导出来的话)——C**char**类型。这显然是主要问题。WASM 在处理数字时非常快，但是在处理 JS 字符串的强制类型时就不那么好了。这种趋势在其他使用字符串相关类型的测试中继续，在 Rust 编写的类似基准测试中也是如此。有问题吗？-我不这么认为。汇编(顾名思义)通常更适合与计算相关的操作，这很好。因为 WASM 在高性能游戏中的广告用法是真实的(游戏做许多不同的计算)。在 WASM 用 ASCII 字符数组表示字符串和字符是否会提高我们用 WASM 文本表示法手写的性能，这是有争议的，因为这需要从 JS 字符串转换成 ASCII 数字，需要更多的内存使用，并且会因为不能使用 Unicode 而限制字符串(不知道 Emscripten 如何处理 C 字符)。

# [](#bottom-line-then)**底线然后...**

JavaScript(尤其是在 V8 中)已经被优化到非常非常快。WASM 给我们提供了新鲜的东西。如果你需要在浏览器上执行 CPU 繁重的计算(无论出于什么原因)，那就去做吧。请记住，从 JS 站点初始化 WASM 是非常昂贵的，因为它们之间的通信是非常昂贵的，所以您需要从 WASM 获得的性能收益水平来证明它的其他性能成本。反正就是这样...暂时如此。😁*