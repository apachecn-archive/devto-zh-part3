# 帮我做个神盾局的调查。

> 原文：<https://dev.to/moresaltmorelemon/do-me-a-s-o-l-i-d-4g93>

当我们第一次学习面向对象编程时，我们被灌输一些简单的概念，比如狗是一种动物。但是这些都只是可爱的例子，掩盖了设计面向对象系统的真正困难。

当 OOP 第一次被引入时，它被认为是编写可重用的模块化代码的一种方法。如果我们把所有的东西都清晰地分成整齐的数据组和对它们进行操作的方法，那么我们就可以像对待乐高积木一样对待所有的东西，然后一点一点地建造。然而，有一个潜在的问题:无论最初的设计多么完美，需求都会发展，曾经完美的东西现在已经不够了，必须改变。

那么问题就变成了，T1 要改变多少？我们能不能加几行代码就完事了？我们必须重做一个类吗，或者看着一个快速修复向外蔓延，触及整个代码库吗？

## 语义版本化

在我们进一步讨论之前，让我们简单地讨论一下[语义版本](https://semver.org/)，一个简单的用于指示代码库内影响变化的系统可以是:

*   补丁版本:这些变化是小的错误修正，是向后兼容的，新版本可以用相同的 API 替换以前的版本，没有明显的影响。
*   次要版本:这些变化增加了功能，但保持向后兼容，因为以前的 API 被扩展了，但没有改变。
*   主要版本:所做的更改破坏了与早期 API 的兼容性。任何与 API 交互的代码也必须更新才能正常运行。

虽然语义版本化通常是为应用程序和模块保留的，但是我们可以在代码中更细粒度地应用这个概念。

# 固体

可靠设计的 5 个原则形成了一个策略，用于减少面向对象系统中的变化对主要路径和次要版本更新的影响。

*   单一责任原则:合理地划分代码，使每个模块专注于一项任务。
*   开闭原则:在不修改模块现有接口的情况下扩展功能。
*   Liskov 的替换原则:子类实现其父类的接口和功能，这样它们可以被替换而不改变结果。
*   界面分离:定义一个集中且稳定的界面，并限制界面背后的功能改进的变化。
*   依赖性反转:为了防止紧密耦合的系统，在依赖性和消费模块之间实现抽象接口。

## 单一责任原则

一个类或模块应该专注于一个单一的目的，这样只有当目的改变时，模块本身也应该改变。

不要把功能堆在一个乱七八糟的实用抽屉里，要细分你的类，这样每个类都有一个特定的目的和存在的理由。仔细的细分导致隔离的代码保持稳定和可重用，并减少系统中其他地方的变化的影响。

例如，如果我们将访问后端所需的所有方法和信息放在一个类中，我们很快就会陷入混乱，并且随着需求的变化而不断重构。

```
class AccessBackend {
  userInfo
  jwt
  baseURI
  registerUser: () =>
  authenticate: () =>
  getData: () =>
  postData: () =>
} 
```

相反，如果我们根据目的来划分类，我们现在可以在不影响其他类的情况下改变任何类的实现细节。

```
class User {
  userInfo
  registerUser: () =>
  loginUser: () =>
}

class Authenticate {
  jwt
  authenticate: () =>
  storeJWT: () =>
}

class HttpHandler {
  baseURI
  get: () =>
  post: () =>
  put: () =>
} 
```

好了，词汇时间:

> 共生性:由相互依赖的系统引起的复杂性的量度。一个系统的一致性越强，单个组件改变的影响就越大。

合生这个概念的核心是另外两个概念之间的张力:*耦合*和*内聚。*

把*内聚*想象成一个整洁的工作台。各就各位，各就各位。在一起的东西*就是在一起的*。锤子和钉子放在一起，而钻头和钻头放在一起。执行单一任务所需的组件位于单一空间中。

另一方面，你的工作台*耦合*越多，执行任务*所需的组件*就越多，所以当你想做什么的时候，你必须打开每个抽屉翻找。

但是一个钻头不仅仅使用钻头，钻头可以被多种钻头使用。你越想放进某个抽屉，就越难保持整洁干净。因此，看似简单的事情:把相似的东西放在一起，很快就变成了一项需要仔细思考的任务。

内聚和耦合是同一枚硬币的两面。我们不能把所有东西都放在自己的容器里，也不能把它们都堆在一起。我们也不能完美地划分一个系统，使每个抽屉都有完成一项特定任务所需的所有东西，而不复制里面的东西。

将会有*容器间的耦合和容器内不完美的内聚。当我们对一个容器进行更改时，在某些时候这些更改会影响另一个容器的内容。然而，通过仔细的计划，我们可以降低这种情况发生的频率。*

## 开/关原理

一旦您定义了一组可在类、模块或函数外部访问的功能，并且该功能正在使用中，对其所做的任何更改都将对依赖于它的代码引入潜在的破坏性更改。

当编写旨在重用的代码时，负责任的维护要求尊重您所做的任何更改对他人的影响。特别是在流行的模块中，另一个开发人员与您的代码的交互可能是紧密耦合和细粒度的，包括对错误和糟糕的设计选择的适应。

这种紧密耦合最糟糕的例子之一就是 JavaScript 本身。尽管这种语言有许多缺陷，但由于 JavaScript 深深嵌入现代互联网，解决这些缺陷实际上是不可能的。修复像`typeof null === "object"`这样基本的东西会让数百万个网站瘫痪。因此，JavaScript 语言的开发侧重于在尊重现有 API 的同时扩展该语言。

类似地，当你继续构建你自己的代码时，要留意任何突破性的变化。避免它们，如果您不能阻止它们，战略性地选择它们的发布时间，这样下游开发人员就不会为了保持兼容性而不断地被迫重构。

## 利斯科夫的替代原理

利斯科夫的替代原理变得有点奇怪，所以请继续关注我。首先我们需要谈谈类型和类型签名。

类型实际上是对一组特定的属性如何交互的一组期望。在底层，我们有像字符串或数组这样的数据类型，可以用像`+`这样的操作符或像`.concat()`这样的方法来操作。但是在更高的层次上，我们可以定义自己的复杂类型。

```
type User {
  name: string;
  address: string;
  greet: (person: User) => User;
} 
```

上面的声明告诉我们，如果我们遇到 User 类型的数据结构，它应该具有已定义的属性。类似地，方法`greet`的类型签名表明它期望一个用户类型的输入，并将返回一个用户类。

如果我们将一个包含一组数据和方法的类定义为*类型*，并且如果我们将一个继承自该类的类定义为*子类型*，那么，因为子类型实现了超类型的功能，我们可以用子类型替换超类型，并且我们的程序将继续运行而不会出现问题。

```
type User {
  greet: (person: User) => string;
}

type Moderator extends User {
  greet: (person: User) => string;
  promote: (person: User) => Moderator;
}

type Administrator extends Moderator {
  greet: (person: User) => string;
  promote: (person: User) => Administrator;
  ban: (person: User) => User;
} 
```

因为子类型可以代替它的父类型，所以保持与它的方法可能作为参数接收的类型的兼容性是很重要的。例如，管理员的`promote`方法只要求给定的人与用户类型兼容，这意味着管理员类可以被版主类正确地替代。

因为子类型与父类型是兼容的，所以我们不需要返回父类型。相反，由于我们在子类型中扩展了功能，我们可以返回子类型。

> 词汇:
> 
> *   逆变:超类型正常，类型正常，子类型不正常
> *   协方差:超类型不正常，类型正常，子类型正常

为了保持子类型之间的兼容性，我们需要遵守一些规则:

*   子类型上方法参数的*逆变*:从超类型继承的方法应该接受与超类型的方法相同的类型。
*   返回类型的*协方差*:子类型的方法的返回类型不能是超类型，而应该是子类型。
*   任何抛出的异常都应该是超类型抛出的异常的子类型。错误处理系统应该与替换的子类型保持兼容。

子类型的方法应该能够接受与超类型相同类型的输入，但是应该返回超类型的返回类型的子类型。呀。让我们重新表述一下*和*。

```
class SuperType {
  method: (input: InputType) => ReturnType;
}

// ok
class SubType {
  method: (input: InputType) => SubReturnType;
}

// not ok
class SubType {
  method: (input: subInputType) => SubReturnType;
}

// not ok
class SubType {
  method: (input: subInputType) => ReturnType;
} 
```

Liskov 的替换原则有一个最终的结果:因为类型必须可以被它的子类型替换，所以子类型必须完全实现超类型。如果一个子类型没有实现完整的父类型，那么我们需要重新考虑是否父类型的所有属性实际上都属于层次结构中的那个级别。

我们可能需要改变层次结构，以便超类型只实现所有子类型之间的所有共享属性，并且进一步共享它们自己的属性集的子类型集合从它们自己的共同祖先继承。

```
class Bird {
  fly: () =>
}

class Seagull extends Bird {
  fly: () =>
}

class Penguin extends Bird {
  // fly: () =>
} 
```

虽然我们通常认为飞行是鸟类的核心属性，但它并不为所有人所共有，而且与生物学不同，利斯科夫的原则并不关心血统，而是关心兼容性。

相反，我们可以插入一个鸟的子类型，它引入了`fly`方法，并由所有飞行的鸟共享:

```
class Bird {}

class FlightfullBird extends Bird {
  fly: () =>
}

class Seagull extends FlightfullBird {
  fly: () =>
}

class Penguin extends Bird {} 
```

## 界面偏析

接口决定了我们如何与模块内部交互。它们可以提供一定程度的抽象，以及通过控制如何访问模块来提供保护。

一个模块并不局限于单个接口，事实上您可以选择定义多个接口，每个接口都面向一个单独的目的，改变模块的哪些方面可以通过每个特定的接口访问。

## 依存倒置

面向对象编程保证了代码的简单重用，然而可重用代码的问题是所有的代码都被重用。

除非一个模块被编写成显式无依赖，否则它将有依赖，而依赖又可能有自己的依赖，等等。这些依赖项都与特定的版本相关联，升级一个版本可能会引入细微的错误或完全破坏下游消费者的功能。我们很容易会遇到这样的情况，我们的依赖关系树包含了对同一个模块的不同版本的多个引用。

虽然消除所有的依赖关系是不现实的，但是我们可以通过颠倒典型的方法来降低消费模块和我们所需要的依赖关系之间的耦合程度。

我们没有在模块中直接引用和利用依赖项，而是定义了一个抽象接口，而不考虑模块和依赖项中实现的实际细节。该接口充当两者之间的翻译器，并将实现的外部细节本地化为根据项目的抽象需求定义的单个内部可控接口。

固体，换句话说:

*   分离依赖关系。定义良好的模块不应该与它们的依赖项直接交互。相反，在它们之间定义抽象交互细节的接口。
*   保持 API 的一致性和稳定性。在 API 后面重构。
*   沿着重构的路线划分。期望扩展和重构，并相应地对模块的内容进行分组。每个模块应该有一个单一的目的，只有修改的目的应该需要改变。
*   扩展超过修改。在不修改现有功能的情况下构建现有功能，使现有功能的消费者不受影响。