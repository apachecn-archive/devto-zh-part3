# 如何正确进行功能测试

> 原文:[https://dev . to/杂耍 thebits/how-to-get-functional-testing-right-34aj](https://dev.to/jugglingthebits/how-to-get-functional-testing-right-34aj)

在软件开发中，没有比自动化测试更能让我学到新东西的话题了。*我合作过的每个*团队都讨论过测试:

*   测试应该在多大程度上影响被测试的代码本身？
*   应该测试什么？
*   高测试覆盖率重要吗？
*   该做多少嘲讽？

我可以很容易地继续这个列表。

由于测试是所有软件开发的相关主题，所以应该有许多(大多数)推荐的实践。)同意。例如，TDD 似乎就是这种情况，它至少被许多人认为是好的实践(尽管不经常遵循)。然而，TDD 并没有告诉你从哪种测试开始。

例如，假设您想要扩展一个待办事项列表管理 web 应用程序，以便用户可以为他们的待办事项列表选择一个图标。您是否从端到端(e2e)测试开始？如果是这样的话，你需要额外的 api 测试吗，因为 e2e 测试已经包含了这些测试？如何测试 http(s)错误代码？你会在这样的测试中嘲笑业务逻辑吗？您会将 todo list api 背后的业务逻辑作为 http(s)测试的一部分来测试吗，或者您会编写额外的单元测试吗？

我多次看到有人推荐的一个指南叫做“测试金字塔”([https://testing . Google blog . com/2015/04/just-say-no-to-more-end-to-end-tests . html](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html))，指的是一种上薄下厚的金字塔式测试分布。建议少做 e2e 测试，多做集成测试，多做单元测试。

然后是“测试奖杯”([https://kentcdodds.com/blog/write-tests](https://kentcdodds.com/blog/write-tests))，提议主要依靠集成测试而不是单元测试，因为这些测试将为投入的工作交付更多的价值。

我觉得这个建议有问题。首先，*给出的为什么*这些分布被认为是好的理由是非常无力的。虽然有人说 e2e 测试通常比单元测试运行得慢(因为它们覆盖了更多的代码)，但是没有人认为单元测试比集成和/或 e2e 测试多是一件好事。如果你正在构建的 app 业务逻辑很少，UI 流很多怎么办？那为什么有很多单元测试呢？

然而更重要的是，无论是“测试金字塔”还是“测试奖杯”都没有告诉你在实现一个特性时应该使用哪些测试。毕竟，它们是度量的虚拟化(例如，“单元测试的数量”与“集成测试的数量”)，因此只能在一个特性被构建之后*应用。它们在实现一个特性所需的细节层次上是不可操作的。*

因此，测试金字塔和测试奖杯都没有回答这个问题:当我实现一个特性时，我应该写哪些功能测试？

我没有依赖直觉或“最佳实践”(根据我的经验，在测试中并不多见)，而是发现了一些可操作且易于理解的指导方针。我试着跟随他们(对于*网络应用*和*http(s)API)*，他们让我决定测试什么变得相当容易。

他们在这里:

*   当你实现**业务逻辑**或**公共助手功能**时，编写测试，独立运行方法的特定功能。嘲笑其他一切。测试被测试函数或方法的结果是否符合你的期望。在这里使用任何单元测试库。
*   当您实现一个 **http(s) api** 时，编写执行 http(s)客户端请求的测试。模仿你所需要的一切来使测试健壮和快速。测试您得到的 http(s)响应是否符合您的预期。这里使用任何单元测试库和 http(s)请求库。
*   当您为第三方服务实现一个**客户端时，编写执行对该第三方服务的调用的测试。检查结果是否符合你的期望。使用任何单元测试库。考虑仅在夜间运行这些测试，因为它们依赖于第三方服务的稳定性，有时可能会失败。**
*   当您在 UI 中实现一个流程时(“**快乐路径**”)，编写一个测试来执行这个流程，通常称为“快乐路径”。需要时模仿第三方服务和您自己的 api。使用 UI 测试库。有了 Cypress 和 TestCafe，web 开发人员终于有了一些好的选择。
*   当您在 UI 中实现新的**控件或表单**时，编写修改这些控件或表单的测试。模仿所有其他东西(例如 http(s)请求、导航、第三方服务)以尽可能减少碎片。这里也使用一个 UI 测试库。

除了可操作性之外，这些指南还有其他一些优点:

1.  它们可以用作代码审查的检查表。当您知道实现了哪个特性时，您可以对照编写的代码检查列表中的每一项。当您看到属于上述类别的代码，但是缺少该类别预期的测试时，您可以明确地指出缺少什么。
2.  他们确保测试是在适用于每个类别的最低抽象层次上编写的。这使得每个测试中使用的依赖项的数量尽可能的少，这有助于保持测试的快速和健壮。
3.  它们非常适合 TDD 风格的开发。当你正在实现一个特性并且已经决定了架构(哪些 API 需要改变，使用哪些第三方服务等等)。)，然后您可以使用指南来决定从哪个测试开始。特征本身自然会随之而来。
4.  他们避免了不得不坚持“单元测试”、“集成测试”和“e2e 测试”以及类似的模糊的和超载的术语。相反，您可以使用上面的术语，如“业务逻辑测试”、“http-API-测试”或类似的术语，这对于测试什么会更清楚。测试框架是关于“单元测试”的事实将是一个实现细节。
5.  它们确保了高覆盖率，不会遗漏代码库的任何大部分。我的经验是，它们通过减少嘲笑和关注测试结果而不是实现来促进重构。

除了这里使用的 web 应用程序和 http(s)API 之外，我对这种代码分类如何应用于其他领域很感兴趣。此外，这篇文章只关注功能测试，根据我的经验，这是大多数应用程序最重要的测试类型。将这个列表扩展到其他类型的测试，比如性能和安全性，会很有意思。