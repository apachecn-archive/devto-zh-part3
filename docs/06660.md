# 了解 AWS 弹性 Beanstalk 工作超时

> 原文:[https://dev . to/rizasaputra/understanding-AWS-elastic-beanstalk-worker-time out-42hi](https://dev.to/rizasaputra/understanding-aws-elastic-beanstalk-worker-timeout-42hi)

如果你以前从未听说过，AWS 有这个编排服务叫做 Beanstalk。基本上这意味着，不用手动设置 EC2 实例、负载平衡器、SQS、CloudWatch 等，您可以使用这个 Beanstalk 来编排设置。你所需要做的就是压缩你的代码(或者如果你使用 Java 的话打包它)，上传压缩文件，然后在一个集中的仪表板上做一些设置，你就完成了。如果你不需要对你的设置有很好的控制，这真的可以帮助你快速得到一个运行的系统。

AWS Beanstalk 提供了两种类型的环境:Web 服务器环境和工作环境。在 Web 服务器环境中，您将获得一个配置了您的平台选择(可以是 Java、Node JS、Docker 等)的服务器，并且您还可以轻松地设置一个负载平衡器。在工作环境中，您可以使用服务器和 SQS 消息平台来运行繁重的后台作业或计划作业。在这篇文章中，我将重点讨论工作环境。

Beanstalk worker 实例有一个守护进程，它持续监听 SQS 队列。每当检测到队列中有消息时，守护程序将在本地向端口 80 上的 [http://localhost/](http://localhost/) 发送一个 HTTP POST 请求，请求体中包含队列消息的内容。您的应用程序需要做的就是执行长时间运行的任务来响应 POST。您可以将守护程序配置为发送到不同的 URL，连接到现有队列，并配置超时。

您可以从 worker environment dashboard 中配置 3 种基本超时:

**1。连接超时**

这是当我们尝试与应用程序建立新连接时，我们希望等待应用程序的秒数。该值介于 1 到 60 秒之间。

**2。不活动超时**

这是我们允许应用程序进行处理并返回响应的秒数。您可以指定 1 到 36000 秒之间的值。

**3。可见度超时**

这是返回队列之前锁定消息的秒数，您可以将其指定为 1 到 43200 秒之间的值。我个人感觉这是比较混乱的部分，我尽量解释一下。

当守护进程从 SQS 队列中读取一条消息时，它将向您的应用程序发送 POST 请求。如果您的应用程序能够处理请求并在不活动超时内返回良好的响应(例如 HTTP 200)，那就太好了。整个处理完成后，消息会自动从队列中删除。

但是，如果您的应用程序未能在不活动超时期限内给出响应，消息将被发送回 SQS，并在可见性超时达到后重试，该超时从您的应用程序开始处理消息的时间开始计算。

例如，假设您将非活动超时设置为 30 秒，将可见性超时设置为 60 秒。然后，您在 10:00:00 向队列发送一条消息。在 10:00:30，如果您的应用程序在 30 秒后不能给出响应，守护程序会将请求标记为失败。在 10:01:00，60 秒后，守护程序将把消息重新抛出到队列中，整个过程将重复进行，直到达到最大重试次数设置(默认为 10 次)。

现在，如果你的应用程序需要 45 秒来完成上面例子中繁重的后台处理会怎么样呢？在这种情况下，在 10:00:00，请求将被触发，处理开始。在 10:00:30，守护进程会将处理标记为失败，**，但是实际的处理仍然会在后台继续进行**。10:00:45 你的应用程序终于给出了响应，但是没有人在听响应。在 10:01:00，消息返回到队列中，重复整个繁重的处理过程，即使它实际上是成功的。因此，您需要将非活动超时和可见性超时设置为相对于预期应用程序处理时间的安全值，并使这两个值保持相对接近。AWS 的默认设置将非活动超时设置为 299 秒，可见性超时设置为 300 秒，仅相差 1 秒。

另一件你需要注意的事情是确保你设置的可见性超时高于不活动超时。现在，考虑这个例子:

您将非活动超时设置为 60 秒，将可见性超时设置为 30 秒。你的应用需要 45 秒的处理时间。在这种情况下，当处理时间达到秒 30 时，消息将在队列中再次可见，然后自动被您的服务器再次使用。你的服务器在实际上不必要的时候完成了双重工作。

唷！现在，我们应该能够正确配置我们的工作环境以避免超时。但是，当 Nginx 配置攻击时，一切都变了。

## [](#nginx)Nginx

如果您在 worker environment 平台上使用 Node JS，AWS 将提供 Nginx 作为实际客户端和您的应用程序之间的代理。Nginx 引入了另一层超时，默认是 60 秒(我觉得，从来没有真正检查过，抱歉)。现在让我们来举例说明这可能会给你带来什么问题。

假设您的应用程序需要 120 秒来处理，并且您已经将可见性超时和不活动超时设置为某个安全的值，例如 300 秒。当一个请求在 10:00:00 开始被处理时，在 10:01:00 Nginx 会抛出超时。守护进程会将此信号视为文字错误，因此不会从队列中删除消息。与此同时，**你的应用程序将继续在后台处理请求**，直到它达到 120 秒，并向任何人呼喊响应，因为守护进程不再监听。当我们到达 300 秒时，整个过程又重复了一遍。

有一种简单的方法来区分您的超时是由不活动超时还是 Nginx 超时引起的。您可以在`/var/log/nginx/access.log`从 worker 环境中获取 Nginx 访问日志。然后，您可以从应用程序处理的请求中检查 HTTP 响应状态。如果状态为 499，这意味着您的应用程序达到不活动超时。然而，如果 HTTP 响应是 504，那么您的应用程序很有可能达到 Nginx 超时限制。

好吧，所以，我们也需要延长 Nginx 超时。然而，延长 Nginx 超时不像其他超时那样容易，因为您不能从 AWS 控制台完成。您可以 SSH 到您的 worker server 实例并直接更改配置，但是在这种情况下，每次您的服务器重建时，您都需要手动应用配置更改。有更好的方法。

您可以在应用程序源代码中添加一个文件夹，并将其命名为`.ebextensions`。您需要按原样命名它，并且不能用其他名称命名该文件夹。在文件夹中，添加一个文件，并将其命名为`nginx_timeout.config`。您可以随意命名该文件，但是最好有一个描述性的名称。关于文件命名的一个要点是，文件必须以`.config`扩展名结尾。在那个文件里面，你可以简单地直接复制粘贴这个:

```
files:
  /etc/nginx/conf.d/timeout.conf:
    mode: "000644"
    owner: root
    group: root
    content: |
      proxy_connect_timeout 300;
      proxy_send_timeout 300;
      proxy_read_timeout 300;
      send_timeout 300; 
```

它所做的只是创建一个文件`/etc/nginx/conf.d/timeout.conf`，Nginx 默认标准配置会自动读取这个文件。该文件规定各种 Nginx 超时值应该是 300，而不是标准配置中的任何默认值，就是这样！现在，我们的工作环境应该可以消化所有繁重的处理任务，而不会超时。