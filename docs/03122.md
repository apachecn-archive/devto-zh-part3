# 展开组件管道

> 原文：<https://dev.to/matsp/spreading-pipelines-of-components-1969>

*这篇文章是我的[博客](https://www.matspfeiffer.dev/blog/2019-05-15_spreading-pipelines.html)的交叉文章。*

...给你的浏览器像凹透镜一样会传播光线。把这句话记在心里，发完帖子再来这里。

如果你现在想知道我到底在说什么，你绝对是对的。用这句话我想解释我的想法的主要概念，用[凹](https://github.com/concave-org/concave)构建一个单页面应用程序——一个微小的 JavaScript UI 框架。

## 又一个 JavaScript UI 框架？

是...在阅读这篇文章之前，请随意离开，因为这是当今技术争论的主要模式。如今的一切都必须用顶尖的 UI 框架/库来构建。有很多关于主要产品的宣传，原因很明显:用复杂性赚钱。有课程、视频、教程、工作坊、会议、播客、youtube 频道等等。人们赚钱是为了解释背后的概念，因为有些时候太多了，不是每个员工都能跟进。这个行业的存在对我来说没问题，但我不同意盲目追随或宣传一种黄金方法，这将导致错误领域的复杂性。我在网络平台上经常看到的是，人们首先选择**工具**，然后调整他们面临的问题以适应它。

## 我的动力

我是一个真正致力于性能优化的人，并试图从某些事情中获得最大收益。有趣的是，我发现了自己内心深处的动力，并对最终的结果感到非常惊讶。我想用一些简单易懂的概念创造一些简单的东西。框架应该附带电池，这样开发者只需要一个依赖项。它应该可以在现代浏览器中直接使用，以允许在沙箱中进行原型开发。最重要的一点是只使用**平台**并尽可能简单地保持潜在的捆绑器构建过程。

“好了好了...这一切已经存在了！”也许是，也许不是。我想要构建的是一个没有依赖关系的框架，并且用现代的普通 JavaScript 实现。它应该拥有我构建一个功能性 SPA 所需要的一切——这意味着它至少需要一个路由器(内置)，最终需要一个管理应用程序状态的存储(内置)和一些将代码组织成组件的架构指南。

我告诉过你我有一颗在网络上表演的心，所以我给自己定了一个目标，在 1 KiB 内达到这个目标。

**剧透**:我错过了目标，但也不远了。

有时候有一个不切实际的目标是好的，因为它迫使你以不同的方式思考和行走。这不正是我最初想要达到的目标吗:探索新的想法来面对一系列问题，而不是盲目地跟随主流。

## 框架:凹面

以下是关于[凹](https://github.com/concave-org/concave)的一些关键事实

*   **声明性** -组件由一个 ES6 模板标签函数支持，可以轻松定义模板
*   **反应式** -组件将根据状态变化自动更新&重新渲染
*   **内置电池** -状态管理&路由器内置，无任何依赖性
*   **最小** - < 1.5 KiB 最小&gzip 无依赖 ESM 模块

让我们从一个无聊的 Hello World 开始:

[https://codesandbox.io/embed/6nv5q4n8m3](https://codesandbox.io/embed/6nv5q4n8m3)

如果你想要一个纯粹的浏览器体验，试试这个 [CodeSandbox](https://codesandbox.io/s/github/concave-org/codesandbox-esm) ，它只使用本地 es 模块。

### [概念](https://github.com/concave-org/concave#concept)

主要概念是由一系列函数组成，这些函数将由动作(普通的 JavaScript 对象)控制。如果你熟悉函数式编程的概念，那么你会发现 concave 中的流水线和 FP 中的`pipe`函数的结果是一样的。

有以下预定义的工厂函数，它们将返回准备使用的管道函数:

*   `createStore` > >创建一个存储管道功能
*   `createRouter` > >创建路由器管道功能
*   `createRenderer` > >创建渲染器管道函数
*   `createComponent` > >创建一个组件管道功能

它们将由返回函数管道的`createPipeline`组成。如果您愿意，也可以用`createPipeline`组成管道。如果您想组合应用程序的不同部分，这可能会很有趣。

使用`runPipeline`启动管道，第一个动作(状态)将流过函数。

通过所有这些组合函数，动作将被传递来控制您的应用程序。

例如,`state`动作——当一个组件接收到这个动作时，它会检查是否需要更新自己，如果需要的话，它会在管道上触发一个渲染动作。

这个简单的概念导致:

*   单向动作流程>>时间旅行&易于调试
*   纯组件>>预测渲染结果
*   单一来源的真实存储>>只有状态缩减器可以修改状态

### 内部构件

凹面在内部使用了非常幼稚的渲染方法。如果一个组件使用了一个存储在状态中的属性，并且这个属性改变了，那么你的整个组件将会被新的替换。这听起来像一个可怕的主意不是吗？事实是，对于我到目前为止构建的每个示例来说，这都没有问题，但我不是傻瓜:这种渲染方法对于具有大量数据交换的真正大型应用程序来说并不适合。这没关系，因为它不是为这种情况而构建的。它专为快速启动和减少资产预算而打造。请记住，你不必考虑*为什么*、*为什么不*、*什么时候*和*什么时候不*你的 UI 就会更新。总是同样的行为——幼稚，简单，管用。

### 什么时候用凹？

试用凹板的有效用例:

*   中小型水疗中心
*   静态 spa(例如投资组合、博客、附带项目)
*   渐进式网络应用(PWAs)
*   引导大型 web 应用程序
*   能够找到自己架构的小团队

不要使用凹面:

*   具有大量反应数据的 spa
*   有很多动画的应用程序(重新渲染最终会触发它们)

## 接下来是什么

这篇文章是对凹板的一个快速介绍。如果你对更多细节感兴趣，可以查看一下 GitHub 的库，在那里你可以找到更多关于内部的信息。

我刚开始用凹板建立我的作品集，可以随便看看。我将很快填充更多的数据，对凹板的性能有一个概念。

如需更新、后续帖子或讽刺性推文，请在 Twitter 上关注我！

感谢所有读到最后的人！这是我在 dev.to 上的第一篇帖子，所以我将感谢任何反馈或评论:)

## 链接

*   [凹面@GitHub](https://github.com/concave-org/concave)
*   [me@GitHub](https://github.com/matsp)
*   [我@推特](https://twitter.com/matspfeiffer)
*   [公事包](https://www.matspfeiffer.dev) <公事包<带凹盖