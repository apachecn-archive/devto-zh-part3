# NodeJS 中的非原子增量或者我如何发现 express-brute 包中的漏洞。

> 原文：<https://dev.to/animir/non-atomic-increments-in-nodejs-or-how-i-found-a-vulnerability-in-express-brute-package-1ncj>

**TLDR:** 使用 [ExpressBruteFlexible](https://github.com/animir/node-rate-limiter-flexible/wiki/ExpressBrute-migration) 从易受攻击的 express-brute 软件包中迁移。

我的目标是提供统一的包[速率限制器-灵活的](https://github.com/animir/node-rate-limiter-flexible)来管理具有灵活选项和 API 的过期增量，因此任何与计数过期事件相关的任务都可以用一个工具完成。

几个月前，我在 github 上寻找有用的功能。有一些好的软件包有类似的目的，我浏览了它们的特性和问题。有时，开放甚至封闭的问题包含有趣的想法。express-brute 有几个未解决的问题。

## 检查两次。然后再一次。

当我读到一个标签标题[时，带有独特声音的警告橙色灯已经打开，全局暴力计数没有更新超过 1000 个并发请求](https://github.com/AdamPflug/express-brute/issues/46)。

> 一旦所有的 1000 个请求都完成了，express brute store 中的计数就不会增加到 150 以上。

我在 npm 上查看了 express-brute 的下载次数。这个数字不小:每周超过 2 万次下载。这个问题是两年多前提出的。“好吧，我相信那些用户”，-我想，然后关闭了浏览器的标签。过了几天我又打开那张票，决定自己测试一下。

## 原子级递增。尤其是在异步环境中。

我想让你多了解一下快递-蛮包。它计算请求的数量，然后根据选项，在几秒钟内允许或禁止请求。最重要的选项是`freeTries`，它限制了允许的请求数量。如果开发人员设置 5，它应该计算 5 个请求，然后在某个时间窗口内允许第 6 个请求并停止第 7 个、第 8 个请求，等等。它按用户名或用户名和 IP 对计算请求数。这种方式可以防止暴力破解密码。

您还应该知道，express-brute 实现了 get/set 方法来计数事件。它可以在几个著名的数据库中存储数据。流程如下:

1.  根据请求从存储区获取计数器数据。
2.  检查一些逻辑，检查限制，比较到期日和当前日期等。
3.  根据第二步的结果设置新的计数器数据。

你可能已经明白了。如果我们的应用程序处理 1000 个并发请求，一些请求将不被考虑，因为集合操作会覆盖前面的集合。这就清楚了，为什么有人在商店里看到的是 150 而不是 1000！更慢的数据库，更多的请求可以在无形中完成。应用程序中的线程或进程越多，覆盖的 Set 查询就越多。

但这还不是全部。NodeJS [事件循环](https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/)使得它更加脆弱。让我们看看一个 NodeJS 进程会发生什么:

1.  Get 查询已发送到存储区，但尚未收到结果。I/O 回调在事件循环级别排队。它可能在队列中不止一个事件循环滴答等待来自存储结果。在此期间，可能会有更多从存储中获取数据的请求。那些 I/O 回调也在排队。
2.  比方说，第一次获取需要 10ms。现在我们的 NodeJS 流程已经准备好计算结果了。但是对于在 10ms 时间窗口内发出的请求，它还会得到另外九个 Get 结果。并且所有这些 Get 结果都具有相同的计数器值，准备被递增和设置。
3.  数学制造。太棒了。计数器递增。集合查询被发送到存储。同一值连续设置了 10 次。数的是 1 而不是 10。

对后果感兴趣？

## 停止理论，给我们实数。

首先，我在本地复制了它。但是局部测试并不惊艳。它们不是真实异步网络世界的反映。“好吧，让我们尝试一些有趣而真实的东西”，我想。我发现 [Ghost 开源项目](https://ghost.org)使用了 express-brute。我很高兴能对他们的服务进行实验。老实说，没什么坏处。

收据很简单:

1.  通过一定数量的请求加载事件循环。如果有很长的 I/O 队列，应该会很慢。我启动了一个小工具，每秒发出 1000 个请求。
2.  瞬间尝试 1000 个密码。

我用的是来自其他大陆的移动互联网和一台有八个 CPU 内核的笔记本电脑。我试了 14 次密码，而不是 5 次。(**编辑:**后来我实际上可以尝试 216 次，而不是 5 次。)“唷，这没什么，罗马人”，-你可能会想。它允许在 10 分钟内再做 5 个。然后 10 分钟内 5 次，20 分钟内 5 次，依此类推，使用默认 Ghost 设置。第一天从一台笔记本电脑通过移动互联网进行大约 60 次尝试，有很大的延迟。1000 台计算机每天会进行 60000 次密码尝试。

10 分钟是 Ghost 项目中默认的最小延迟。express-brute 设置的默认最小延迟为 500 毫秒，最大延迟为 15 分钟，可免费尝试 2 次。我没有测试，但它允许每天从一台电脑上进行大约 500 次密码尝试。这不安全！尤其是，如果这次袭击是一个更大计划的一部分。

## 这不仅对银行很重要

用户倾向于在多个服务中使用同一个密码。如果你觉得你的应用对黑客来说没什么意思，那你可能就错了。黑客可以利用一个服务的弱安全性来增加攻击另一个服务的可能性。

## 我们没有空闲时间来修复它！

我让它在几分钟内迁移。有 [ExpressBruteFlexible](https://github.com/animir/node-rate-limiter-flexible/wiki/ExpressBrute-migration) 中间件。它有相同的逻辑、选项和方法，但它与建立在[限速器灵活](https://github.com/animir/node-rate-limiter-flexible)包之上的原子增量一起工作。

迁移起来很简单。

[![Example of migration](img/90a7c58e0fd5a1046b04e93fcf63063e.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--cfwCDuMa--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ttno0t6gvrb807qftnvy.png)

如果你有任何问题或故事要说，我很乐意聊天或倾听！