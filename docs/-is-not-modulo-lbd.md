# %不是模

> 原文：<https://dev.to/nichartley/-is-not-modulo-lbd>

> **注意**:这个帖子实际上并不适用于所有语言。只有他们中的许多人。要查看它是否适用于您选择的语言，请检查`-4 % 3`是否等于`-1`。如果是`2`，你的`%`其实就是模。如果你有别的发现，告诉我，因为我很好奇！

你可能在几个地方看到过`%`的用法。也许有人在某个范围内产生了一个随机数:

```
rand() % max 
```

或者循环遍历一个数组:

```
index = (index + 1) % array.length; 
```

你可能也听说过这叫做“模”。如果你了解模运算，乍一看，它似乎也很准确。但是它...不完全是。这种差异可能看起来无关紧要，但是如果您发现自己在实现任何使用真正的模运算的数学时，这是非常重要的。

# Vocab

首先，快速词汇课:

A / B = C 的意思是“A 除以 B 等于 C”。a 是除数，B 是被除数，C 是商。如果我提到“除法”而没有具体说明，在这篇文章中我指的是整数或 floored 除法。那是当你做除法时，没有记录小数部分(例如，14 / 5 是 2，而不是 2.8)。

好吧，这样就行了...

# 什么是`%`？

`%`获取整数除法的余数。如果你认为整数除法是将许多对象平均分成若干组，那么余数就是剩下多少个对象。例如，14 / 5 是 2，因为这 5 个组中的每一组可以有 2 个对象，还有 4 个对象不能被平均拆分到这些组中。

或者，更数学地说，余数是除数与被除数和商的乘积之差。比如 14 / 5 是 2，那么余数就是 14 - (2 * 5) = 4。

为了清楚起见，我将使用“rem”作为操作符来指定我想要得到除法的余数。所以，比如说，`14 rem 5`就是 4。

> **注意**:获取余数很少像在实际硬件上那样实现。不过，效果是一样的，所以我将把它留到以后再说。

# 什么是模？

模，或称模运算，有一点不同。首先，这不是手术。这更像是一个做数学的系统。这就像普通的算术一样，但是每当你执行一个操作时，它都包含在 a 中，范围是从零到所谓的“模数”。

这可能有点技术性和抽象，所以考虑一下告诉时间。无论你使用 12 小时制还是正确的 24 小时制，想想 1:00，刚过午夜。现在想想两小时前是什么时间。不是-1 点，不是 11 点就是 23 点。或者，反过来说，你不会在 12 小时内从 11:00 到 13:00，或者在 24 小时内从 23:00 到 25:00。相反，你*绕过*，当你经过终点时，回到范围的起点——从 0 到 12 或 24——或者当你回到起点后面时，回到终点。

在数学中，因为它是一个算术系统，模通常被用作整个方程的一种修饰语。然而，在编程中，重新定义算术如何为单个表达式工作并不容易(至少在大多数编程语言中不容易)，所以它被用作运算符。要使用之前 24 小时制的时间示例，`25 mod 24 = 1`。

你可能想知道当你绕回时，如果你仍然在范围之外会发生什么。比如什么是`14 mod 5`？如果你只是包装一次，那么你得到 9，这仍然在范围之外。在这种情况下，您只需继续换行，直到 4，其中*是范围内的*。

# 如此...有什么区别？

到目前为止，我只对除数和被除数使用正整数。在这些条件下，余数和模执行相同。我不会在这篇文章中讨论所有的实数，因为在编程中，余数和模运算几乎总是与整数运算一起使用。

但是仍然有很大一部分我只是...还没覆盖:负数。那么那里的情况有什么不同呢？

好吧，让我们从最简单的情况开始。回到时钟的例子，什么是-1 rem 24 和-1 mod 24？

余数很容易计算。-1 / 24 是 0，所以差是-1。

模数也很简单。-1 小于 0，所以绕回 23。

如果我们使用负的模数，同样的问题会发生，但是反过来。12 / -5 是-2，所以 12 rem -5 是 12 和 10 的差，即 2。然而，将 12 包装在 0 到-5 的范围内并不能得到一个正数，事实上它给出了-3。

有了两个负数，一切又恢复正常。-12 雷姆-5 和-12 mod -5 都是-2。

# 我怎么修？

你可能已经注意到了余数和模之间的区别。具体来说，当有一个差时，它总是正好是除数。还有，如前所述，除数和被除数是不同的符号。这两个都可以证明是正确的，但我不会在这里进入实际的数学-只是相信我的话。

这使得修复相当容易。首先，检查`%`在你的语言中是余数还是模。它很可能是余数，但也有一些大的余数，比如 Python，它是模的。通过使用我在上一节中使用的任何示例，并查看您得到的答案，您可以非常容易地做到这一点。

如果你的语言的`%`是一个余数，那么很可能有一个标准的库函数来做模运算。如果不是，这里有一个 C 函数来做基于余数的“实数”取模:

```
int mod(int dividend, int divisor) {
  if (dividend == 0) return 0;
  if ((dividend > 0) == (divisor > 0)) // if they're the same sign
    // then remainder is the same as modulo
    return dividend % divisor;
  else // otherwise, if they're different signs
    // account for the difference
    return (dividend % divisor) + divisor;
} 
```

> **注意**:零必须是特殊情况，因为无论你用哪种方式检查符号(无论是正的还是负的),它总是以零在其中一个分支上是错误的而结束。如果你有任何让代码更干净的想法，请告诉我！

这应该很容易移植到任何语言中，尽管如果二进制 XOR 在您的语言中不可用，检查它们是否是相同的符号可能需要以不同的方式编写。

# 事情为什么会起作用？

在这一点上，考虑到这种差异，您可能想知道事情是如何进行的。在大多数情况下，这可以归结为事情总是积极的。比如我一开始举的`rand()`例子:

```
rand() % max 
```

在 C 语言中，因此也是大多数 C 语言派生的语言中，内置的类似于`rand`的函数返回从 0 到某个最大值的数字，而`max`值总是正的。当然，更现代的语言通常会提供另一种更清晰的方式来获取随机数，你应该使用这种方式。

数组索引的例子是类似的:

```
index = (index + 1) % array.length; 
```

这将获取数组中的下一个索引，一旦到达末尾，就返回到开头。因为指数开始是正数，除了当它回到零时，只会增加，负数永远不会到达。尽管如果你试图倒着做，它会坏掉

```
index = (index - 1) % array.length; 
```

在这种情况下，当`index`为 0 时，`(0 - 1) % array.length`会给你-1，这是一个越界访问。你必须做一个适当的模加法来解决这个问题。

* * *

那么，你有没有遇到过模和余数的区别的问题？我有；实际上，修复一个这样的错误是这篇文章的灵感来源。