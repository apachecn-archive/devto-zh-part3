# 为什么我选择秋田而不是 NgRx

> 原文:[https://dev.to/joaomarcusc/why-i-chose-akita-over-ngrx-4adb](https://dev.to/joaomarcusc/why-i-chose-akita-over-ngrx-4adb)

我真的很喜欢 Redux 的概念。它允许开发人员避免状态操作在应用程序中扩散，导致难以检测的不一致性，特别是在处理异步事件(如 HTTP 服务调用)时。然而，这不是一个容易理解的概念。这可能看起来像是一个考虑不周的解决方案，制造的麻烦比解决的还多。无论如何，几个月前我决定尝试一下 NgRx。这不是一次愉快的经历。让我告诉你为什么。

* * *

## [](#too-much-boilerplate)样板文件太多

让我们从样板问题开始。每当我需要为 webapp 的特定部分使用 NgRx 时，我必须:

*   创建一组操作
*   用又大又丑的 switch 语句创建一个 reducer 函数
*   将减速器添加到`StoreModule.forRoot`或`StoreModule.forFeature`调用中。
*   在我的组件中调用`select`函数或者创建选择器来获取当前状态。
*   调用`dispatch`函数来分派一个动作。

如果我需要从服务中获取数据怎么办？好吧，那我不得不:

*   添加需要提取数据时将调度的操作
*   添加呼叫成功结束时将调度的操作
*   添加调用失败时将调度的操作
*   添加一个效果类，该类将调用数据获取服务本身并执行动作分派
*   将效果类添加到`EffectsModule`调用中

如果不是经常需要，问题不大。不过，数据交换是我主要做的事情！效果会变得巨大，不容易维持。

* * *

## [](#too-many-concepts)概念太多

我不得不承认，我们的一部分问题是开发者只知道 AngularJS (1.5)，不知道 Angular (2+)。他们必须学习组件、模块、DI。我知道 AngularJS 以前也有，但是 Angular (2+)是如此的不同，感觉就像一个新的框架。他们还必须学习 RxJS、可观测量和其他重要的概念。然后，突然之间，他们还必须学习动作、调度器、减少器、效果、选择器！也许我应该预见到它的到来，但是即使他们已经对 Angular 感到很舒服，似乎这些概念也不容易理解，除非你以前知道 Redux(-ey)库。

* * *

## [](#ngrx-feels-alien-to-angular)NgRx 感觉陌生到棱角分明

每当我使用 NgRx 时，我觉得它可能会更多地使用 Angular。例如，默认情况下应该使用 decorators，而不是又大又丑的 reducer。一些库试图解决这个问题，但我觉得它们不够好，而且它们有时会引入更多的复杂性，比如需要特定的工作来避免 AOT 编译的问题。如果你正在使用 NgRx，我推荐 [ngrx-actions](https://github.com/amcdnl/ngrx-actions) 。

我的同事在“理解”NgRx 方面经历了一段非常非常艰难的时间，他们花在理解 NgRx 和 Angular 上的时间比开发应用程序本身还多。因此，我们决定完全放弃 NgRx，让每个人做他们想做的事情，因为有一个截止日期。

* * *

## [](#dropping-redux-not-yet)滴 Redux？还没有！

我没有放弃尝试在我的应用程序中使用 Redux 风格的库，但我决定尝试替代方案。其中两个看起来更加成熟，久经考验:

*   NgXs :比 NgRx 更简单，但它仍然有一些让开发人员恼火的特定部分，例如需要在单独的地方声明一个动作和相应的特定调度方法。
*   [秋田](https://netbasal.gitbook.io/akita/):比 NgXs 还要简单。而不是动作和调度程序，只是一个简单的服务，即使是异步调用。查询是显而易见的。

* * *

## [](#the-winner-akita)获胜者:秋田

现在，让我们看看在一个具体的项目中引入秋田需要什么

*   将商店创建为扩展 EntityStore 的类
*   创建一个注入存储的服务，并将操作公开为服务方法。不需要动作、缩减器、调度器、带注释的方法等。只是更新状态的简单方法。
*   创建一个扩展 QueryEntity 的类，因此我们创建了选择器
*   需要调用 HTTP 服务吗？没问题，创建一个服务方法就行了。

这可能更容易，但这似乎足够简单，我现在可以谈论它，而不会引起很多人的惊讶。也许我会再给 NgRx 或 NgXs 一次机会，但现在我会选择更简单的。