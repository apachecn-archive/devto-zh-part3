# Swift 实例的可靠编程(1)

> 原文:[https://dev . to/Piero 9212/solid-programming-with-swift-examples-1-4pg 2](https://dev.to/piero9212/solid-programming-with-swift-examples-1-4pg2)

我们所有沉浸在软件开发中的人都听过、有过关于*坚实的*原则的想法或经历。这个原则在很久以前(2000 年)就已经描述过了，并且已经在几种编程语言中使用。
这些概念对于所有开发软件的人或者必须从质量/功能的角度审查代码的人仍然有用(就像开发人员审查其他编程语言的代码一样)。不管你从事软件工作有多长时间(经验),这些原则作为*模式*在开发阶段做出好的决策。

让我们看看这些模式是什么，它们试图解决什么。

## [](#bad-architectural-decisions-as-i-usually-said-bad)糟糕的架构决策(正如我通常所说的糟糕)

### 让我们试着确定你是否已经有了错误的代码。

你是否曾经试图修改某段代码，并注意到你将不得不花费大量的时间来重构或改变其他功能/文件/类而不是特定的代码？这个问题被称为僵化，因为要做出改变需要付出很多努力，比如改变项目的几个部分。

您是否曾经更改过一段代码，并在其他功能/文件/类中发现错误/崩溃/问题，而不是这段特定的代码？这个问题被称为脆弱性，因为变化可能会打破意想不到的部分。

你曾经尝试过在其他文件/模块/项目/存储库中重用一段代码，并且不得不添加他的依赖关系吗？这个问题被称为不可移动性，因为很难在另一个文件/模块/项目/存储库中重用一个组件，因为它有太多耦合的依赖关系。

我把所有这些问题总结成一条黄金法则:

编写易于删除或替换的代码
正如鲍勃大叔(罗伯特·C·马丁)所说，这些概念不是规则、法则或完美的真理，而是帮助你开发优秀软件和提高软件架构质量的指南，所以要正确使用它们。

## [](#solid)固体

是五个指导原则的缩写。我将用 Swift (iOS)中的例子来解释每一个问题。

*单一责任原则*意味着一个函数、模块、类或结构应该只有一个目标、理由或任务。每当你创建/改变一个函数/模块/类/结构时，你应该问自己:它有多少责任？听起来很简单，对吗？

我们通常违反这个原则，因为应用这个模式在你需要为它创建的文件、类和/或协议的数量方面可能是艰苦的工作。

在我作为 iOS 开发人员的经验中，我看到了我们通常违反单一责任原则的最糟糕的元素之一，视图控制器。

考虑到以下因素，我们很容易发现这个问题:

视图控制器可以是数据源或表视图或集合视图的代表，
你可以在视图控制器中发出 web 请求
你可以在视图控制器中使用业务逻辑
你可以在视图控制器中格式化元素
你可以在视图控制器中处理导航

让我们看一个例子: