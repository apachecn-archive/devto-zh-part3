# 外部 API 集成的用例实现

> 原文:[https://dev . to/Charles 1303/a-use-case-implementation-for-external-API-integration-eoj](https://dev.to/charles1303/a-use-case-implementation-for-external-api-integration-eoj)

#### [](#introduction)简介

唷终于来了！这将是我在这个社区的第一篇文章，我希望在这里发表更多的文章时能够更好地使用它们。所以它开始了...

我做了一个简单的任务，与 [Bin List API](https://lookup.binlist.net) 集成，并返回一个与从 Bin List API 得到的响应不同的预期客户端响应。我想指出为这样一个任务设计和构建一个系统的一些基础。
bin list API 是一个公共 API，用于获取支付卡的详细信息。可以通过这里的 [Bin 列表 API](https://lookup.binlist.net) 访问。它公开了一个端点，您提供卡号的前八(8)位数字，并返回卡的详细信息。例如，下面是对 API 的请求和相应响应:

```
 GET  https://lookup.binlist.net/45717260  {  "number":  {  "length":  16,  "luhn":  true  },  "scheme":  "visa",  "type":  "debit",  "brand":  "Visa/Dankort",  "prepaid":  false,  "country":  {  "numeric":  "208",  "alpha2":  "DK",  "name":  "Denmark",  "emoji":  "🇩🇰",  "currency":  "DKK",  "latitude":  56,  "longitude":  10  },  "bank":  {  "name":  "Djurslands Bank",  "url":  "www.djurslandsbank.dk"  }  } 
```

我不会做太多的代码截图，但是你可以访问在[我的 github repo](https://github.com/charles1303/binlistImpl) 中突出显示的每个类和方法的名称和签名。

由于时间和空间的原因，我将强调以下几个方面。

1.  设计模式实现(DTO、服务外观、存储库、无缓存 Cow)

2.  性能(缓存)

3.  测试(单元和集成)

#### [](#toolsplatform-used)使用的工具/平台

1.  Spring Boot 2.1.2 版本

2.  Maven 3.5.3

3.  Java 8

4.  Mysql 5.7.25

5.  Ubuntu 16.04

#### [](#design-pattern-implementation)设计模式实现

因为我正在做一个需要数据传输和操作的集成，这些设计模式在要采用的策略方面立即脱颖而出

1.  数据传输对象(DTO)模式

2.  服务外观模式

3.  知识库模式

4.  无恶病质牛反模式

当您想要以一种结构良好的格式跨服务或域传输数据时，可以使用**数据传输对象(DTO)模式**。它还允许域之间的数据结构转换。预计 dto 应该是可序列化的。因此，虽然 **BinListResponse 类**封装了从 BinList API(我已经在 **application.yml** 中配置了其 url)中检索到的数据，但是**card detail to 类**包含了客户端可以理解的转换后的数据格式。转换是在 **CardDetailService 类**的**convertToCardDetailDto(BinListResponse BinListResponse)方法**中完成的。这种方法的一个优点是，BinList API 响应或客户机的期望都可以在内部更改，而不会影响任何一个。如果数据格式决定改变，这也将防止 BinList API 接口的破坏。这种方法还利用了面向对象编程(OOP)范式中的封装。应用程序中使用的所有 dto 都可以在**com . projects . bin list . dto . responses 包**中找到。

**Service Facade 或简称 Facade** 是一种策略，允许您封装和隐藏执行操作的复杂性，从而向客户端或方法调用方公开一个简单的接口。具有这种特征的界面有时被称为粗糙的。例如， **CardDetailService 类**中的**getCardRequestLogsCountGroupedByCard(Pageable Pageable)**在将数据返回给客户端之前会做很多事情，即检查缓存存储、调用存储库并转换检索到的数据以满足客户端的期望。这样做的好处是，它公开了一个简洁明了的接口，并将相互依赖的相关和看似链接的操作封装为一个操作单元，从而维护了系统操作和客户端输出的完整性。客户端的优势还在于这些操作非常透明，它们不需要知道检索数据的实现。(我喜欢让我的控制器薄而简单)。

众所周知，**存储库模式**允许轻松交换**数据访问层**的实现。它通常由由**数据访问对象(DAO)** ( *DAO，这是另一种设计模式*)类实现的接口组成。Spring 提供了不同的存储库接口，可以根据我们的数据存储引擎进行扩展和实现( **Mysql** 、 **MongoDB** 等)。如您所见，我的存储库域只是一堆泛型接口，它所作用的实体作为类型参数，如在**CardDetailRequestLogRepository 类**中所见。存储库模式允许松散耦合和简单测试，我们稍后会看到这一点。此外，我还拥有编写定制查询的优势，我可以根据所使用的数据存储引擎或 ORM 实现轻松地更改它们。

我将在下一节讨论**无恶名母牛反模式**。

#### [](#performancecaching)性能(缓存)

还记得我在上一节关于服务外观的内容中说过，它是如何通过将一堆操作封装成一个操作单元来产生预期的数据输出，从而公开一个简单的接口进行调用的吗？这是有代价的，每次调用产生输出都要花费时间。但是，我们可以通过存储数据输出并在需要时检索它来消除这种成本，而无需经过重新处理的步骤，前提是我们有某种标识符或关键字，可以查找映射到我们想要检索的特定数据的标识符或关键字。这类似于**动态编程**，当我们通过在数据结构(**数组或映射**)中存储一个带有关键字的先前计算的值来实现**递归算法**时，无需对该值进行递归调用即可检索该值，从而降低了时间复杂度。

在我们的应用程序中，我们使用缓存实现来存储该值，因此我们不必为每个服务调用进行昂贵的数据库调用和数据转换。在这个上下文中，缓存仅仅意味着

> *如果你没有重新处理或重新计算的数据，就照原样给我拿来*。

这就是我们如何处理我之前提到的我们通常称之为**无恶病质母牛反模式**的方法。

为了在我们的代码中实现这一点，我们使用**ConcurrentMapCacheManager**实现在我们的配置类之一 **CacheConfig 类**中配置了一个 Spring 缓存管理器 bean(我们也可以很容易地使用 **EhCache** 实现)。然后，我们在我们的 **CardDetailService 类**中用提供必要值的 **@Cacheable** 注释服务方法**getCardRequestLogsCountGroupedByCard(Pageable Pageable)**(该值表示我们的配置文件中的缓存名称，而键是我们正在使用的键命名策略)。在这里的键命名策略中，我们将方法名与我们发送的*可分页*参数的 *pageNumber* 属性值连接起来，以生成一个键，并使用该键存储返回的数据。因此，第一个请求将经历检索数据的处理步骤，然后使用生成的键将数据存储在缓存中。对于一个 20 条记录的表来说，这大约需要**276 毫秒**。后续请求将忽略处理步骤，只从缓存中取出存储的数据，大约需要 **5-10ms** ( *哇！*)。只有当您发送先前未发送的*可分页*参数的不同*页码*属性值时，才会发生数据的重新处理。但是，这里的一个警告是，如果来自后端的数据已经更改，要想办法从缓存中清除数据，以防止返回陈旧的数据。因此，当数据库中的日志在**logCardDetailRequest(String iinStart)方法**中更新时，其上的**@ cacheevit**注释清除缓存，因此它将强制方法调用**getCardRequestLogsCountGroupedByCard(Pageable Pageable)**从数据库中实际获取数据，因为它将不再位于缓存中。我稍后将向您展示我们如何在测试类中验证这一点。

#### [](#testing)测试

在应用程序开发过程中，编写测试无论怎样强调都不过分。针对您的功能编写测试保证了完整性，如果任何新的代码更改破坏了您的应用程序，就会发出危险信号。在继续之前，我想在这里提一个反问:

> 你为什么要写测试或者你为什么要写那个测试？

对于那些认为

> **我想验证我的功能或端点工作正常。**

，你可能倾向于围绕我们所称的**集成(或功能)测试**来编写你的测试。对于其他认为

> 我想验证我的方法是否正常工作。

，很可能你最终会写**单元测试**。在您的测试套件中包含这两个测试并没有错，但是当您决定实现哪一个或者两个都实现时，您需要考虑以下问题。

集成测试通常依赖于环境，例如，在本地机器上成功编写并通过的测试可能会在另一台机器上失败，原因是不同数据库实例中的数据状态不同，或者由于网络故障导致资源依赖不可用。当您尝试运行**carddetailcontrolleritest**或 **CardDetailControllerTest** 类时，就会看到这样的场景。这些测试类期望在它运行的任何环境下都实现以下内容

1.  Bin 列表 API 是可访问的
2.  数据库可用且可访问
3.  任何环境的数据库中的数据集必须是相同的。

尽管有这些限制，集成测试的一个明显优势是，您可以实际看到您的依赖项在生产环境中的真实部署场景中的行为。例如， **CacheIntegrationTest** 测试类断言在两个服务调用中得到的响应是相同的(即在第一个调用中创建的缓存响应在第二个调用中返回)。它还验证了存储库层在两次调用后只被访问了一次，这表明第二次调用没有访问数据库，而是从缓存中检索了对象。

另一方面，单元测试独立于环境的数据状态，无论在什么环境下运行，都会产生相同的结果。其原因是依赖性、资源、输出和数据被模拟，因此不需要可用或可访问。这里只测试纯逻辑和组件方法行为。例如，在 **CardDetailServiceTest** 类中，用于访问 Bin 列表 API 的 *RestTemplate* 依赖项与响应一起被嘲笑。(这就像在 *PHP* 中使用 *Guzzle MockHandler* 或者在*节点*世界中使用 *nock* )。此外，您还将观察到，**logcarddetailerequest(String iinStart)**类的**carddetaileservice**方法行为同样受到嘲弄，因为它与数据库交互时，指示它什么也不做(感谢@Spy 注释)。最后，我们测试的是我们的 DTO 模式实现(即**convertToCardDetailDto(BinListResponse BinListResponse)**方法)，以确保将从 Bin List API 获得的模拟 **BinListResponse** 对象状态被转换为适当的模拟 **CardDetailDto** 对象状态，并返回给客户端或方法调用方。

你能猜出这种测试方法的缺点吗？是的，没错，它并没有模拟您的依赖项在生产环境中部署时的真实行为。选择在您的代码中实现哪些测试(单元或集成)是编码审查需求、用例或业务需求以及部署管道中采用的策略的功能。

我在这个任务中省略了其他特性，比如**安全性、异常处理和日志**，因为它们不一定是基本需求。我希望不久我也能分享我对此的见解。在执行这项任务中所概述的这种方法绝不是一成不变的，因为我欢迎在执行这项任务时提出意见和其他更好的方式或方法。请随意将项目[拉到这里](https://github.com/charles1303/binlistImpl)进行审核。毕竟这是一个社区，不是吗或者我应该说不是吗？:) .编码快乐！