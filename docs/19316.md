# 数组与链表

> 原文：<https://dev.to/noah11012/arrays-vs-linked-list-3jpb>

在编程语言中，你首先要学习的事情之一是如何创建数组:内存中的连续数据段。

如果你学过 CS 入门课程，毫无疑问，你将学习的第一个数据结构是链表。

在本文中，我们将讨论两者的区别，以及何时应该选择其中一种。

## 数组

数组可以被认为是数据结构。虽然极其简单，但它们允许随机访问。这意味着访问数组中的任何位置都非常快。

但是数组确实有几个缺点。

### 重新分配

当使用像 Python 这样为你处理内存的语言时，这并不坏，但是在像 C 这样的语言中，这就有点乏味了。

只有首先使用`malloc()`或`calloc()`分配数组，我们才能增加数组的存储容量。放在堆栈上的数组不能调整大小。要调整数组大小，我们需要分配一个容量更大的新数组，然后从旧数组复制到新数组并释放旧数组。

```
int *arr = malloc(sizeof(int) * 8);
// Fill in array until we run out of space

int *new_arr = malloc(sizeof(int) * 16);
memcpy(new_arr, arr, sizeof(int) * 8);
free(arr);

// Continue on... 
```

在示例中，我们在堆上分配了一个存储容量为八个整数的数组。稍后，当我们用完空间时，我们会分配容量是旧阵列两倍的第二个阵列。接下来，我们将整数复制到新的更大的数组中，并释放旧的数组。

这组操作可以通过 C 标准库函数`realloc()`来完成。它接受两个参数:第一个是指针，指向由`malloc()`或`calloc()`分配的堆内存，第二个是数组的新大小。它返回一个指向新分配的内存的指针，传入的指针无效。

```
int *arr = malloc(sizeof(int) * 8);
// ...

int *new_arr = realloc(arr, 16);
// Carry on with our operations... 
```

### 插入和移除

如果我们需要将一些数据放在数组的中间，而不是将其附加到末尾，该怎么办？

首先，我们需要将所有元素从放置新数据的位置一直移动到数组的末尾。

示例:

```
| 1 | 2 | 3 | 4 | 5 | |

Shift the array from 3rd index

| 1 | 2 | 3 | | 4 | 5 |

Place new data into freed space

| 1 | 2 | 3 | 6 | 4 | 5 | 
```

对于小型数组来说，这没什么大不了的，但是当处理具有数百、数千甚至数百万个元素的数组时，这可能是一个非常昂贵的操作。

移除也好不到哪里去。我们现在不是将元素移动到末尾，而是将所有元素从末尾移动到被删除元素所在的位置。

## 链表

一个链表节点至少由两部分组成:它保存的数据和指向下一个节点的指针或引用。链表在数组不发光的地方发光。

## 重新分配

链表中的节点是根据需要创建的。当然，虽然保存一个额外的指针和数据会增加链表的总大小，但我们得到的好处是不必重新分配越来越大的数组。在数组中，当重新分配时，我们将其容量加倍。如果你有一个包含一千个元素的数组，并且需要重新分配，那么你必须分配两千个元素。假设一个整数在 64 位平台上是 8 字节，那么你刚才分配的字节数就是 16000 字节。随着阵列继续变得庞大，情况会变得更糟。

每个新节点分配的字节数总是节点结构的大小。如果节点只包含一个整数和一个指针，并且不考虑填充，那么节点的字节大小将是 16 字节。

## 插入和移除

在链表中插入元素比在数组中执行同样的操作要快得多。

首先，我们需要遍历列表，直到找到我们想要的链表节点的“索引”。链表没有索引，但是我们假装它们有，因为这样可以更容易地进行插入等操作。

接下来，我们使来自插入点之前的节点的指针无效，并让它指向新节点，新节点现在将指向前一个节点所在的位置。

因此，如果我们有 node1、node2 和 new_node，它会像下面这样:

```
node1 ---> node2

     new_node

node1 -x-> node2

      new_node
      ^        |
      |         V
node1            node2 
```

比移动数组中的所有元素好多了。

删除一个元素也一样简单。要删除的节点之后的节点现在将由被移除的节点之前的节点指向。

因此，节点 1 的指针将从 new_node 指向节点 2。

## 访问元素

这就是数组优于链表的地方。数组是随机访问的，但是在链表中，获取你想要的节点需要你遍历每个节点，直到找到请求的“索引”。同样，链表不索引，但它有助于对话。

链表也不是缓存友好的。创建链表节点时，是在堆上创建的。当前一个节点指向它时，不能保证新节点与前一个节点接近。所以，当你在每个节点上旅行的时候，你是在你的计算机内存上跳跃。

这肯定对 CPU 缓存节点没有帮助。当 CPU 检测到某个内存段经常被访问时，它会被缓存到一个特殊的位置，以便更快地访问。

## 用哪个？

现在，了解这两者之间的差异可以帮助您做出更明智的决定，决定使用哪一种来满足特定的需求。

如果元素的数量没有快速增加，而你更关心更快的读写速度，那么我建议使用数组。

如果你知道元素的数量会迅速增加，那么链表可能是一个更合适的选择。