# Azure 网络应用——故障排除时代

> 原文:[https://dev.to/lssweatherhead/azure-web-apps-故障排除-era-4n4i](https://dev.to/lssweatherhead/azure-web-apps---the-troubleshooting-era-4n4i)

所以我和 Azure 的关系有点复杂。

我喜欢(总的来说)它让我的生活更轻松。我喜欢连接持续集成是如此的不可思议的简单。
我喜欢管理部署插槽和设置新插槽是合乎逻辑的，并且可以快速完成(尽管有一些部署等待)；我喜欢您可以配置实例，这些实例将根据对其资源的需求进行扩展或缩减。

我不喜欢更新/部署/传播每件事似乎都要花很长时间。我不喜欢这个 UI 似乎是由大约 200 个人同时开发的，所以有时候事情会自动发生，有时候你必须点击 8 个不同的确认按钮，它才会显示你确实想这么做。
当日志/分析/洞察有这么多不同的位置时，我不喜欢尝试解决性能问题。
**我也不喜欢，偶尔他们心目中的错误消息是一片不愉快的乌云。**

* * *

### 我有 99 个问题(当然不是同时发生，但我就是这么觉得的)

最近，我试图弄清我们的 Azure 云目录中一些令人沮丧的性能问题。

症状包括:

*   间歇停工期
*   缓慢的应用重启
*   滞后的前端性能

特别是一个 NET Core 应用程序非常虚弱，重启后通常需要 7-8 分钟才能恢复。令人困惑的是，它也是我们最简单、最小、流量最低的应用之一，那么这是怎么回事呢？

* * *

### 你试过关机再开机吗？

提示一个蒙太奇(尽管实际上这是一个越来越令人沮丧，越来越减少的螺旋),在应用洞察中跟踪一个又一个尖峰图，下载内存转储，满怀希望地点击 blob 存储上的每个日志文件夹，并试探性地浏览希望与您“聊天”的“诊断和解决问题”仪表板上的各种路线。可爱。

当同事们问我进展如何时，我开始使用“可能的线程饥饿”这样的短语，并花了足够的时间阅读 Net Core 中的启动配置，以至于我能够以 50 步的速度对应用程序启动进行故障诊断，但仍然没有找到解决方案。

虽然，严格来说那不是真的。我对事情发生的原因有了更多的了解...

*   我们在一个应用程序计划中有大约 7 个生产站点，该计划根据时间表(早上 7 点和晚上 10 点)以及资源处于压力之下或在此期间之外释放的时间进行缩放
*   当计划扩大时，其中的应用程序服务实例要么为网站加速运行，要么停止运行，正是这段时间让可怜的 wee Net Core 应用程序最不开心
*   Net Core 应用程序是 Pingdom 因停机问题而不断调出的应用程序，但实际上所有应用程序在重启时都有点抖动(它们只是处于不同的警报标准下，doh！)

有了这些信息，我至少可以把我与谷歌的对话从抽象的、青少年焦虑的话题上缩小*“但是为什么呢？”*到更具体的*【管理 azure app 重启】**【配置 net core apps 的多个实例】*。这是一个微小但充满希望的进步。

* * *

### [](#cutting-a-long-and-oh-terribly-exciting-story-a-bit-short)把一个很长(而且，哦，非常激动人心)的故事剪短一点

进一步的调查和编码蒙太奇引导我找到了一套指导原则，我将把它放在这里以供将来参考，并提供给任何试图让病态的 Azure Web 应用恢复健康的人:

首先，也是我最大的收获:在*应用设置*选项卡上的 **`AlwaysOn`** 设置。对于那些不熟悉的人:

> 当网站上启用“始终打开”时，Windows Azure 将定期自动 ping 您的网站，以确保网站始终处于活动状态并处于预热/运行状态。这有助于确保站点始终响应(并且应用程序域或工作进程不会因为缺少外部 HTTP 请求而调出)。

*摘自[斯科特·格思里的博客](https://weblogs.asp.net/scottgu/windows-azure-staging-publishing-support-for-web-sites-monitoring-improvements-hyper-v-recovery-manager-ga-and-pci-compliance)*

听起来很明智吧？而且是在*生产*的场地上。但是，这是我们自己挖的一个小洞，微软借给了我们一把铲子，这是**而不是**一个特定于插槽的选项，因此，为了避免生产站点在分阶段交换后意外闲置，我们一直都有`AlwaysOn`选项。在每个插槽上。在任何环境下。对于每个项目。

这意味着，每当我们的 7 个生产站点扩大规模时，我们都会得到(例如)每个站点的 2 个实例，这两个站点都会重新启动并预热，然后执行 pinged 操作以确保它们是`AlwaysOn`。到目前为止，一切顺利。但是，接下来所有的转移和开发插槽都会被 pinged 并强制启动，巨大的 I/O 量会完全破坏几乎所有东西的性能，并导致感觉停机。为什么 Azure Web App 用这个这么吃亏？那是[另一回事](https://stackoverflow.com/questions/36966505/azure-web-apps-are-really-slow)。

目前对我们来说没有什么好的管理方法——如果你用一个脚本来处理槽交换，我想你可以在交换后切换`AlwaysOn`选项。我们只需在部署结束时将其添加为手动检查。这不是世界末日，但这肯定是一个需要注意的令人恼火的细微差别！

其他较小的胜利包括:在 Net Core 应用程序上从 IMemoryCache 迁移到 IDistributedCache(以最大限度地减少 I/O 存储写入，并使我们能够利用未来的负载平衡)，并确保 HTTPS 唯一标志设置为`true`，以便应用程序初始化器在启动时不会在任何愚蠢的地方反弹。