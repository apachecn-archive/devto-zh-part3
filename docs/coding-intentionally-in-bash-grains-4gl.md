# 有意用 Bash 粒度编码

> 原文：<https://dev.to/rpalo/coding-intentionally-in-bash-grains-4gl>

*这篇文章最初是[发表在 exercisem](https://exercism.io/blog/coding-intentionally-in-bash-grains)上，这是一个非常棒的基于导师的免费平台，旨在提高你的编码技能。我在那里指导 Bash 和 Python 方面的人员，如果您想学习更多关于特定语言习惯用法的知识并提高您的编码技能，您绝对应该去看看。*

剧透警告:这篇文章有关于谷物运动的剧透，特别是 Bash 赛道上的谷物运动。如果你自己还没有完成，并且你不想看到一些解决方案，那么一旦你完成了就回来！

这是你在新公司的第一天。您已经完成了所有的文书工作，会见了团队成员，现在终于是您坐下来开始阅读一些您将要处理的代码的时候了。您开始通读不同的函数、类和模块，当您阅读时，您发现自己开始困惑地眯着眼睛看屏幕。你继续读着，一个词从你的嘴里冒出来，几乎是说出来的，几乎是呼吸:“哇，哇，哇，哇，哇……”越往前走，这种情况就越多，你会变得更加困惑，甚至有点生气。

> 这段代码中发生了什么？

每当不止一个人在一段代码上工作时，保持事情可管理所需的小心谨慎的程度就会上升。它不再是存在于你大脑中的概念，也不再是让这个概念发生的代码。现在，这个概念必须存在于代码中*，所有的合作者都可以看到它，并在需要时修改它。*

对于最终用户来说，你如何实现某个东西并不重要，但是对于每一个在任何时候接触到你的设计的工程师来说，这应该是 T2 卷。通常有很多方法可以实现相同的功能，看起来任何一种方法都足以完成工作。然而，我相信你做的每一个决定都应该有一个理由(即使是一个有小理由的小决定)，这个理由应该传达一个目标或要求。

实现细节应该帮助代码读者辨别思维过程、目标和优先级的想法被称为**设计意图**。你如何命名你的变量，你的函数采用什么参数，以及事物是如何被抽象的，这些都是可以表达设计意图的地方——无论是好的还是差的。

我坚信设计意图是实现工程设计时要考虑的最重要的事情之一。这是软件工程与编程的区别之一。

> 软件工程是当你增加时间和其他程序员时，编程会发生什么。
> 
> — [鲁斯·考克斯](https://research.swtch.com/vgo-eng)

## 设计意图是跨学科的

我是机械工程师，设计[注塑模具](https://youtu.be/WHwTHarf8Ck?t=51)，大部分是医疗器械。我所有的设计，一旦完成，就直接出门进入机械车间，在那里他们开始制造所有的零件并把它们组装在一起。因为他们不知道我在创作每一个设计时脑子里想的所有事情，我必须找到一种方式让*通过设计本身向*展示我的意图。

很多时候，有些功能特别关键。要么是客户说他们需要特殊的紧公差，要么是模具装配的方式出于某种原因需要极高的精度。因此，为了帮助机械师以优先考虑重要部分的准确性的方式创建工件，我必须留下特别方形或容易以特定方式放入老虎钳的点。这样，对他们来说最容易的方法对我来说会产生最好的结果。

也有尺寸不那么重要的地方。例如，如果我在设计中放一个孔，只是为了通风，我会把它做成一个很好的普通尺寸，比如 6mm。

当他们加工这个孔并去测量它是如何出来的，如果他们看到一个像 5.99 毫米这样的数字，他们会想，“好吧，这可能应该是 6 毫米，所以我很接近了，”他们甚至不必去仔细检查 CAD 或规格图上的尺寸。相反，如果我让它变得不寻常，比如 5.87 毫米，他们会看着它，有这样的第一反应:

1.  哦，该死，我是不是太小了？应该是 6mm 吧？
2.  (他们去查看 CAD，发现他们的球洞很好，只是大小不太一样。)
3.  嗯。我肯定这个洞不寻常是有原因的。可能是真的很重要，或者是客户要求在这里开一个特别的洞。我要去和 Ryan 谈谈看看这个洞有什么重要的。
4.  (SLAM！他们优雅地把大块铝放在我的桌子上。)
5.  (他们发现这个洞没有什么重要的，我只是选了一个奇怪的尺寸，所有这些额外的工作和担心都是没有理由的。)
6.  伙计，那个叫赖安的家伙，真是个麻烦。(发牢骚，骂人，发牢骚)

所有这一切的发生是因为我的设计的每一个决定都传达了一些信息给其他人，不管我是不是有意的。他们必须看到其中的意义，因为这是他们唯一可以依靠的信息！所以，如果我能花时间把*有意义的*、**有意的**信息放在我的设计里就更好了。

## 谷物简介

现在，让我们用一个练习中的例子来讨论如何在代码中传达设计意图。我最近和一个学生合作，研究他们在 Bash 赛道上的*谷物*练习的解决方案。*谷物*是解决[小麦和棋盘问题](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem)的练习。简而言之，一粒小麦被放在棋盘的第一格。两个谷粒放在下一个方块上。四粒放在下一个方块上。以此类推，每个方块的纹理都是前一个方块的两倍。学生们被要求找到一种方法来计算每一个方块上的数值以及棋盘上颗粒的总数。

这个特别的学生想出了一个非常聪明的方法来计算总数。

```
bc <<< 'ibase=16;FFFFFFFFFFFFFFFF' 
```

`bc`是一个命令行计算器。你可以给它传递算术字符串，它会对它们求值，即使是非常大的整数和浮点数。在 Bash 中，不使用`bc`也有其他的方法来进行计算，但是，为了简单起见，我们将看看在使用`bc`时，意图是如何被传达的。

这个解决方案是可行的，因为整个练习围绕着 2 的幂——有 2 的幂，就有二进制，有二进制，就有十六进制 <sup id="fnref2">[2](#fn2)</sup> ！

这是一个聪明的解决方案，但是代码告诉我们什么呢？十六进制在这里很重要吗？问题基本上围绕着 16 岁？重读问题陈述后，很明显这两种情况都不存在。这位学生和我一起集思广益，想出了一些如何更清楚地传达意图的想法。以下是我们想到的一些事情:

### 第一选项:二进制

因为我们已经有了一堆加倍的东西(因此，一堆 2 的幂)，让我们看看二进制中发生了什么，看看这是否会帮助我们。

* * *

第一个方块上有 1 粒。在二进制中，这也将是`0b1`(`0b`只是意味着“这是一个二进制数”，实际数字是`1`)。

第二个方块上有两个颗粒。在二进制中，`0b10`。到目前为止总数是 3(或`0b11`)。

第三个方块上有 4 ( `0b100`)粒。至今总数:7 ( `0b111`)。

第四格有 8 粒(`0b1000`)。至今总数:15 ( `0b1111`)。

* * *

你能看出模式吗？

每个方块代表另一个二进制数字，把它们加起来就是一串 1。

在学生的解决方案中，我们可以用 64 个 1(每个正方形一个)来代替 F！

```
bc <<< "ibase=2;1111111111111111111111111111111111111111111111111111111111111111" 
```

更有目的性，因为它更贴近问题给我们的内容。但是，我们不会说机器人。一长串本质上不可数的 1 可能不是一种改进。

### 第二种选择:蛮力计算

好吧，也许我们可以完全放弃非十进制的计数系统。我们为什么不让代码与我们如何手工计算棋盘上的颗粒总数相匹配，通过计算每个方格上的颗粒数？

```
total=0
current_grains=1
for square in {1..64}; do total=$( bc <<< "$total + $current_grains" )
  current_grains=$( bc <<< "$current_grains * 2" )
done echo "$total" 
```

这更具可读性和可理解性。代码清楚地显示了棋盘上方格的数量是一个驱动因素，以及每个方格的加倍效果。我认为这比最初的解决方案要好。

然而。

很慢。循环、添加和重复调用外部命令？它们的运行时间都比较慢。这有什么大不了的吗？不，如果你在 Bash 中编写这个脚本，你可能已经决定你没有速度限制。但是还能更好吗？是的。

### 第三种选择:直接计算

那么，我们如何在不迭代的情况下把所有这些加起来呢？

让我们考虑同样问题的一个*小一点的*版本:一个有 5 个方格 <sup id="fnref3">[3 个](#fn3)</sup> 的棋盘。

五个正方形将具有以下数量的颗粒:

```
---------------------
| 1 | 2 | 4 | 8 |16 |
--------------------- 
```

这里的总数是:1 + 2 + 4 + 8 + 16 = 31。嗯。31 号还没对我吼出什么明显的声音。让我们再大一点。

好吧，那么六格棋盘怎么样？这一次，我将在每个方块下方显示运行总数，以帮助我们将其相加。

```
-------------------------
| 1 | 2 | 4 | 8 |16 |32 |
|   | 3 | 7 |15 |31 |63 |
------------------------- 
```

而总和:1 + 2 + 4 + 8 + 16 + 32 = 63。嗯（表示踌躇等）...实际上我已经开始看到一点端倪了，但是我们会再做一次来确认一下。

7 个方块:

```
-----------------------------
| 1 | 2 | 4 | 8 |16 |32 |64 |
|   | 3 | 7 |15 |31 |63 |127|
----------------------------- 
```

1 + 2 + 4 + 8 + 16 + 32 +64 = 127.你看到了吗？31，63，127 值的警报响了吗？

它们几乎是 2 的幂。事实上，他们的*比*的*少一个*的二次方。

再举一个例子，把它开回家。想象一个 12 平方的棋盘。那是一，翻了 11 倍(在数学上，就是 2^11): 2048。再翻一倍，你得到 4096 (2^12).因此...如果我们得到了正确的模式，运行总数将是 4096 的*差*，也称为 4095。如果我们把它加起来，我们会得到:1+2+4+8+16+32+64+128+256+512+1024+2048 = 4095。

> 换句话说，要得到所有`n`方块的总数，你需要增加 2 的 1 次方，然后从结果中减去 1。

方块 64 上的颗粒数是 2^63(零分度，记得吗？).所以，如果我们想计算从*到*方块 64 的所有方块上的总颗粒数，我们需要计算 2^64 并减去 1。

布拉莫。

在 Bash 中，它会是这样的:

```
bc <<< "2^64 - 1" 
```

当你确认二进制发生了什么时，这是有意义的。在二进制中，所有 64 个正方形的总数是多少？

```
0b1111...  # 64 ones 
```

理论上的第 65 个正方形有多少粒？

```
0b10000... # 1 and 64 zeros 
```

如何从 1 和 64 个 0 减少到 64 个 1？你减去 1。

这给我们带来了什么额外的好处？好了，现在我们有了一个很好的，可读的总表达式。不迭代，所以性能不错。它包含数字 64，这是棋盘上方格的数量，这是一个信号良好的**设计意图**的好例子。如果出于某种原因，在 1000 年后，世界在 7x7 棋盘上标准化，那么未来的工程师(可能使用 Bash 6.1)将检查脚本，了解您想要什么，并将 64 改为 49。一切都好！

## 留点心，朋友们

当制定一个实现时，很容易把东西扔来扔去，抓住第一个可行的解决方案。这在你探索问题的时候很好，但是一旦你完全理解了关键的组成部分——如果你有时间好好润色一下的话——确保每个算法、每个变量名、甚至你的空白空间都描绘出了问题、关键需求以及所有部分是如何组合在一起的。

* * *

1.  参见 Thom Holwerda 的漫画。 [↩](#fnref1)

2.  如果你对二进制和十六进制计数感到有些生疏，@kytrinyx 推荐《如何计数》这本书。作为一个无耻的家伙，我最近也给[写了几篇关于二进制和十六进制的博文。](https://www.assertnotmagic.com/2018/09/10/binary-hexadecimal-part-1/) [↩](#fnref2)

3.  我不知道那会怎样。也许我们可以让棋子互相较量。 [↩](#fnref3)