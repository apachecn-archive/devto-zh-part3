# 感谢字节大小的整数

> 原文:[https://dev . to/some dood/thank-you-to-byte-size-integers-2h6c](https://dev.to/somedood/thank-you-to-byte-sized-integers-2h6c)

# [](#a-very-brief-history-of-computing-numbers)计算数字的非常简短的历史

在过去，现代计算的早期先驱们面临着一个似乎不可逾越的障碍。他们必须弄清楚计算机如何有效和高效地表示十进制数字系统。他们最终同意用 1 和 0 来模拟整数。虽然使用以 2 为基数的数字系统来模拟以 10 为基数的数字系统很奇怪，但这种设计被证明是一种巧妙的设计，因为 1 和 0 的开关性质实际上与晶体管、逻辑门、算术单元和处理模块的开关行为一致。这基本上是天作之合。

当他们不得不考虑分数、精度和负数时，问题就出现了。巧妙的创新和变通，如[符号位](https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation_(SMR))和[二进制补码](https://en.wikipedia.org/wiki/Two%27s_complement)，最终导致了 1985 年 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) 标准的形成。数字的二进制格式被设计成类似于科学记数法，这样它就可以存储和有效地对更大范围的数字进行算术运算，并具有更高的十进制精度。

尽管有计算上的缺陷和限制(比如臭名昭著的`0.1 + 0.2 != 0.3`)，该标准对许多计算机制造商和语言设计者来说是一个可行的解决方案/折衷方案。事实上，该标准(及其后续修订版)设计得如此之好，以至于我们常常认为它是理所当然的。我们今天所知道的大多数计算机和编程语言要么完全采用 IEEE 754 标准，要么以某种方式源自该标准。如果没有这种处理浮点运算的标准化方法，它们就无法高效而精确地运行。

# [](#memory-inefficiencies-for-dynamicallytyped-languages)动态类型语言的内存效率低下

在我们考虑动态类型语言之前，IEEE 754 标准是一个很好的解决方案。高级的动态类型语言——即 [JavaScript](https://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-value) 和 [Python](https://docs.python.org/3.7/tutorial/floatingpoint.html#representation-error) ，这是近年来最流行和最广泛采用的编程语言中的两种——默认情况下，通常选择遵守 IEEE 754 标准(2008 年修订版)的所有**数字。没有办法定制这种行为，因为这样做的话,“高级、动态类型化”语言的“高级”和“动态”方面将是没有意义的，因为对于如此低水平的对存储器的控制，人们将被要求静态地键入一个数字。**

尽管对于许多用例来说是初学者友好且灵活的，但是从内存优化的角度来看，将所有的**数字都作为带符号的 64 位(双精度)浮点数存在一个相当大的问题。并不是所有的用例都需要数字的范围和精度。为尾数分配 52 位，为指数分配 11 位，为符号位分配 1 位，这对于通常的用法来说无疑是大材小用。8 个字节对于一个很小的正整数来说实在是太多了——比如一个数组的`length`属性——它可以很容易地用 1 或 2 个字节来表示。**

C++通过`int`、`float`和`double`类型以及它们各自的修饰符(`signed`、`unsigned`、`short`和`long`)给了我们更大的自由来决定数字的大小。当我第一次发现这一点时，我内心的书呆子立即被我的控制力所激动。突然，我从动态类型语言的桎梏中解放了出来。突然间，我有能力在我认为安全和必要的情况下使用尽可能少的内存。

因为我很少在程序中使用分数和负数，所以`unsigned short int`是我默认的数字类型。除非 API/实现有另外的要求，或者我发现[整数溢出](https://en.wikipedia.org/wiki/Integer_overflow)的*真实*可能性，我没有特别的理由升级到更大的整数类型。可以说我是一个不必要的“优化”的学究，但我内心的书呆子只是在尽可能多地节省内存中找到了很多满足感。尽管到处键入`unsigned short int`非常冗长，但是知道我因为没有被迫使用双精度浮点数而节省了 6 个字节的内存，感觉还是很棒。

# Rust 整型变得更加疯狂

正当我认为 2 字节的`unsigned short int`数字是我痴迷于内存优化的最终解决方案时，Rust 闯入了我的生活，用[无符号的 1 字节整数(类型注释为`u8` )](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types) 打了我一巴掌。

当然，有人会说 C++也有一个“字节大小”的整数结构，但是从语义上来说，`char`应该被用作字符，而不是整数。将一个整数声明为一个`unsigned char`肯定能为我完成这项工作，但是如果没有明确的文档，它很难传达我将它解释为一个整数的意图。简而言之，与 C++相比，Rust 为“字节大小”的整数提供了语义上更优越的构造。另外，输入`u8`比输入`unsigned char`要方便得多。

但接下来你可能会问，“存储一个溢出超过`255`的整数有什么意义？”老实说，除非你用它来——比如说——存储一个颜色分量的值(就像在 [RGB 颜色模型](https://en.wikipedia.org/wiki/RGB_color_model)中一样),使用“字节大小”的整数比使用`unsigned short int`(或者 Rust 中的`u16`)没有明显的优势。你必须像我一样非常迂腐(或者相当书呆子气)才会考虑使用它。

```
// JavaScript ❌
// Very concise but very memory-inefficient (8 bytes)
const num = 1; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

```
// C++ 😐
// Quite memory-efficient (2 bytes) but very verbose
const unsigned short int num = 1; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

```
// Rust ✅
// Quite concise and very memory-efficient (1 byte)
let num: u8 = 1; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#thank-you-bytesized-integers)谢谢，“字节大小”的整数

最终，人们会认为，由于现代 CPU 和 ram 卡的强大，这些类型的“微优化”不会对程序的整体性能产生影响。是的，我完全同意那个论点，但是我写这篇文章并不是为了断言“我们必须总是尽可能使用`u8`整数”。我写这篇文章是为了表达我对数字类型的感激之情，它给了我作为一个程序员在内存分配上的自由。

在当今这个时代，高级的动态类型语言统治着软件开发领域，这种程度的内存控制已经成为过去...理所当然！如今，担心内存管理的细微差别已经变得不必要的乏味，甚至是徒劳的，尤其是最近 T2 的“敏捷开发”哲学越来越流行。

然而，我不允许这妨碍我在生活的琐事中寻找快乐。对我来说，我在最大化我拥有的比特、字节和字节中找到了一种特殊的满足感。这并不是因为我想成为非生产性的或类似的东西；当我知道我尽了最大努力来管理我所拥有的有限资源时，我的某一部分只是拍拍我的背。

也许这种对资源优化的执念，来源于我从小被低端设备包围长大。我清楚地记得，我无法忍受再多花一秒钟等待一个程序最终做出响应。从那时起，我向自己承诺，我再也不会编写让人们经历我童年时经历过的漫长等待时间的软件。

出于这个原因，我要对数字类型说“谢谢”——即 C++的`unsigned short int`和 Rust 的`u8`——感谢它们让我完成了对优化的毕生奉献，并在我需要每天的内存优化来让我振作起来的时候陪在我身边。

🥂 *为数字类型干杯！* 🥂