# 契约式设计——学习一些关于 OOP 的新知识

> 原文：<https://dev.to/rlxdprogrammer/design-by-contract---learn-something-new-about-oop-4jfd>

**简介**

当我学习计算机科学时，我遇到了所谓的霍尔逻辑。它的主要思想是为每个命令/程序定义一个前置条件和一个后置条件。这些是逻辑表达式。在开始程序之前，前提条件必须为真。主要是检查所有输入是否在正确的范围内等等。当然也可以是恒真的，这意味着:这个程序没有特定的前提条件。运行程序后，必须满足后置条件。就像你的前提条件是 x > 0，你的程序什么都不做，然后 y := x，那么你的后置条件将是:x > 0 和 x = y，通过一些预定义的规则，你可以用逻辑方法证明你的程序是正确的还是错误的。对于简单的程序来说，这很容易，但是对于复杂的程序来说，这就变得非常复杂，这就是为什么用这种方式来验证程序代码并不常见。无论如何，它是一个静态代码验证方法。

所以我学了，通过了考试，然后就把它忘了。

几年后，我读到了所谓的固体原理，其中有一个叫做利斯科夫替代原理。我突然想起了我的研究:“嗯，我已经在某个地方听过了”。这个原则是这样的:“如果 S 是 T 的一个子类型，那么程序中 T 类型的对象可以用 S 类型的对象替换，而不会改变程序的任何期望的属性”。很清楚，但事实上这意味着什么呢？它的含义如下:

不能在子类型中加强前提条件。

子类型中的后置条件不能被削弱。

超类型的不变量必须保留在子类型中

嗯，这听起来像霍尔逻辑，听起来像一些有用的东西。在这一点上，我读了一些关于契约式设计的书，我在那里学到的东西让我更好地理解了我应该如何在 OOP 中实现我的程序。

我想向你展示主要的概念。

**一类合同**

我们可以讨论三种不同类型的契约:不变式、前提条件和后置条件。不变量属于一个类，前置条件和后置条件属于一个方法。

不变量就是对你的类的状态的限制。类的状态基本上就是类变量的值。例如，如果你有一个直角三角形的类，你的类变量可以是:三角形 a 边的长度，b 边的长度和 c 边的长度。这些变量及其当前值代表了类的状态。我们知道规则:直角三角形的情况下 a*a + b*b = c*c。这意味着如果我们的类代表直角三角形，所有不满足这个条件的值都是无效的，它们不代表直角三角形。所以这个逻辑表达式(a*a + b*b = c*c)可以是你的类不变量。这在任何情况下都是正确的。它将被检查:在你的构造函数的末尾，在你的任何类方法的开始，在你的类方法的末尾。其次，保持类变量私有并通过 setter 和 getter 函数访问它们是一个很好的实践，这样你的类就永远不会得到不满足不变量的无效状态。

方法的前提条件是在启动方法之前检查一个条件。例如，如果你有一个三角形的拉伸函数，它有一个名为 factor 的参数，你的前提条件可以是这个参数大于 0。

方法的后置条件。被选中，它描述了你对你的方法的期望。对于中的拉伸函数，可能类似于:a =旧(a) *因子，b =旧(b) *因子，c =旧(c) *因子，其中旧表示方法开始时的值。这里同样重要的是，你需要考虑你的类的整体状态。因此，如果它具有不应由该方法更改的属性，也应该在 post 条件中指定。例如，如果你的表示也有一个颜色属性，那么 post 条件应该扩展为:colour = old(colour)。

到目前为止都很简单:每个方法都有一个前置条件和一个后置条件，类有一个不变量，在构造之后，在每个函数的开始和结束时都会检查这个不变量。

**子类合同**

如果你的类有了基类会有什么变化？

你的类拥有所有基类的不变量。因此，在一个基类的情况下，需要始终满足以下条件:invariant_of_base_class 和 invariant_of_your_class。所以从子类中你不能破坏基类的不变量。

例如，如果直角三角形类是从三角形类派生的，则三角形类的不变量可以是:a + b >= c(两个较短边的长度之和应该至少是最长边的长度)。直角三角形也应该满足这个不变量。

关于前置和后置条件:

对于被覆盖的函数，前置条件不能作为基类中的前置条件得到加强。所以它可以是强度较小的(比如代替(a < 10 和 b < 10)只是(a < 10))或者和基类中的一样。

对于被重写的函数，后置条件不能被弱化为基类中的后置条件。所以强度可以一样，也可以更大。

这叫做利斯科夫替代原理，是固体原理的一部分。

第一次看可能有点复杂，但它只说明了:你的子类是你的基类的特例，所以它应该适用于所有与基类一起工作的输入，并且应该产生相同的结果。

**支持编程语言中的契约式设计**

对代码使用契约式设计是一种防御性的编程方法，在违反任何契约(不变量、前置条件或后置条件)的情况下，您的程序都会出现运行时错误。同样常见的是，对契约的检查只在代码的测试版本中被激活，而在发布版本中被停用。

有一些编程语言，比如 Eiffel，以本地方式支持契约，但是它们现在并不流行。对于当今流行的面向对象语言(C++，C#，Java 等。)你可以做你自己的实现，它也不会太复杂或者重用一个已经存在的库。对于 C++ Boost。合同是个不错的选择。对于 Java，有几种开源解决方案，如 Oval 或 Contract for Java。对于 C#你可以使用代码契约。对于 Python PyContracts。

**总结**

当然，我知道契约式设计不是一种经常使用的编程方式，我认为这是完全可以的。另一方面，在我看来，这是一种快速简单的方法，可以提高你的代码质量，让你更多地思考“我的代码到底在做什么”。这也使你的代码更干净，因为你会仔细检查你的类的状态，你的前置和后置条件也记录了你的函数的规格。

我认为，即使你没有使用这种方法进行开发，了解这种编程方式并在实现你的类时考虑一下你的不变量、前置和后置条件以达到更好的代码质量也是很好的。