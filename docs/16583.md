# 创建可重用代码

> 原文:[https://dev.to/nicholascloud/creating-reusable-code-5cjp](https://dev.to/nicholascloud/creating-reusable-code-5cjp)

创建可重用软件是具有挑战性的，特别是当软件可能被重用在它不一定是为其设计的情况或场景中时。我们都有过这样的会议，老板或经理会问这样的问题:“你设计的东西很棒，但是我们能把它用在这里吗？”

在过去的一个月里，我有过这样的经历，从中我学到了许多关于制作可重用软件的宝贵经验。

## [](#etexts-and-annotations)文本和注释

当我刚开始为 eNotes 工作时，我最初的任务是修复一些与我们网站上显示的电子文本相关的代码(例如，莎士比亚、爱伦·坡、吐温等)。).我们为许多文本收集了大量的注释，当用户点击文本中的突出显示时，这些注释就会显示给用户。几年前，我们将这项技术分拆成一个独立的产品， [Owl Eyes](https://www.owleyes.org) ，增加了额外的教师工具和教室管理功能。由于我对现有电子文本和注释代码的经验，也因为我主要负责前端 JavaScript，我的任务是为这些电子文本在浏览器中构建一个[“类似 Kindle”的体验。(这是我职业生涯的亮点之一。这项工作很艰难，有很多边缘案例，但它在各种设备上都能很好地工作，并且有一些非常酷的功能。)](https://www.owleyes.org/text/hamlet/read/act-i-scene-i)

### [](#filtering-serializing-and-fetching-annotation-data)过滤、序列化和获取注释数据

教师和教室功能引入了一些额外的挑战，这些挑战在 eText 内容首次在 enotes.com 托管时并不存在。首先，教室必须相互隔离，这意味着如果老师或学生在 eText *中为他们的教室*留下注释，教室外的任何人都不会看到。此外，如果教师使用相同的 eText 教授多门课程，他们需要能够跨教室复制注释。最终，我们引入了付费订阅的高级功能，这使得注释可见性规则变得更加复杂。所有猫头鹰之眼官方注释都可以免费公开查看，但某些优质教育注释仅限于付费订户。(此外，在付费订阅的老师授课的教室里的学生被认为是订阅者，但是*只在那个教室的课本内*！)事情很复杂。

我们设计了一种策略，通过这种策略，一系列可组合的规则可以应用于任何一组注释，根据我们的业务需求对它们进行过滤。这些规则实现了一个简单、相同的接口，每个规则都可以作为参数传递给另一个规则以形成集合。过滤后的注释数据随后被序列化为 JSON 并发送到页面服务器端。当读取器在客户端呈现时，这些数据被反序列化，客户端应用程序脚本接管。

给定用户在系统中拥有的角色通常决定了他们是否可以看到与注释相关的附加元数据，或者他们是否可以对那些注释执行某些动作。这些被传送到前端以根据需要启用/禁用特性，然后如果聪明的用户试图颠覆他自己的角色的限制，则在后端强制执行。为了使页面上的数据占用尽可能少，我们开发了一个可组合的序列化方案，可以应用于应用程序中的任何实体。通用序列化类将实体的数据分解成一个 JSON 结构，而更专用的序列化类根据用户的角色和权限添加或删除数据。这样，给定的注释可能包含教师感兴趣的元数据，但是会排除学生的元数据。如果用户是管理员，则会添加附加信息，以便他们能够更好地控制前端数据。

最终结果是，从用户的角度来看，当打开 eText 阅读器时，他们可以看到的注释以及这些注释中的数据是为用户量身定制的。

快进到今天。我最近被指派将我们的文本和注释带回 enotes.com。我们集思广益，寻找实现这一目标的最佳方式，因为 enotes.com 缺乏完整的电子文本和注释数据，以及丰富的前端阅读体验。

我们认为，由于 eText 和注释数据已经被序列化为 JSON，供 owleyes.org 的客户端使用，所以通过 API 提供相同的数据是微不足道的。我实现了一个简单的控制器，它利用 Symfony 的身份验证机制通过 API 密钥对对签名请求进行身份验证，并以与在 eText 阅读器中呈现数据完全相同的方式返回注释 JSON 数据。经过检查，我意识到一些注释数据与我们想要在 enotes.com 上显示的内容无关，所以我很快创建了新的序列化类，这些序列化类利用了现有的序列化类，但是在返回之前从生成的 JSON 结构中提取了不需要的数据。不需要对注释过滤规则进行任何更改，因为从规则集的角度来看，API 用户是一个“公共用户”，因此会看到与未登录到该站点的用户看到的相同的注释数据。

在 enotes.com 上获取这些数据很简单，只需使用 PHP 的 CURL 类从 owleyes.org 端点请求数据。

### [](#the-user-interface)用户界面

owleyes.org 上的 eText 阅读器 JavaScript 代码复杂；它由许多不同的模块组成——视图模块、状态模块、实用模块、消息模块等。-它们相互作用，形成流畅的阅读体验。它比我们希望在 enotes.com 上显示的页面更具交互性，所以我最初担心代码会因为其复杂性而无法完全重用。

我愉快地错了。

当我写软件的时候，我会煞费苦心地分离代码，更喜欢组合而不是继承，并且在我的模块和类中观察清晰、严格和自然的 API 边界。和每个程序员一样，我有一种特殊的编程“风格”——我思考和建模问题的方式——在这种情况下，这种方式对我非常有用。

我将 owleyes.org 代码库的模块复制到 enotes.com 代码库中，我知道这些模块对于新的 eText 页面的运行是必要的。通过一些小的调整(主要与 DOM 元素标识符和类有关)，代码几乎完美地工作了。在我需要引入新代码的地方(我们在 enotes.com 使用弹出菜单显示注释，而在 owleyes.org 我们使用页脚“弹出菜单”在旋转木马中循环显示注释),现有代码中的 API 定义得如此之好，以至于我能够很容易地适应它们。当需要不同的页面行为时(例如，当读者滚动时，当注释弹出窗口太靠近屏幕顶部时，弹出窗口移到注释下方，否则移到注释上方)，跟踪窗口和页面状态的解耦实用程序模块已经为我提供了实现这些行为所需的事件和信息。因为通过 API 交付的序列化注释数据的模式与 owleyes.org 阅读器中嵌入的 JSON 数据相同，所以过滤、排序和操作这些数据的模块根本没有改变。

## [](#why-it-worked)为什么有效

不用说，作为开发人员，这个项目让我非常满意。当你的代码在其他环境中被轻松重用时，这意味着你做对了。我观察了一下是什么使这种重用成为可能。

首先，可重用代码应该以这样一种方式对一个问题或一个系统进行建模，即该模型的组成组件可以一起工作，或者单独使用，而不会影响模型的其他部分。模块、类和函数是我们用来在软件中表达这些模型的有形构件，它们应该与我们头脑中对这些模型的思考方式相对应。每一个都应该被恰当地命名，与模型中的一些概念相对应，并且它们之间的联系应该被很好地理解和显而易见。例如，在 eText 阅读器中，工具提示是文本的突出显示部分，单击它可以显示注释弹出窗口，该窗口显示注释信息。工具提示和注释弹出是*可视化*模型中的组件；它们被恰当地命名，它们之间的关系是单向的，从工具提示到弹出窗口。

第二，一个给定的问题实际上可能由同时运行的*多个*模型组成。控制 UI 的模块是*视觉*或*显示*模型的一部分；控制数据访问和过滤的模块是*域*模型的一部分。模块跟踪鼠标移动，或基于用户交互启用/禁用功能，是*交互*模型的一部分。在这些模型中，对象或模块应该只执行符合模型目的的工作。例如，*可视化*模型中的对象不应该将业务规则应用于数据。当一个或多个对象展示来自多个模型的行为时，提取并封装不属于每个对象的主模型的行为会使该对象更加可重用。

第三，模型中的对象应该有定义良好的，*粗糙的*API。(在对象的上下文中，API 是对象对外部调用方或扩展它的对象的“公共”方法。)粗糙的 API 是提供其职责所需的最少功能的 API。是的，最少的*最少的*。一个对象要么独立存在，要么利用其他对象来完成它的工作。如果一个对象上的方法很多，那么这个对象很可能被分解成几个更小的对象，它将委托给这些对象，并且依赖这些对象来完成它的内部工作。提问:这个对象代表什么抽象，哪些方法实现了这个抽象。同样，对象方法的参数通常可以通过将已知状态传递给对象的构造函数(或工厂函数，或任何用于创建对象的方法)来减少。这将对象的行为链接到一个预先确定的状态——所有剩下的方法参数只是这个状态的*扩展*。如果状态需要改变，具有不同状态的另一个相同类型的对象被创建并代替它使用。API 是粗糙的，因为方法很少，并且它们的参数很稀疏。

第四，对象的状态应该始终稳定。它的初始状态应该完全通过对象的构造源来设置(无论是通过参数提供的数据，还是合理的默认值，或者两者都有)。对象的属性应该被认为是只读的，因为它们代表了进入对象状态的“窗口”。每当对象的相关内部状态发生变化时，通常是方法调用的结果，都应该计算计算属性。我避免公开可以通过属性引用操作的对象；属性总是可以重新产生或重新计算的基本元素，或者是具有相同特征的其他“数据”对象的集合(通常是从其他来源克隆或缩减的)。如果一个对象需要公开它的一个内部子对象的信息，我会将该信息从内部源复制到外部对象本身的一个原始属性中。如果信息本身是具有多个属性的对象的形式，那么我将它们展平成外部对象上的单个属性。最终结果是对象的状态总是在内部生成，作为方法调用的结果，并且不能在外部操作，除非通过它的公共 API(方法)。

最后，共享数据应该存在于“包”中——小心翼翼地保护数据的对象，并且只有*在被请求时通过值向调用者传递*数据。例如，《哈姆雷特》中关于 owleyes.org 的一章可能包含数百个注释。注释可以在客户端代码中创建、编辑、删除和接收回复。注释包负责保存注释数据，并按照请求以只读格式将其传递给其他模块，以便它们可以相应地呈现自己(或执行计算)。当一个注释*改变*时——当一个 owleyes.org PUT 请求被发送到 API 并且接收到一个成功的响应时 bag 上的一个方法被调用来更新注释。因为注释只能通过值来获取，所以对于启动更新的模块来说，直接操作自己的注释对象上的属性没有什么好处。没有其他模块会收到更改。相反，负责的模块告诉 bag 通过向它传递从 API 响应反序列化的新注释来更新注释。bag 替换其内部集合中的注释，然后引发一个事件来通知监听模块给定的注释已经更改。任何对注释感兴趣的模块——或者所有注释——然后请求更新的数据(只读格式)并重新呈现自己(或者重新计算其内部状态)。那么，这个包就是模块之间的共享资源(*而不是*直接的数据)，它是所有数据请求的真实来源。

## [](#epilogue)后记

关于在这个项目的执行过程中出现的模式和原则，我还可以说得更多，但是在将现有代码移植到新的上下文中时，上面列举的那些是最重要和最重要的。可重用代码不容易写。它不是自动的。这是思想和纪律的结果，随着锻炼慢慢变成习惯。

并非所有代码都将被重用；事实上，大多数人不会。但是从长远来看，从扩展和重用的角度来编写代码可以节省时间和精力。不过，这是一种权衡。可重用代码越多，它拥有的重定向层就越多，这就需要增加模块、类、函数等的数量。需要被创造出来。这是一种折衷，可以通过保持代码尽可能简单来缓解。如果一个人能够对代码进行推理，预测什么模块(等等),那么他就可以相对容易地浏览代码。)做什么以及它们是如何通过推理联系起来的。

虽然我不能保证你的经历会和我的一样愉快，但我确实相信，如果你思考并把这些模式和原则付诸行动，有一天你会体验到*真实地*告诉你的经理，“哦，那只需要两周！”因为你的勤奋产生了精心制作的、可重用的代码。

* * *

这篇文章最初出现在 nicholascloud.com。