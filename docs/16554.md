# 物体三定律

> 原文:[https://dev.to/sandordargo/the-three-laws-of-objects-381o](https://dev.to/sandordargo/the-three-laws-of-objects-381o)

物体三定律。听起来够朗朗上口吧？对我来说，是的。我在肯·普的《预测》中读到了这些定律。

如果你感觉到阿西莫夫的[机器人三定律](https://en.wikipedia.org/wiki/Three_Laws_of_Robotics)来自 [I，机器人](https://amzn.to/2Rp2sD8)，这不是巧合。这是作者的目的。

够了，桑德尔，给我看看法律——你可能会说，你是对的。给你:

*   一个对象应该做它的方法所说的事情
*   一个物体不会造成伤害
*   如果一个对象不能执行所请求的操作，它应该通知它的用户

让我们逐一展开。

## 一个对象应该做它的方法所说的事情

让我们把这条定律分成两段。

### [](#a-rose-by-any-other-name-is-not-a-rose)玫瑰用任何别的名字都不是玫瑰

对于系统中的每个概念，您必须创建一个明确定义的名称。一个定义明确的名字。坚持下去。

名称是方法本身的重要部分。这意味着，如果您更改了名称，但保持代码不变，该方法就变成了另一个方法。一个新的名字至少会有稍微不同的含义，所以从概念上来说这个方法会改变。如果你开始同时使用旧名字和新名字，情况会更糟。

如果马格里特的名画叫做“这是一根管子”，它会是同一件艺术品吗？

[![The Treachery of Images from https://knowyourmeme.com/memes/this-is-not-a-pipe-parodies](../Images/cbfa4111876257410e5b2b645830b8f6.png "The Treachery of Images from https://knowyourmeme.com/memes/this-is-not-a-pipe-parodies")T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Pjce209o--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/v1/%7B%7B%20site.baseurl%20%7D%7D/assets/img/magritte-this-is-not-a-pipe.jpg)

### [](#principle-of-least-surprises)最小惊喜原则

因此，对于给定的对象/方法所使用的给定概念，我们有一个明确定义的名称。同样重要的是，代码要做到名称所合理表示的那样。

该方法不做任何其他事情是必要的。它不应该给我们带来一些不必要的惊喜。书中用到了`delete`和`remove`的例子。假设你在一个数组中存储了对一些对象的引用。一个`remove`操作应该删除被引用的对象本身吗？或者应该用一个`delete`操作从列表中删除引用吗？

好问题。

给定一个名字，这个方法应该做你所期望的事情。你的期望可能基于简单的英语或者公司的字典，最重要的是保持一致。

但是惊喜还是会出现。如果你的函数不是[幂等](https://en.wikipedia.org/wiki/Idempotence)呢？这意味着你用相同的参数列表连续调用它两次，它不会返回相同的值。你会感到惊讶吗？除非底层数据源没有改变，否则很可能会改变。但是让我们说，[看情况](https://dev.to/thorstenhirsch/poll-do-you-know-what-idempotent-means-4759)。就像一些不想要的副作用改变了你的对象的状态，即使它应该是一个吸气剂。显然，函数式编程是一个可能的答案，至少可以保证最少的意外。

关于名字，请记住一个好名字取决于你。你有责任在你交付的代码中很好地命名事物。

## [](#an-object-shall-do-no-harm)一个物体不会造成伤害

在最小惊奇原则之后，第二定律似乎是显而易见的下一步。除非一个函数/对象伤害自己是你所期望的。什么被认为是伤害？

[前置](https://amzn.to/2VoCO0k)以一个对象创建 widgets 为例。在该程序中，对于每个小部件的创建，必须从文件中读取配置。但是负责创建这些小部件的对象并没有在不需要它们时立即关闭配置文件，而是在很久以后才在销毁时关闭。正在运行的操作系统可以同时打开 20 个文件。

因此，最多只能创建 20 个小部件。创建窗口小部件的对象是有害的，因为它锁定了不必要的资源。

在 C++中，甚至更容易创建一些有害的对象。想想对象在自己之后留下内存泄漏。它们有害。多少钱？那取决于泄漏的大小。如果您在必须处理所有权时使用原始指针，那么可以肯定的是，您最终会发现自己正在修复内存泄漏。想了解更多关于内存泄漏的知识吗？[先看看这个维基百科页面](https://en.wikipedia.org/wiki/Memory_leak)。雷，我的意思是 [RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) 应该是你学习处理内存泄漏的不同方法时的好朋友。

如果你使用一种不直接控制对象析构的语言——因此你依赖于垃圾收集器——你必须特别注意手动释放资源。

但是就算用 C++这样的语言，也要三思，什么时候可以释放一些资源。越快越好。

## 如果一个对象不能执行所请求的操作，它应该通知它的用户

根据物体第三定律，如果一个物体面临麻烦，它永远不会保持沉默，它必须说话！它可以打印到日志中，它可以返回一些错误代码或者抛出异常。如你所愿，或者更好地说，在这种情况下是有意义的。

这条定律背后的要点是，如果对象无声地失败了，或者做了修复动作而没有报告，那么调试将变得非常困难。假设您有一个函数，它应该向 list 添加一个新元素，但前提是这样的元素还不是 list 的一部分。举个例子，假设你有一个大车库，你有一个叫停车场的功能。你的法拉利已经在车库里了，但是你又用你的法拉利调用了这个方法:

```
garage.park(myFerrari); 
```

如果这个方法什么也没做，或者它用这个替换了你以前的法拉利实例，很可能你只是掩盖了一个错误，这个错误以后会变得更加令人生畏。但是，当错误再次出现时，您将没有可以帮助您更容易地进行调查的所有日志。

就像在管理中一样，一旦软件中出现问题，也要立即报告。

## [](#conclusion)结论

在这篇文章中，我们读到了物体的三大定律，正如肯·普在他的书《前因子化》中所描述的。根据这些定律，物体应该如它们的名字所暗示的那样行动，它们的行为不应该引起惊奇。当他们照他们所说的去做时，他们不会在系统或邻近的物体中留下任何伤害。最后但同样重要的是，对象应该报告它们的困难，这样你就可以在问题出现的早期就意识到它们。

编码和阅读快乐！

*本文最初发表在[我的博客上。](http://sandordargo.com/blog/2019/01/08/three-laws-of-objects)T3】*