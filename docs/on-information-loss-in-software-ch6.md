# 论软件中的信息丢失

> 原文：<https://dev.to/ilya_sher_prog/on-information-loss-in-software-ch6>

“信息丢失”是看待世界的一种方式。话题很广。这篇博文将关注计算机软件开发和运行过程中的信息丢失。

这篇文章讨论了为什么信息丢失是不好的，并给出了一些例子。

我希望读完这篇文章后，你能更容易地发现信息丢失。这将帮助您避免信息丢失，消除昂贵的信息恢复阶段。一些示例包括如何避免信息丢失这种特殊情况的具体建议。

## 信息丢失定义

就本博客而言，信息丢失是指信息`I`可用，并且在时间点`t1`容易访问，但后来在时间点`t2`需要时，信息要么不可用，要么不容易访问。

该职位将提出各种类别的信息损失的例子。该清单并不详尽；这不是命中注定的。目的是给出一些例子来帮助你获得感觉，并开始从信息损失的角度来看问题。

## 为什么信息丢失是坏事？

在许多信息丢失的情况下，丢失的信息可以恢复，但这需要投入资源(时间和/或金钱)。这是我想帮助你避免的情况。

## 介于头部和代码之间

当在软件上工作时，信息丢失首先发生在程序员将想法转化为代码的时候。这一阶段的信息丢失将表现为在代码审查或仅仅是代码阅读期间每分钟增加 [WTF。每次阅读代码时，当读者重构代码背后程序员的想法时，会有额外的认知负荷。](https://www.osnews.com/story/19266/wtfsm/)

我已经确定了头到代码阶段信息丢失的两个主要原因:

*   程序员的错误
*   强加的编程语言

### 由于程序员的过错造成的信息丢失

一个程序员经验越丰富，这个阶段信息丢失的可能性就越小。

#### 命名错误的变量

在程序员脑袋里:`number of servers running the ETL task`。代码中变量的名称:`n`。代码审查时的 WTFs 保证。

#### 误命名的函数

我很确定`getUser()`不应该更新数据库中用户的姓氏。这样的命名是违法的，但不幸的是，我见过类似的代码。

#### 使用神奇的数字

`if (result == 126) ...`。写`126`的人知道这个数字意味着什么。阅读代码的人需要花时间检查这个数字的含义。人们应该使用常数或枚举来代替:`if (result == NOT_EXECUTABLE) ...`。

#### 代码中缺少注释

最重要的评论是关于为什么做某事，而不是如何做。如果一个人的代码是用高级语言编写的，并且质量很好，那么他很少需要对正在做的事情或如何做做评论。另一方面，像“解决 API 错误:它返回 false 而不是空数组”这样的评论是非常有价值的。

#### 数据类型的不正确用法

例如，一个人的列表不仅仅是一个列表。它有语义。当数据使用正确的类型时，理解程序就容易多了。Java 有[泛型](https://docs.oracle.com/javase/tutorial/java/generics/index.html)来传达这样的信息，比如`List<Person>`。其他一些语言也有足够强大的类型系统来传递这样的信息。

### 编程语言强加的信息损失

编程语言的局限性导致代码的表达性较差，因为程序员头脑中的想法不能以直接的方式表达出来。代码的读者会更加努力(阅读浪费时间)去理解代码。

#### 未命名的函数参数

bash 和 perl5(对 perl5 不再有把握，有一些实验性的东西)没有指定函数参数名的语法。这使得代码缺乏表现力。有时候程序员会做“正确的事情”:

```
myfunc() { local target\_file=$1 ...} 
```

…但是当它们不存在时，你用一个未命名的参数结束，想知道它可能意味着什么:

```
myfunc() { if [[-f $1]];then ... fi} 
```

这是要生成的文件还是源文件？你不知道，你必须继续读下去，希望得到答案。

建议:即使您的语言不支持命名参数，也要模拟它们。

#### 将字符串扩展成几个自变量(bash)

```
rm $x 
```

这是删除一个还是几个文件？程序员的意思是什么？你根本不知道。这取决于`x`的*内容*，它通常被空格分割成参数。如果您能从变量名推断出它是一个还是几个文件，那您就很幸运了。

从今天的角度来看，这只是糟糕的设计。回想当年，我想这是实现数组的最实用的方法。

建议:使用两个备选方案中的一个 blow，不要使用`rm $x`形式。

*   单个文件:`rm "$x"`(正确引用)
*   多个文件:`rm "${my_files[@]}"` ( [猛击阵法](https://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html))

旁注:当`x`偶然包含一个空格时，这个“特性”在过去几年里引起了如此多的痛苦。即使当`x`打算用作数组时，该数组的*元素*也可能意外包含空格。

#### 错误处理

在不支持异常的语言(bash、C、Go)中，程序员被迫进入两种情况之一:

*   编写忽略错误的不正确的代码(有意还是无意，看是哪一个)
*   编写处理错误的详细代码。当代码处理每一个可能的错误时，错误处理会变得混乱，需要更多的时间来理解代码。这就是信息丢失的情况，因为读者被代码淹没了。

在 [NGS](////ngs-lang.org/) 中，由于典型的用例是脚本，我希望代码简洁。这就排除了随结果一起返回状态代码的可能性，因为调用者会被迫检查它。让 NGS 拥有异常，让脚本决定是捕捉它们还是让整个脚本因为一个未捕捉到的异常而错误终止，这确实更有意义。

#### 无序的哈希/映射/字典数据结构

在某些语言中，哈希数据结构是以非保序方式实现的。这意味着在键/值对的顺序很重要的情况下，程序员不能自由地表达意图。当程序员通过实现他/她自己的有序字典来对抗这种语言时，这就导致了可读性更差的代码。

在这种情况下，信息丢失就是再次看不到程序员的意图。

幸运的是，现在许多现代语言已经解决了这个问题:

*   Python 通过在 Python 2.7 中添加 [OrderedDict](https://docs.python.org/2/library/collections.html#collections.OrderedDict) 解决了这个问题。
*   Ruby `Hash`从 1.9 版开始变成了[订购。](https://www.igvita.com/2009/02/04/ruby-19-internals-ordered-hash/)
*   JavaScript 有[映射类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)。旧的[对象类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)文档没有提到任何关于订单的内容，所以我认为它没有得到保证。

建议:检查你的语言是否有你真正想用的数据结构，无论是内置的还是库中的。

#### 有限数据结构(bash)

在 bash 中处理数据结构或多或少会产生复杂的代码，这取决于需要处理的数据结构。这是 bash 正好支持三种数据结构的直接结果:

*   标量(有时可被视为数字或数组的字符串)
*   排列
*   关联数组

这些数据结构不能嵌套。

结果是代码可读性差得多，与其他流行语言(Python、Ruby 等)中的数据操作相比，作者的原始意图更难恢复。

建议:对于繁重的数据操作代码，考虑使用 bash 之外的其他语言。

#### 缺少不可空的类型

在某些语言中，没有直接的方法来指定不可为空的参数。然后要求程序员检查每个传递的参数是否是`null`。这导致了更多的样板代码。让我们看看下面这段来自流行的 Apache Flink 项目的 Java 代码:

```
// flink/flink-java/src/main/java/org/apache/flink/api/java/DataSet.javaprotected DataSet(ExecutionEnvironment context, TypeInformation<T> typeInfo) { if (context == null) { throw new NullPointerException("context is null"); } if (typeInfo == null) { throw new NullPointerException("typeInfo is null"); } this.context = context; this.type = typeInfo;} 
```

#### 异步计算模型(JavaScript)

例如，在 JavaScript 中，越来越多的可读代码使用:

*   [回调](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function)
*   [承诺](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
*   [异步/等待](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)

同样，当程序员的意图在代码中丢失时，就会发生信息丢失，因为代码看起来像是与异步性和语言的一场大斗争。

建议:宁要`async/await`不要承诺，宁要承诺不要回拨。

#### 语义信息丢失(JavaScript)

JavaScript 中的`console.log()` vs `debug('my-module')('my message')`。当程序员选择使用`log()`而不是`debug()`时，语义信息就会丢失。在这种情况下，这意味着在输出中找到所需信息需要更多的努力，而不是简单地打开和关闭相关的调试部分。

建议:使用[调试](https://www.npmjs.com/package/debug)模块。

## 运行时信息丢失

运行时的信息丢失将表现为调试更加困难。

#### 空 Catch 子句

这是一名边缘罪犯。除了在极少数情况下，空的 catch 子句确实是合适的，通过在代码中放置空的 catch 子句，你正在为你的同事设置一个炸弹。他们会付出时间、眼泪和精神健康，更不用说他们会恨你。信息流失在哪里？在异常生成时，会有关于发生了什么的有用信息。空的 catch 子句会丢失该信息。结果:很难找到异常及其原因。

在 [NGS](https://ngs-lang.org/) 中，有明确的方式来表达你不只是忘记处理异常(`try ... catch(e) { }`)，而是你实际上不在乎(或确切知道)发生了什么:

*   `try EXPR`完全没有`catch`子句。如果 EXPR 抛出异常，`try EXPR`求值为`null`，否则求值为`EXPR`。
*   `EXPR tor DFLT`如果 EXPR 抛出异常，则求值为`DFLT`，否则求值为`EXPR`。

#### 写到`stdout`而不是`stderr`

`stdout`具有语义(计算结果),`stderr`也具有语义(错误描述)。这将使任何包装器脚本更难处理向`stdout`输出错误或向`stderr`输出结果的程序。关于文本的语义信息丢失了，如果两个输出被混合，则需要由调用者恢复。

#### 错误的退出代码报告

这个真的阻碍了自动化。

```
if ... then { ... error("error occurred") exit(0) # incorrect error code reported} 
```

由于很容易忘记退出代码，而且常见的情况是`exit()`意味着程序异常终止，在 NGS `exit()`中，不提供退出代码默认为退出代码 1。

#### 错误退出代码处理

```
if [-e MY\_FILE] ... 
```

这是所有的 bash 脚本…这是错误的。哪些退出代码`[`程序/内置返回？0 代表“是”，1 代表“否”，2 代表“发生了错误”。你猜怎么着。你不能用两个`if`分支处理三个不同的案例；“出现错误”导致`if`的“假”分支被采用。如果幸运的话，您会在`stderr`上看到错误信息。如果你运气不好，你的脚本在某些情况下会不正常工作。

在这一点上，NGS 的权衡是为了正确，而不是简单。`if $(test -e MY_FILE) ...`在 NGS 可以走三条路:“是”分支，“否”分支和例外。任何外部进程完成后，NGS 检查退出代码。对于未知进程，非零退出代码会引发异常。对于`test`和其他几个，零和一不会导致异常。退出代码检查工具是可扩展的，人们可以很容易地“教”NGS 新程序。

## 开阔你的视野——临时演员

我将在这里提到非严格意义上的软件开发相关的信息丢失案例。

### 未标记的云资源(AWS)

您是否刚刚创建了一个 EC2 实例并将其命名为`Server`,或者您根本没有标记它？恭喜，语义信息刚刚丢失。你的同事将努力理解实例的作用是什么。

建议:严格标记资源，对未标记或标记不当的资源发出警报。在 AWS 中，您还可以通过查看 [CloudTrail](https://aws.amazon.com/cloudtrail/) 来知道是谁创建了资源。

附注:在 Azure 中，任何资源都必须属于一个“资源组”,这使得跟踪资源更加容易。

### GUI

您刚刚在 GUI 中执行了操作。发生了什么的信息在你做手术的那一刻就丢失了。祝你好运复制或记录它。

在 NGS，解决这一问题的计划是为通过 GUI 执行的每个操作提供文本表示。

### 字符串串联

每次将两个字符串连接成一个字符串时，都会丢失一些信息。

建议:在生成输出时，考虑使用结构化数据格式，而不是在以后解析非结构化文本(连接的结果)。(例如:JSON)。

* * *

希望有帮助。玩得开心！