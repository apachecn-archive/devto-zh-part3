# 上下文对于软件设计至关重要

> 原文：<https://dev.to/pbeekums/context-is-essential-to-software-design-1765>

最佳实践听起来很棒。为什么我们不想确保我们的软件是最好的呢？如何比使用每个人都认为最好的实践更好地做到这一点呢？这是我职业生涯早期非常关心的事情。

[![](img/35084f1010dde3f8599c1465be1e70fd.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--JkMpQS4e--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2019/context.jpeg)

我在各种各样的情况下工作过:小公司到大公司，消费产品和 B2B 产品，纯软件公司和出售实物的公司，新软件到大型成熟系统。这帮助我艰难地认识到，虽然有一些软件实践平均来说是好的，但重要的是要始终考虑到你构建软件的环境。

我们以微服务为例来看。一群开发人员批评 monolith 系统已经成为一件很平常的事情。我肯定是这些讨论的一部分，过去很少为独石辩护。让 20-30 名开发人员为一个代码库贡献代码是一件相当麻烦的事情，尤其是当有人想要修改“核心”代码或更新库的时候。让每个团队维护他们自己的微服务集可以解决很多问题。

然而，微服务有巨大的开发开销。根据定义，每个都将位于自己的存储库中。如果你有一个需要修改多个微服务的特性，事情就变得复杂了。这也使部署变得复杂，因为您必须确保以正确的顺序部署所有内容，并且不破坏向后兼容性。这在 monolith 中不是问题，因为所有代码都是一次性部署的。

微服务也增加了基础设施开销，因为它们都需要自己的监控和备份。关于这些有趣的事情是，你往往想要定期测试这些，以确保它们仍然工作。发现所有备份都被破坏的最糟糕的时候是你真正需要它们的时候。更多的微服务意味着花费更多的时间进行测试。

对于一家成长中的公司来说，微服务也使入职流程变得复杂。对于新开发人员来说，一套微服务的设置要比 monolith 复杂得多(除非 monolith 的设置非常糟糕)。这可以通过 Docker 来缓解，但是无论何时添加新的微服务或者对现有的微服务进行系统更改，都需要有人来维护 Docker 设置。

最终，一个由少数开发人员组成的团队可能会在一个整体中做得最好。对于每一个新的开发者来说，维护一个整体的开销最终会超过微服务的开销，此时应该考虑过渡。在此之前构建微服务弊大于利。

另一个例子是将数据捆绑在一起以提高效率。在 SQL 数据库中，我们可以通过连接查询做到这一点。在 NoSQL，我们可以通过在文档中嵌套更多的数据来做到这一点。这很有道理。当您可以只进行 1 次查询时，为什么要对数据库进行 2 次或更多次查询呢？以这种方式进行优化有助于在中短期内进行扩展，并且有助于提高性能。

不幸的是，从长远来看，这方面的多重挑战开始出现。让我们假设您遇到了一个问题，您认为将您的整体拆分为微服务是一个好主意。将大部分数据捆绑在一起会限制您这样做的能力。您最终会遇到这样的情况:您不得不分析所有数据以找到合适的拆分，却发现没有多少数据可以拆分。为了进行这种转换，必须重写大量代码来分离数据。

这也使得伸缩变得困难，至少对于 SQL 来说是这样。SQL servers 并不以水平扩展著称，单个服务器只能做这么多。拥有大量的连接使得很难将表拆分到它们自己的数据库中，因为不能跨多个服务器运行连接查询。这也使得对数据库进行分片变得困难，因为您必须确保所有需要加入的数据都在同一个分片上。

也就是说，确保你所有的数据都是独立的有它自己的问题。除了进行更多查询的性能开销之外，您还必须处理管理所有独立数据源的更多开发开销。

这里没有正确的答案。做什么是“最好的”取决于你在构建什么样的软件，以及你在为谁构建。每种方法都有利弊。你不能简单地挑选某样东西，因为其他人都认为它是最佳实践。你的特殊情况必须被考虑进去。每一个设计决策都必须有一个真正的理由，而不仅仅是因为事实如此。