# 强制解包不仅仅是“不像 Swift”这是不对的。

> 原文:[https://dev . to/evandeaubl/force-unwrapping-is-not-just-not-swift-like-its-error-GCM](https://dev.to/evandeaubl/force-unwrapping-is-not-just-not-swift-like-its-wrong-gcm)

Swift 提供了许多功能来帮助开发人员编写正确的无错误程序:可选功能、安全转换和内置错误处理。但是对于其中的每一个，都有一个出口:`!`，力展开操作符。

你可能认识另一个开发人员或团队成员，他在强制解包方面有点草率。或者你不想做额外的样板文件来打开一个可选的，所以你在“没人看”的时候做。

对于为什么安全解包是好的而强制解包是坏的，你可能没有很好的理由，除了 Swift 文档是这样说的，或者“就是这样做的。”

安全解包背后的原因来自历史悠久的语言，这些语言不提供像这样的强大的安全性。这经常导致试图将随机内存位置解释为对象，这在最好的情况下会导致崩溃，在最坏的情况下很难调试应用程序的行为。不使用 Swift 的所有安全机制不仅不像 Swift，也是糟糕的编程。

* * *

Swift 做了很多工作来使安全解包易于使用，但有时使用`!`的吸引力非常大。只要把它放到你的代码中，你就可以忽略一些你通常需要的零检查、错误捕捉或类型转换。这是一种错误的思考方式；**你不应该把`!`当成一条出路。**

使用`!`是说你比你的编译器更懂；你可以通过所有的路径和代码的使用进行推理，不仅仅是现在，而是未来所有可能的使用，并决定你的强制解包是安全的。**新闻快讯:**编译器关于代码的推理；解释代码以产生可执行的输出是他们存在的唯一理由。在保护你的安全方面，他们会比你做得更好。

操作符是一个很好的字符选择——也许吧🚨会更好，或者🔥——因为**你应该警惕**你在代码中看到的任何地方。无论你在哪里看到`!`操作符，要么定义一个隐式展开的属性，在一个可选的`as!`或`try!`之后，你不应该认为“这将是好的，所以我是强制展开的。”你应该想，“这是一个我已经指定我的代码可以崩溃的地方。”当你用这些术语来描述它的时候，你会更有动力去用避免这种情况的方式编码。

你现在可能会说，“但是我需要与 Objective-C nsdictionary 或 NSArrays 接口，我知道它们包含所有的字符串，或者所有的整数，所以我想强制打开它，然后继续。”您可以——也应该——仍然对 NSDictionarys 和 NSArrays 使用安全的解包和强制转换。

考虑一下这个:

```
var foo: NSArray = NSArray(arrayLiteral: 5, 6, 7)

if let bar = foo as? [Int] {
  print(bar.reduce(0, +))
}

if let bar2 = foo as? [String] {
  print(bar2)
}
// Will not print 
```

安全强制转换立即检查所有元素，因此第一个`if let`打印 NSArray 元素的总和，而第二个`if let`失败，因为元素不是整数。在收到 NSArray、NSDictionary 或其他松散的 Objective-C 类型后，尽快这样做，然后您的 Swift 代码将专门与更严格的 Swift 类型一起工作。

如果您的代码中有强制解包、强制转换或`try!`操作，那么几乎总是有一些方法可以让您重新构建代码，使其变得安全。去掉你的`!`s；你未来的自己会为此感谢你的。

* * *

你喜欢这个建议吗？关于[的下一个技巧在 Swift](https://www.appsdissected.com/bool-objcbool-swift/) 中使用 Objective-C BOOLs 可能会遇到的编译时错误已经在等着你了。或者[注册，让每一条建议都直接进入你的收件箱。](https://www.appsdissected.com/newsletter/)

这篇文章最初发表在 [Apps 剖析。](https://www.appsdissected.com/force-unwrapping-not-swift-like-wrong/)