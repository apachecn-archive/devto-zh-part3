# API 网关不是新的独角兽

> 原文:[https://dev . to/alom barte/an-API-gateway-is-the-new-unicorn-2kk 2](https://dev.to/alombarte/an-api-gateway-is-not-the-new-unicorn-2kk2)

我们与人们谈论 API 网关的次数越多，我们就越意识到这个术语对不同的人有不同的含义，更具体地说，我们看到了一个不断增长的趋势，即开发人员(但主要是管理人员)希望 API 网关能够创造奇迹，通常离其预期用途还有很长的路要走。

这就好像 API 网关是新的独角兽，它将解决所有问题，并使微服务场景中的一切都变得精彩。

我们写这篇文章是为了围绕 API gateway 模式展开一场对话，并强调一些通常被忽略的部分，这些部分导致了模式实现中的误解或错误。这是因为周围的许多定义是有偏见的，并试图向你推销一种一刀切的解决方案。

让我们从头开始:由于 API 网关只在有几个服务的环境中有意义，这里提醒一下微服务模式。

## [](#the-microservice-pattern)微服务模式

在微服务时代的开端，Martin Fowler 列出了微服务架构的共同特征。并非所有微服务架构都具有所有这些特征，但它们往往具有以下大部分特征:

1.  通过服务的组件化
2.  围绕业务能力组织
3.  产品而非项目
4.  智能端点和哑管道
5.  分权治理
6.  分散数据管理
7.  基础设施自动化
8.  故障设计
9.  进化设计

## API 网关试图解决的问题

网上引用最多的 API 网关模式描述之一在 Chris Richardson 的 [microservices.io](http://microservices.io/patterns/apigateway.html) 网站上。文章用以下问题介绍了微服务模式的**问题**:

> 基于微服务的应用程序的客户端如何访问单个服务？

本文中给出的问题定义和建议的解决方案都是一个完美的切入点——但是它们可能会导致一个主要的误解。让我们首先分析问题的定义，然后对照引用的微服务定义进行测试。

1.  谁是基于微服务的应用的客户？根据定义，它们应该是应用程序本身:移动应用程序、网站、SDK 用户等。
2.  什么是基于微服务的应用？不是服务，这是肯定的。没有一家公司为了构建单一服务而采用微服务模式。它更可能是一个服务生态系统，每个服务负责一个小的、有限的功能集
3.  为什么客户会访问任何服务？他们宁愿消费用例。当然，每个用例可以是 N 个服务的组合，但是这与客户端本身无关。

我们希望对问题更好的定义**更宽泛，可以是这样的:**

> **基于微服务的生态系统的客户端如何使用他们的用例？**

此外，市场上任何 API 网关针对此问题提供的任何解决方案都应该对照基于微服务的生态系统的共同特征进行检查。

## API 网关解决方案

API 网关解决方案不是市场上任何特定产品的答案，因此它应该符合这个**抽象定义**:

> API 网关是解决**客户如何在微服务模式**内基于微服务的生态系统中使用用例的问题的一种方式

回到我们之前提到的 [microservices.io 文章](http://microservices.io/patterns/apigateway.html)，它提出了这个问题的解决方案:

> API 网关]是所有客户端的单一入口点。API 网关以两种方式之一处理请求。一些请求被简单地代理/路由到适当的服务。它通过分散到多个服务来处理其他请求。

如果我们接受 API 网关的抽象定义，这个断言将会变得不完整，有些部分是错误的。让我们从错误的开始:

1.  根据定义，API 网关**不应该是微服务生态系统**中的单一入口点，因为它将加强集中化、协调性，并具有单点故障的**。API 网关应该是**一些用例集**的入口点，您应该分析如何在不同的 API 网关服务中对这些用例进行分组。与任何其他微服务一样，服务的范围至关重要。否则，我们就把整块石头从 API 移到了网关上！**
2.  **代理不在 API 网关层**的范围内，因为它意味着客户端完全耦合到服务实现，而不是它们试图覆盖的用例。在微服务模式流行之前，有很多好的代理，它们解决了一个非常不同的问题。

同样的文档做了一个变化，为每种客户端类型添加了一个 API 网关，并将其称为前端的后端

> 这种模式的一种变体是后端对前端模式。它为每种类型的客户端定义了单独的 API 网关。

这个模型更接近于我们之前接受的最初的抽象定义。但是**之前的定义**中缺少的是:

1.  API 网关将客户端从客户端正在使用的用例中涉及的实际服务中分离出来(不管一个用例中涉及多少个客户端)。
2.  API 网关对于每个用例都有一个专用的端点。每个用例可以被多个客户端使用。
3.  如果可能的话，用例应该是幂等的。
4.  一个用例不能包含外部资源/服务之间的顺序事务。

最后，对这种方法的最大反对意见是，它为许多不良实践打开了大门:单一入口点概念和最后一句话:

> API 网关还可以实现安全性，例如验证客户端是否被授权执行请求

**小心！**这意味着 API 网关是实现微服务环境所需的所有*横向特性*的好地方。要做到这一点，不破坏每个微服务的某些预期特性是不可能的。

## [](#so-what-can-be-expected-from-an-api-gateway)那么，对 API 网关有什么期望呢？

以下是您可以从 API 网关中期望得到的一些东西:

*   **服务器端请求验证**:在到达后端之前，可以注入一些服务器端请求验证，但是这些验证不需要任何外部请求。你可以验证 JWT 的签名，但是你**不应该在送达之前要求第三方**进行验证。

*   **QoS 优化**:对于服务的*质量和改善用户体验，有几种策略可用。所有这些都基于关键概念:*

    *   **将来自单个客户端的请求**分组到后端，作为*用例*
    *   **并发发送多个请求，滥用后端服务的等幂性**。在[并发请求文档](https://www.krakend.io/docs/endpoints/concurrent-requests/)中有更多相关内容。
    *   **收缩响应**以包含不可或缺的数据，因为它改善了客户端的响应时间和带宽消耗。
    *   减少从客户端发送的请求数量(http 头缓存)
*   **请求和响应操作**:API 网关可以并且应该执行某种请求和响应操作，以满足每个用例。

*   **与已有服务发现的交互**:与已有服务发现的无阻塞交互是完全合理的。协调这些互动并不容易。

*   **分布式速率限制和节流**:引入可以在服务的孤立、分布式实例上运行的特性是可以的，但是对每个集群施加硬性限制是不现实的(如果我们关心整体性能的话)。

*   **断路器**:检测故障，防止给你的生态系统带来压力。

*   **多种编码和协议**:因为您的服务可能是多样化的。

*   **指标收集**:为了了解这一层发生了什么，只要这是非阻塞的，并且不依赖于一个集中的位置。

*   **干净的 API 版本控制贡献者**:您可能希望为您的网关保持干净一致的版本控制，这与您的每个内部服务的版本控制完全无关。

## [](#what-you-shouldnt-expect-from-an-api-gateway)你不应该对 API 网关有什么期望

来自 Thoughtworks ( [PDF](https://assets.thoughtworks.com/assets/technology-radar-vol-17-en.pdf) )的最新[技术雷达让我们会心一笑，因为他们和我们一样看待 API 网关:](https://www.thoughtworks.com/radar)

> 我们仍然关注中间件中实现的业务逻辑和流程编排，特别是在创建单点扩展和控制时需要专业技能和工具的情况下。在竞争激烈的 API 网关市场上，供应商们通过添加特性来延续这一趋势，他们试图通过这些特性来区分他们的产品。这导致了**过于雄心勃勃的 API 网关产品**,其功能——本质上是一个反向代理——鼓励了继续难以测试和部署的设计。API 网关确实提供了处理一些特定问题的工具——比如认证和速率限制——但是任何领域的智能都应该存在于应用程序或服务中。

对我们来说，哪些功能可以进入 API 网关而哪些不应该进入的界限可以用一句简单的话来概括:

> 任何不需要其他服务或共享状态的帮助就可以在 API Gateway 中验证或创建的东西都是合适的。其他的，把它拿开。

例如，如果您收到加密的角色，并且想要解密它们并根据网关配置中的 ACL 进行验证，请执行此操作。如果您想使用外部数据库查询 ACL，请不要这样做。

因此，根据简单的经验法则和已经讨论过的特征列表:

*   API 网关不应该是单点故障
*   API 网关不应该是集中式的或同步协调的
*   API 网关不应该用作集中配置点
*   API 网关不应该依赖于状态
*   API 网关不应该仅仅是另一个微服务
*   API 网关不应该知道任何封装在其后端的业务逻辑

## [](#summary)总结

微服务模式提出了一种解决方案，通过将系统分解成更简单、更紧密的组件，并将部分责任委托给客户端，向去中心化迈出了一大步，从而处理某些环境的巨大复杂性。

API 网关模式是一种在基于微服务的生态系统中减少委托给客户端的复杂性的方法，它通过添加更多的微服务来负责处理一些复杂性，而不破坏微服务的任何特征。这种服务确保管道仍然是哑的，同时使客户端开发人员的生活更加轻松。它不能帮助后端服务公开它们的资源、编码输入/输出或检查用户是否有足够的特权来消费所请求的资源。

最后，如果我们考虑到 [**CAP** 定理](https://en.wikipedia.org/wiki/CAP_theorem)，并且我们正在考虑在客户端和它们使用的资源服务器之间添加一个新的层，那么究竟为什么会有人向这个新的微服务层添加依赖于系统一致性( **C** )的特性呢？我们想从 fat 数据库转移到 fat API 网关吗？如果是这样，也许我们应该使用那些组件已经存在的名称:边缘服务、企业服务总线、API 管理器...而且我们也应该问问那些收养他们的公司:为什么你几年前就抛弃了他们？

丹尼尔·洛佩斯和阿尔伯特·隆巴尔特的原创文章

感谢阅读！