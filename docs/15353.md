# NPM 的语义版本控制

> 原文:[https://dev.to/thorning_m/semantic-versioning-with-npm-j98](https://dev.to/thorning_m/semantic-versioning-with-npm-j98)

当你发布代码时，给它分配一个版本号是一个非常好的主意。这为用户提供了一个有用的参考号，如果事情没有像预期的那样工作，他们可以发送给你(使跟踪 bug 变得更容易)，为你提供了一个安全点，你可以回滚到你知道事情正常工作的地方，正如你从 package.json 中的 dependencies 和 dev-dependencies 部分看到的，如果你计划构建一个从第三方来源获取代码的应用程序，这是至关重要的。

[![package.json screenshot](../Images/0ca9d8bc9ed553b5607cb7c709f03527.png)T2】](///static/137e6a9d875943cacf2ae52abc68ffac/7e0ae/pjson.png)

幸运的是，package.json 有一个`"version"`属性(如上所示),所以您可以增加这个属性并提交给 git，对吗？嗯，这是一种方法，但是它不能让其他使用你代码的人知道你所做的改变是小的错误修复还是大规模的，彻底的改变，这会使他们所有的代码变得完全无用。签出一个旧版本也不会特别容易，因为您必须搜索 git 日志来找到您更改 package.json 的提交(我希望您编写了一个描述性的提交消息！).

## [](#semantic-versioning)语义版本化

仅使用版本号，我们如何传达我们的变更对用户的影响的理解？语义版本控制(或简称 semver)允许我们让他们知道我们发布的代码属于三个类别中的哪一个:

1.  主要版本-这些变化将打破东西！如果您正在将一个依赖项更新到一个新的主要版本，那么您需要留出一些时间来重新编写代码，以确保它正确工作；不要在周五下午做！
2.  次要版本——这些变化是向后兼容的特性，不会破坏任何现有的代码，只会增加额外的功能。
3.  补丁版本——这些是向后兼容的错误修复，因此应该可以安全使用，而不必对使用它的任何代码进行更改。

版本号由三部分组成，每一部分由句号分隔:

**少校。次要补丁**

如果我们的代码在版本 *2.15.0* 并且我们修复了一个 bug，我们将发布版本 *2.15.1* 的修复。如果我们添加了一个不会破坏任何东西的新特性，那么这个版本将会被推迟到 *2.16.0* 。请注意，当次要版本增加时，修补程序版本变为零。接下来，假设我们决定重写大部分代码，改变一切；该版本将升级到 3.0.0 ，因为使用我们代码的任何应用程序都可能会被破解。同样，更改右侧的数字被重置为零。

重要的是要明白，除了右边的数字被重置为零之外，这三个部分是完全相互独立的，当你达到 100 个次版本或类似的东西时，你不会增加主版本。像 2.256.0 这样的版本号并不少见，因为开发人员试图限制他们发布的重大变更的数量。

## [](#git-tagging)去标记

所以我们现在可以通过 package.json 中的版本号让我们的用户知道我们的发布将会产生的影响，我们只需要一种明确标记(或标记)的方式！)在我们的 git 历史中的一次发布。为此，我们需要更改 package.json 中的版本号，然后:

```
git add .
git commit -m "Version 0.15.0 - new useful feature"
git tag 0.15.0 
```

要将新的提交和标记推送到远程存储库(如果您正在使用一个存储库的话)，您可以使用:

```
git push && git push --tags 
```

如果我们检查 git 日志，那么您应该看到有一个用我们的版本号标记的 commit。

[![git log screenshot](../Images/d233454c6b609f4ece3309c49e8127d5.png)T2】](///static/b81788485af6f454f7a5089c996e0b04/6f6e3/gitlog.png)

如果以后我们需要回滚到这个版本，我们可以通过键入:
来轻松完成

```
git checkout 0.15.0 
```

## [](#npm-version)NPM 版

这些都非常有用，但是每次你想发布什么东西的时候都有很多事情要做，尤其是当你考虑到这实际上并没有发布任何东西的时候！幸运的是，有一个命令可以帮我们做到这一点。要升级 package.json 的版本，创建一个新的提交，并用版本号标记它，可以使用下面的命令:

```
npm version major -m "Version %s - Breaking Changes!"
npm version minor -m "Version %s - New stuff in this release!"
npm version patch -m "Version %s - Hopefully this fixes stuff!" 
```

像提交一样，`-m`后面的字符串将是 git 日志中显示的提交消息。如下图所示,`%s`将取代版本号:

[![git log screenshot](../Images/23144e2b3466830bc7437f57b450a0e5.png)T2】](///static/e2799c4186bcc3a250f4974c07950f5c/aeb3e/gitlog_2.png)

默认情况下，NPM 会在版本号前面加一个`v`。我敢肯定这不会打扰大多数人，但它让我恼火，所以我把它关掉！要去掉`v`(如果你愿意，还可以添加其他东西)你可以添加一个. npmrc 文件到你的项目的根目录，包含下面这行:

```
tag-version-prefix="" 
```

## [](#pre-and-post-version-scripts)前后版本脚本

你使用 package.json 的脚本部分吗？如果没有，你应该，它非常有用！对我来说，典型的脚本部分包含运行 Webpack、节点服务器、Jest(用于测试)和发布脚本的脚本。这是我最近制作的一个聊天应用的 package.json 中的一张图片，可以让你有所了解:

[![package.json screenshot](../Images/417d76ef01772d78bf272b97035fcdc7.png)T2】](///static/68997688b0bd61ca0f9d3d99750cce06/9ce1f/pjson_2.png)

正如你在上面的图片中看到的，在底部附近有一个名为`postversion`的脚本。NPM 允许你为任何你喜欢的脚本创建前置和后置脚本。如果我想的话，我可以创建一个“premongo”脚本或者“post release-VPS ”, NPM 会在你期望的地方运行它们。这里，我使用一个`postversion`脚本将新创建的标记提交推送到远程存储库。如果我在一个项目中有 Eslint 或 Jest，那么我会在一个“preversion”脚本中运行它们，如果测试或林挺失败，那么版本脚本不会运行。

在这个用 [GatsbyJS](https://www.gatsbyjs.org/) 编写的应用程序中，我使用了一个“前版本”脚本来运行更漂亮的程序，它很好地格式化了我的代码(因为这个原因，我懒得在这个代码库中使用 linter)和一个“后版本”脚本来推送我的 git commit &标签，然后运行发布脚本来将我的代码推送到服务器:

```
"format": "prettier --write \"src/**/*.js\"",
"preversion": "npm run format",
  "postversion": "git push && git push --tags && ./release.sh" 
```

* * *

这就是我如何在 NPM 中使用语义版本控制来使我的发布变得快速而轻松，让我有更多的时间去做重要的事情！感谢您的阅读，如果您有任何意见、问题或更正，请随时在 [Twitter](https://twitter.com/thorning_m) 上给我发消息。