# 所有的不是:在极端干燥和 YAGNI 的尝试

> 原文：<https://dev.to/joshbruce/all-the-nope-an-attempt-at-extreme-dry-and-yagni-2om>

我已经在平台上工作了[8 倍](https://8fold.pro)。我做的大多数事情都可以归结为某种形式的实验。有时他们是出于哲学动机，也可能是出于其他原因。对于这个平台，我真的很想尝试:

极端不要重复自己(干)，你不会需要它(YAGNI)。

所以，如果我发现自己在权衡某个方法的利弊时，是基于这样一句话，“嗯，有一天我会需要 X，”我会停下来，删除这个推理，然后重新开始。

从鲍伯·马丁叔叔的一次演讲开始，这种精神状态就占据了我的大脑。在这本书里，他描述了关于[fitness](http://fitnesse.org)的最初发展。一开始，FitNesse 没有数据库，因为团队中有人说，“你知道，我们真的不需要*做这件事。”基本上就是把一切都保存在记忆里。我将把其余的留给谈话。*

当我作为 8fold 的主要支付处理器开始与 Stripe 互动时，我也开始更多地考虑这个问题。我欣赏 Stripe 的一点是，个人信息和信用卡识别信息永远不会触及我的服务器或代码。相反，我可以通过 API 从 Stripe 中提取某些类型的信息。此时，持久性存储就变成了一个分布式系统。

Stripe 保存与卡相关的所有数据，可能是电子邮件地址、订阅、计划、产品等等。此外，Stripe 还可以执行某些功能，如发送收据、提醒等。责任的委托。

GDPR 的出现让事情变得有点复杂(以一种非常好的方式)。GDPR 的规定之一是，用户可以将所有数据导出到一个他们可以轻松使用的包中。如果你曾经在一个主流社交网络上这样做过，那么你很可能熟悉下面的用户流:

```
security page -> request export data

time passes

receive email that package is ready with link -> follow link -> download package

open (or unzip) package -> read web pages or other plain text files 
```

这种流动的原因是因为提供者必须从数据库中的数据构建这些平面文件。

这是最后一颗让我思考的钉子。

* * *

据我估计，每种类型的存储在某一方面都非常出色，而在另一方面则略胜一筹。

关系数据库(如 MySQL)非常擅长查询、检索和管理关系...因此得名。对于许多人来说，使用这种方法本身的难点在于改变数据结构。我个人的难点是在数据库中存储大块的内容，特别是当它专门为一个网页存储实际的 HTML 时。

通过 API (RESTful 或其他)访问的 web 服务擅长为开发人员充当门面，并将开销和决策委托给其他人。这里的难点是，它可能是一个很大的瓶颈，因为它以互联网的速度移动，而不是运行其余代码的机器。除非你有开发人员的主线，否则通常很难做出改变。

平面文件结构(就像基本的互联网技术)有利于快速检索和传递简单的内容查询；打开文件夹，抓取文件，做一些事情，返回结果。(NoSQL 和平面文件在底层技术方面非常相似。)痛点在搜索。过去的痛点是读写磁盘，但固态硬盘让这变得微不足道。

NoSQL 数据库(如 MongoDB)非常擅长克服关系数据库的不灵活性，使得创建返回 JSON 的 web-API 更加容易。这里的难点在于扩展具有大量关系的大型数据集。据我所知，与一系列表相比，完整的结构可能很难理解，每个表都包含相同的数据。

* * *

因此，对于这一轮，我对事物设定了以下界限:

1.  关系数据库:这些本质上是(元)数据库。它们不包含内容。相反，它们保存关于内容的元数据，包括关系。比方说，一个用户类，每一行都有给定用户实例的密码、电子邮件地址等等。
2.  Web 服务:这些服务负责保存与其服务相关的数据，是唯一的真实来源，也是数据的唯一存储位置，不会严重影响所需的检索。
3.  平面文件:这些文件主要保存基于文本的内容和用户上传的内容，存储由那个用户*生成的内容；因此，导出用户数据变得容易得多，因为它不需要被聚集和编译。*
4.  NoSQL:没有理由使用完整的 NoSQL 解决方案；但是，一些平面文件是 JSON 文件，带有某些类型的非关系元数据。

* * *

我还将平面文件结构分为我称之为公共和私有的部分，同时还对数据库中存储的尽可能多的数据进行加密或哈希处理，出于多种原因，这并不多，尤其是 8fold 不希望个人数据(你不会需要它)超出软件工作所严格要求的范围。到目前为止，我们需要电子邮件地址、密码和用户名来创建用户对象。

按照 Bob 叔叔的观点，数据存储机制是一个实现细节。因此，当我作为一名开发人员与 User 的一个实例进行交互时，我不关心发生了什么，除非它坏了。例如...

```
 <?php

$user = new User;

// This would come from the relational database
$id = $user->id;

$personas = $user->personas();

// This would come from the Stripe API
$cards = $user->cards();

// This would come from the flat-file
$profile = $user->profile();

// This would come from the non-NoSQL JSON
$emails = $user->emailAddresses(); 
```

如果我决定更改任何关于持久存储和访问的实现细节，我可以很容易地做到，而不会影响到作为开发人员的我自己...至少不是很多。