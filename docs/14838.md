# 当我开始研究 ID 时，我希望我知道什么

> 原文:[https://dev . to/rnovaglia/what-I-wish-I-know-when-I-started-work-on-id-36im](https://dev.to/rnovaglia/what-i-wish-i-knew-when-i-started-working-on-id-36im)

<figure>

[![It's a bad joke about James Bond being a cookie...](../Images/57f9c2c97c1f9dbecc73236bfd477eb7.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--MkayDyJj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/5gw2ziyjepwwx0bu9n0i.jpg)

<figcaption>Get it? It's James Bond? Secret Identity? With cookies? Nevermind…</figcaption>

</figure>

我最近在工作中启动了一个项目，用一个基于云的产品取代内部身份解决方案。这是我第一次从事身份认证(又名身份验证和授权等)的工作，所以需要学习很多东西。这是我希望我能在一月初读到的，当我开始的时候。

### :D 将会是个好天气

我已经知道了，但是安心总是好的。我很幸运身边有一个超级好的，有见识的，支持我的团队。

### 没什么大不了的，比你想象的要多得多

在一天结束的时候，对于我们正在做的事情来说，没什么大不了的。我们希望在用户可以使用系统之前知道他们是谁，一旦我们知道，我们希望向他们提供相关信息。所有这一切意味着，一旦他们登录，他们就会得到一个“令牌”(不管那是什么)，我们用它来让后端知道他们是谁。这是因为 HTTP 请求本质上是无状态的，所以每次交互都是从一个神奇的浏览器到一个受祝福的后端的一个全新的神秘消息。

与此同时，关于如何获得令牌、用它做什么、多久检查一次等等，有许多细微差别。围绕如何管理用户、在哪里管理用户以及为什么管理用户，还有大量的流程和业务决策。

### 3:你不是在重新发明轮子，大多数东西已经存在了

幸运的是，我们使用相当成熟的工具，所以除了把东西放在一起之外，真的没有那么多事情要做。复杂性在于正确使用工具，理解您的系统现在是如何工作的，为什么会这样工作，以及如何推进它。

* * *

## 那么它实际上是如何工作的呢？

解决了这个问题，让我们深入到这个工作原理的一些细节中，集中在一些我从未真正想到的东西上，当我开始思考时，这些东西让我感到困惑。这其实是相当基本的东西，我有点不好意思不知道(骗子联合起来！)，但直到做了才知道。这是几周前我不知道的一些事情，现在我开始明白了。

### [](#1-papers-please)1:请交卷

所以你试着去一个网站，在你能使用它之前你必须登录，所以你被重定向到一些登录页面。当然，我以前经历过。但是，等等，那实际上是如何工作的？你是如何神奇地试图去一个地方，却在另一个地方结束的？
嗯，在我们的例子中，这都是由于我们创建的一些中间件(middlewhat？一分钟后会有更多的介绍)。当有人试图访问我们的应用程序时，我们做的第一件事就是检查他们是否随身携带了“令牌”。如果他们没有，我们只是礼貌地要求他们登录。

这让我困惑了一段时间。他们所说的“象征物”是什么？

我认为“令牌”是一个临时的昵称。当有人使用他们的用户名和密码登录时，身份服务会给他们一个昵称，而不是随身携带。这意味着当他们来找我们时，他们不必不断地向我们发送他们的用户名和密码，而是保持他们的安全。昵称只是暂时的，所以风险较小。

因此，当拥有*私人密码*的*通常用户*来找我们时，我们只需让他们去其他应用程序，并暂时将自己展示为*塔米*。然后，我们的系统可以与安全团队(也称为身份服务)一起检查它，以确保他们知道它们。如果他们这样做，膨胀，ID 服务让我们知道他们实际上是用户。

我们暂时使用*Tammy*的原因是，当他们注销时，或者如果他们离开太久，我们可以忘记临时名称，防止进一步访问我们的应用程序，但仍然记得*通常的用户*。当他们回来时，他们可以获得另一个临时名称，并再次执行这一操作。
好吧，他们得到了名字和昵称，然后发给我们。等等，到底是怎么回事？塞格。

### 这是一块饼干...这是一块蛋糕...不，是饼干！

嗯，美味可口的饼干。谁不熟悉点缀在我们众多网站上、让我们欣喜若狂的可爱小弹出窗口呢？事实证明，它们对保持用户登录非常有用。我隐约知道这个想法，但不知道它实际上是如何工作的。原来，这都是关于它们的 HTTP 头。

我们要求用户登录后携带昵称的方式是，当我们响应他们时，我们在响应中包含一个特殊的 HTTP 头，指示浏览器在某个地方保存一些数据，并在随后对我们网站的请求中，将它作为头包含在内。

因此，我们的身份服务用一个名为`set-cookie`的特殊头回复，头的值为`token=TemporarilyTammy`，浏览器识别它并记下它的值。当用户和请求`GET https://super.duper.com/theBestAppEver`一起被送回我们的应用程序时，他们的浏览器包括一个名为`Cookie`的标题，其值为`token=TemporarilyTammy`。当我们的应用程序收到请求时，我们应用程序的中间件(又是中间件..)查看请求附带的标头，找到 cookie，并与我们已知的身份服务进行核对`TemporarilyTammy`。如果检查通过，我们让他们通过我们的应用程序(等待一些其他的额外检查，比如他们是否真的可以使用我们的应用程序)。

那么，在我们进入后端业务逻辑的实际核心之前，所有这些检查对我们来说意味着什么呢？

### [](#3-its-not-at-the-beginning-and-its-not-at-the-end-where-in-the-middleware)3:不在开头，也不在结尾。在哪里？在中间

因此，我们的应用程序有一些中间件来检查 cookie 头的存在，并使用身份服务对其进行双重检查。但是这个中间件到底是关于什么的呢？

我发现了中间件的几个定义，但为了我们正在做的事情，在我们的 Node.js 应用程序中，我认为中间件是一个过滤器。当我们要求您的应用程序在某个端点之前使用一些中间件时，我们是说在将请求传递给端点逻辑之前，过滤所有通过它进入的请求。如果一切正常，中间件满意，请求将继续在我们的系统中旅行，否则我们的函数将立即响应，请求甚至永远不会到达我们的端点。

在我们的例子中，这意味着我们的 auth 中间件会在请求到达应用程序逻辑的其余部分之前对其进行过滤，甚至在浏览器中检索要呈现的文件。当一个请求进来时，如果没有`Cookie`头，或者它的值不包括`token=value`部分，这是一个自动的禁忌。如果`Cookie`在那里，它就提取`token=value`并将值发送给我们的身份服务。如果他们不能识别这个值，还是不行。这意味着令牌已经过期，或者被篡改了。如果它被识别，我们的功能验证用户实际上可以使用我们的应用程序。如果他们不能，该死。如果可以的话，最终是时候让我们的端点完成它的工作，或者让文件流回浏览器了。

在所有否定的情况下，我们的中间件都会向浏览器发回一个响应，其中包含状态代码`401`或`403`(分别为“谁死了”和“不能碰这个*提示音乐*”)。该响应还包括一个方便的`location=https://please.login.com`标题，指示浏览器或我们的应用程序离开当前页面并登录。

* * *

简而言之，这就是我们如何实现登录我们的网站。还有很多其他的方法，比如 JWT (JSON Web 令牌)、OAuth、OpenID 等等。还有一些东西，比如在后端缓存会话，以避免每次发出请求时都纠缠身份服务，以及关于 cookie 中应该包含什么的讨论。

但是这些问题和答案肯定有助于清除我头脑中的一些迷雾。希望你也会觉得有用！

* * *

我在考虑是否在 Node.js 中包含如何实现这一点的示例，或者甚至是完整的示例 repo 并编写一个演练。你会觉得有用吗？让我知道！