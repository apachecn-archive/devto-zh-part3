# Web Atoms Core 简介

> 原文:[https://dev.to/web-atoms/introduction-to-web-atoms-core-k41](https://dev.to/web-atoms/introduction-to-web-atoms-core-k41)

# [](#introduction)简介

## [](#what-is-web-atoms)什么是网络原子？

“Web Atoms”是一个先进的 MVVM 框架，用于在`HTML5`和`Xamarin.Forms`中编写跨平台应用。与其他框架不同，Web Atoms 允许您以严格的 MVVM 方式划分用户界面逻辑，并在`HTML5`和`Xaml`中分离视图。在 ViewModel 中分离用户界面逻辑的好处是，您可以单独对视图模型进行单元测试，以确保您的逻辑跨平台保持一致。

此外，一切都转换成 JavaScript，您的视图模型和服务仍然在 JavaScript 和浏览器中完美地工作。

在 Xamarin。用 C#编写的表单、Web Atoms 包可以帮助你轻松地在应用程序中托管 JavaScript 模块，整个用户界面都是通过 JavaScript 实现的。

### [](#benefits-of-web-atoms-with-xamarinforms)网原子与 Xamarin 的好处。形式

*   小应用程序下载大小
*   甚至 Xaml 视图也被转换成 JavaScript
*   通过服务公开来重用现有的 NuGet 组件
*   在服务器上托管 javascript，即时更新应用程序
*   不需要本地编译，除非您添加/修改用 c#编写的本地服务
*   您可以使用 Xaml 绑定以及 Web Atoms 的 JavaScript 绑定

## [](#requirements)要求

1.  VS 代码
2.  TSLint 扩展
3.  与 NPM 不和
4.  Xamarin 的 Visual Studio。表单应用程序[可选]
5.  Gitlense 可选]

## [](#umd-loader)UMD 装载机

所有 web atoms 模块都被编写(编译)为 UMD 模块，适合在节点中测试，也适合用 AMD Loader 在浏览器中加载。

```
<html>
    <head>
        <title>Web Atoms Core Samples</title>
        <!-- AMD Loader -->
        <script type="text/javascript" src="./node_modules/web-atoms-amd-loader/umd.js"></script>
    </head>
    <body>
        <script type="text/javascript">

            // map every package and its relative or absolute
            // path (from cdn)
            UMD.map("reflect-metadata", "./node_modules/reflect-metadata/Reflect.js");
            UMD.map("web-atoms-core", "./node_modules/web-atoms-core");
            UMD.map("web-atoms-samples", "./");

            // set language
            UMD.lang = "en-US";

            // Load view in entire page, this method will
            // resolve package from the above mentioned map of 
            // package to url. And it will create an instance of
            // App class and it will host the view `AppHost` in the
            // body of this document
            UMD.loadView("web-atoms-samples/dist/web/views/AppHost", true);
        </script>
    </body>
</html> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

## [](#web-atoms-generator)网络原子生成器

`src`文件夹下的每个 html 文件被转换成一个 TypeScript 文件，该文件可以包含一个从 AtomControl 派生的类。这个类是一个可以用`UMD.loadView`方法加载的视图，它可以嵌套在任何其他视图中。

类似地，`src`文件夹下的每个 xaml 文件都被传输到一个 TypeScript 文件，该文件可以在 Xamarin 中使用。表单应用程序。

关于如何设置，请参考生成器。

## [](#directory-structure)目录结构

```
root
  + dist // dynamically generated by compilation, ignored in git
      ...
  + src
     + model        // all models here
     + services     // all services inside this folder
     + tests        // all unit tests
     + view-models  // all view models must be placed here
     + web          // all html files must be placed inside web folder
     + xf           // all xaml files must be placed inside xf folder 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

将文件保存在`web`和`xf`文件夹中是很重要的，因为模块加载器将替换相应文件夹 url 中的`{platform}`变量来加载视图。这将使视图模型完全独立于平台。

## [](#atomcontrol)原子控制

AtomControl 是一个 UI 控件，包含在屏幕上呈现可视元素的逻辑。AtomControl 有一个初始化生命周期，在每个平台上都是通用的。然而，渲染生命周期在每个平台上都有所不同。例如，`Xamarin.Forms`有自己的渲染生命周期，所以 AtomControl 只绑定到属性。在`Web Browser`中，它有特殊的生命周期来呈现内容。大多数时候，开发人员不需要担心这一点，因为控件是在考虑最佳性能的情况下创建的。

以下属性存在于 AtomControl 上，它们从逻辑上继承了。

### [](#properties)属性

*   应用程序(只读)
*   父(只读)
*   数据
*   视图模型
*   localViewModel

### [](#why-data-and-viewmodel-properties-are-separate)为什么数据和 viewModel 属性是分开的？

在大多数 UI 框架中，视图模型通常设置在`data`属性中，这导致列表框等多项控件出现问题。这需要不必要的向上爬层次结构，并获得父数据属性的实例进行绑定。因此，拥有独立的继承的`viewModel`属性使得引用与整个页面或片段相关联的视图模型变得更加容易。

### [](#what-is-localviewmodel-)什么是 localViewModel？

为了使可重用组件更容易，可以使用`localViewModel`来托管所有特定于组件的逻辑。例如，假设您想要创建一个日历组件。本地视图模型将包含为当前显示的月份和年份创建所有日期列表的所有逻辑。它还将创建所有年份的列表。所有这些逻辑将独立于渲染逻辑，它可以放在一个视图模型中，该模型可以单独进行单元测试。好处是，您可以为平台相关组件编写一个可重用的视图模型，该模型具有跨不同平台的通用逻辑。所以在 component 内部，您将只编写绑定表达式到`localViewModel`。

## [](#atomviewmodel)原子视景模型

类提供了必要的服务和属性来编写容易扩展的视图模型。它有`init`和`dispose`方法来初始化和处理你的视图模型。

```
public class TaskListViewModel extends AtomViewModel {

    // dynamically inject TaskService
    @Inject
    public taskService: TaskService;

    public tasks: ITaskModel[];

    public async init(): Promise<void> {
        this.tasks = await this.taskService.loadTasks();
    }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#watch)手表

由于视图模型不能访问用户交互更新，视图通常与属性进行双向绑定，当用户修改它时，我们必须观察变化并更新视图模型。这是通过`@Watch`装饰器完成的。

```
public class TaskListViewModel extends AtomViewModel {

    @Inject
    public taskService: TaskService;

    public tasks: ITaskModel[];

    public search: string = null;

    public range = { start: 0, size: 10 };

    public async init(): Promise<void> {
        this.loadTasks(null);
    }

    // whenever any of search, range.start or range.size 
    // property is modified
    // automatically call this method
    @Watch
    public watchSearch(): void {
        this.loadTasks(
            this.search, this.range.start, this.range.size );
    }

    private async loadTasks(
        search: string,
        start: number,
        size: number
    ): Promise<void> {
        this.tasks = 
            await this.taskService.loadTasks(search, start, size);
    }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

按照惯例，`@Watch`修饰的方法必须以`watch`字为前缀。即使名字不同，`@Watch` decorator 仍然会关注变化。

Watch decorator 自动开始观察每个以`this.`开头的表达式，它忽略方法，只观察属性。为了提高性能，这个装饰器不解析 javascript 代码，它只查找`this.identifier.identifier...`表达式，并创建观察整个表达式中每个属性的映射。

> 在`@Watch`修饰方法中访问的每个属性必须初始化为`non undefined`值。因为绑定框架忽略了`undefined`

### [](#watch-property)手表属性

也可以在只读属性上定义监视。

```
 @Watch
    public get fullName(): string {
        return `${ this.model.firstName }  ${ this.model.lastName }`;
    } 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

HTML

```
 <span text="[$viewModel.fullName]"></span> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

XAML

```
 <Label Text="[$viewModel.firstName]"> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

您可以将任何视图属性绑定到`fullName`，每当在`model.firstName`或`model.lastName`中检测到任何变化时，它都会自动刷新。同样，两者都不能初始化为`undefined`。

### [](#validate-property)验证属性

虽然`@Watch`是观察任何属性的好方法，但是我们不能用它来验证，因为一旦页面被加载，用户就会被抛出错误消息。所以我们创建了`@Validate`装饰器，它只在调用`this.isValid`属性后返回一个错误消息。

例如，

```
 public class SignupViewModel extends AtomViewModel {

    @Inject
    public navigationService: NavigationService;

    public model = {
        firstName: null,
        lastName: null
    };

    // both validate properties will return undefined value
    // unless `this.isValid` is referenced.

    @Validate
    public get errorFirstName(): string {
        return this.model.firstName ? "" : "First name is required";
    }

    @Validate
    public get errorLastName(): string {
        return this.model.firstName ? "" : "Last name is required";
    }

    public signup(): Promise<void> {

        // as soon as this property is called first time
        // validation decorator will update and error will be displayed
        if (!this.isValid) {
            await this.navigationService.alert(`Please enter required fields`);
            return;
        }
    }

} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

HTML

```
<div view-model="{ this.resolve(SignupViewModel) }">

    <input placeholder="First name:" value="$[viewModel.model.firstName]">
    <span class="error" text="[$viewModel.errorFirstName]"></span>

    <input placeholder="Last name:" value="$[viewModel.model.lastName]">
    <span class="error" text="[$viewModel.errorLastName]"></span>

    ...

    <button event-click="{ () => $viewModel.signup() }">Signup</button>

</div> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

XAML

```
 <Entry 
        Placeholder="First name:" 
        Text="$[viewModel.model.firstName]"/>
    <Label
        Style="Error" 
        Text="[$viewModel.errorFirstName]"/>

    <Entry 
        Placeholder="Last name:" 
        Text="$[viewModel.model.lastName]"/>
    <Label
        Style="Error" 
        Text="[$viewModel.errorLastName]"/>

    ...

    <Button Command="{ () => $viewModel.signup() }">Signup</Button> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

在上面的例子中，当页面被加载时，错误跨度不会显示任何内容。即使`firstName`和`lastName`都是空的。一旦用户点击`Signup`按钮，`this.isValid` get 方法将开始观察所有`@Validate`装饰器方法的变化，用户界面将开始显示错误消息。

## [](#dive-into-samples)潜入样本

[https://www.webatoms.in/samples.html#contextId=0](https://www.webatoms.in/samples.html#contextId=0)

## ![GitHub logo](../Images/a73f630113876d78cff79f59c2125b24.png)[we B- atoms](https://github.com/web-atoms)/[core](https://github.com/web-atoms/core)

### MVVM 浏览器 JavaScript 框架。表单，写 TSX/TypeScript 代替 Xaml 和 C#，热重装 Live 发布的 Xamarin。表单应用程序。

<article class="markdown-body entry-content container-lg" itemprop="text">

[![Action Status](../Images/cfa2fdbb651ac020b318dc872b0e8974.png)](https://github.com/web-atoms/core/actions)[![npm version](../Images/281097dbfee702a2db5f84f4ea1dd388.png)](https://badge.fury.io/js/%40web-atoms%2Fcore)[![codecov](../Images/6cd68ebe76fa6f8061493408508cc5a5.png)](https://codecov.io/gh/web-atoms/core)

# 网络原子核心

Web Atoms Core 是一个 UI 抽象框架和强大的 MVVM 模式，用于设计现代 Web 和移动应用程序。

## Xamarin。表单功能

1.  使用 VS 代码开发 Xamarin。形式
2.  编写 TypeScript 而不是 C#
3.  写 TSX (JSX)而不是 Xaml
4.  已发布应用的实时热重新加载

## Web 功能

1.  抽象原子成分
2.  抽象设备 API(浏览器服务、消息广播)
3.  没有 CSS 的主题和样式支持
4.  一次性、单向和双向绑定支持
5.  简单依赖注入
6.  内置简单的单元测试框架
7.  UMD 模块支持
8.  具有强大验证功能的全功能 MVVM 框架

## 文件夹结构

1.  网站的所有视图必须放在“src”文件夹内的“web”文件夹下。
2.  Xamarin 表单的所有视图必须放在“src”文件夹内的“xf”文件夹下。

### 示例文件夹结构

```
src
+--images
|  +--AddButton.svg
|
+--view-Models
|  +--TaskListViewModel.ts
|  +--TaskEditorViewModel.ts
|
+--web
|  +--tasks
|     +--TaskListView.tsx
|     +--TaskEditorView.tsx
|
+--xf
   +--tasks
      +--TaskListView.tsx
      +--TaskEditorView.tsx 
```

### 示例视图

…</article>

[View on GitHub](https://github.com/web-atoms/core)