# 发行版与发行版:为什么 Python 打包很难

> 原文：<https://dev.to/alexbecker/distributions-vs-releases-why-python-packaging-is-hard-4ohm>

大多数编程语言的包生态系统有两个层次:每个*包*都有一个或多个*版本*，用版本来区分。Python 还有第三个:每个版本都有一个或多个*发行版*，它们是你下载来安装包的实际文件。在大多数语言中，所述文件与版本同义，但是“*或更多的*在 Python 中是至关重要的，因为对于大多数广泛使用的包的大多数版本，事实上有不止一个发行版。

为什么？嗯，Python 的特殊之处在于它将 C 扩展视为该语言的一级特性，*和*试图使软件包用户不必编译 C 扩展。这意味着发行版需要包含从 C 扩展编译的二进制代码——这样的发行版(在其现代迭代中)被称为*二进制轮子*。但是 C 扩展通常需要针对特定的目标 Python 版本和操作系统进行编译，因此要获得任何种类的广泛支持，都需要多个轮子。此外，由于软件包作者不能预见*所有的* Python 版本和操作系统(其中一些还不存在！)，包含一个*源代码发行版*也很重要，它由包用户负责编译。

尽管如此，用户——以及大多数工具——仍然考虑发布版本，而不是特定的发行版。这可能会导致令人惊讶的不一致。例如，在一台机器上安装一个包可能需要几秒钟(因为有匹配的二进制发行版)，而在另一台机器上可能需要几分钟甚至几小时。即使两台机器都找到合适的二进制发行版来安装，它们的哈希也不会匹配，这使得检测 MitM 攻击更加困难。这是因为像`pip`这样的工具会自动确定一个版本的“最合适”的发行版，当一个与给定的系统兼容时，优先选择二进制轮——如果多个兼容，则选择最具体的二进制轮——否则就退回到源代码发行版。大多数其他工具都会效仿，只要在引擎盖下使用`pip`。

在您已经为一个新发行版安装了另一个发行版之后，当该发行版发布时，最大的问题就出现了。这几乎是不可避免的——PyPI 只允许您一次上传一个发行版，创建一个新的发行版，第一次上传的发行版有一个新的版本，所以最终有人会在您上传最后一个发行版之前下载第一个发行版。让构建机器人并行构建不同的发行版的做法变得更加普遍，二进制发行版通常比源代码发行版花费的时间长得多。但是更糟糕的是，当一个包的作者在几个月或几年后回来添加对一个新平台或一个新版本 python 的支持时。发生这种情况时:

*   期望给定包有某个散列值构建系统突然崩溃了。
*   像 [PyDist](https://pydist.com) 这样的 PyPI 镜像不知道寻找新的发行版并失去同步。
*   先前已经安装了发行版的系统(比如，您的开发机器)将不会获得新的发行版，并且可能与安装它的系统(比如，您的生产服务器)的行为不同。

没有明显的方法可以在不显著破坏生态系统的情况下解决这些问题——尽管 PyPI 维护者[意识到了痛苦](https://github.com/pypa/packaging.python.org/issues/564)和[讨论工具改进](https://github.com/pypa/pip/issues/5874)。同时，大量使用 Python 的用户和系统管理员有责任理解 Python 包是如何分发的，以及`pip`如何选择发行版。