# Perl 手册:变量、内存引用和散列[OT]在内存中存储数据(3/4)

> 原文:[https://dev . to/vitalipom/perl-handbook-variables-memory-references-and-hashes-ot-storing-data-in-memory-34-kk7](https://dev.to/vitalipom/perl-handbook-variables-memory-references-and-hashes-ot-storing-data-in-memory-34-kk7)

# [](#perl)Perl

### [](#storing-data-in-memory-)在内存中存储数据-

### [](#variables-memory-references-and-hashes)变量、内存引用和散列

#### [](#off-topic-ot)离题【OT】

我们希望向我们的读者阐明，在 Perl 和所有其他可能的地方，只要有引用、指针(在像 Java 这样的语言中)或内存中数据类型之间的某种不同链接，就有必要引用。

有人可能会认为，计算机内存专家可以简单地获取一些标题、头部和元数据(例如用 html 语言)，将其存储在内存中的某个位置，然后在为我们的对象分配的位置存储我们想要的任何内容，而不是使用那些可能令人讨厌的指针和 Perl - References 中的指针。在拒绝了这个解决方案并因为 Mike 发表了没有根据的和如此怪异的声明而将他从我们的团队中开除之后，让我们指出他是如何得出这个结论的。

当你用 C 写的时候，你必须给出内存分配的确切大小，然后释放它给系统的其他部分使用——再次释放和你之前分配的一样多的空间。所以…基本上，没有限制说“不要分配太多你！为了我们不会因为分配罪而受到惩罚！！!"，这意味着我们可以在这一点上分配更多的空间，为我们的 head/title/it-is 等存储额外的数据，如 whoami(数组/哈希/变量),每当我们需要一些嵌套的数据结构，如哈希数组，将这一堆对象存储在一行中，这些对象的哈希实际上是一个接一个地排序的，从而提高了存储的内存密度和 I/O 速度。

瞧啊。没有指针，我们赢了！！！我们做到了！正如我们所希望的那样，我们有一个带有密集存储的快速操作存储器。等一下…让我们再仔细看看。

在我们提到的所有数据类型中，总会有一些动态类型，它们不仅允许我们进行更改，还允许我们动态地添加和删除数据(即对象)。这一切都很好，直到添加/删除操作的数量增加。扩展这种类型的数据存储的时间有时根本不值得，因为数据类型的嵌套会导致总扩展时间的运行时唤醒(这还没有提醒最终会到来的收缩时间，并导致密度的松散，使我们回到我们心爱的引用模型，在该模型中，我们在实际数据和它在内存中的地址(也称为引用)之间进行解耦。