# 在 Elixir 中集成第三方库的最佳实践

> 原文：<https://dev.to/jackmarchant/best-practices-for-integrating-with-third-party-libraries-in-elixir--59ff>

当我们考虑一个应用程序做什么时，通常会考虑它在依赖关系的上下文中的行为。例如，我们可以说一个虚拟的应用程序与第三方 CRM 同步数据。我们思考应用程序的方式会影响我们在代码中进行抽象的方式。如果我们考虑一个典型的 web 应用程序，我们可能有一个数据库、路由器、控制器和一些关于我们如何使用数据并在页面上显示数据的业务逻辑。在许多情况下，我们需要将我们的应用程序与外部 API、第三方库等集成。对于大多数 web 应用程序来说，抽象概念以使代码更易于阅读和在将来更改是至关重要的。
在许多其他语言中，我们经常看到[接口](https://en.wikipedia.org/wiki/Interface_(computing))与[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)结合使用来实现这些目标。在 Elixir 中,“最佳实践”方法并不总是那么清晰。

在本文中，我将讨论一个与第三方 API 集成的典型场景，并详细说明您可以在下一个项目中使用的潜在方法。

当我们开始编写与第三方的集成时，我们应该考虑应用程序的其余部分将如何使用它，以及它在某些情况下应该如何表现。我们的目标应该是我们可以有一个单一的内部模块，其职责是与外部依赖接口。

在大多数情况下，当需求发生变化时，您不需要再编写任何代码——您可能需要添加额外的功能，但是您的业务逻辑(使用内部模块的代码)不应该仅仅因为您从“非常好的 CRM”变成了“有史以来最伟大的 CRM”而发生太大的变化。也就是说，我并不真的赞同你的代码永远都不会完美，你会有一个围绕你所选择的 CRM 的完美抽象，这样你甚至可以在运行时交换模块并能够同时使用它们。然而，我认为这不会是一件特别痛苦的工作，需要重写你自己的业务逻辑。

为了帮助在我们的系统中实现松耦合，我们可以使用一个[六边形架构](https://fideloper.com/hexagonal-architecture)，换句话说，我们的目标是将所有外部依赖推到我们应用程序的边缘，将我们的核心业务逻辑与一些可能产生的副作用分离开来。通常，这是通过包装外部库(依赖项)来实现的，并且只在代码库的其余部分使用这些包装模块。一个好的经验法则是在你的代码中只有一个表示外部依赖的模块，无论是 API 还是数据库。

在 Elixir 中，我们已经将这种方法用于 Repo 模块，它映射到一个 Ecto 数据存储。当我们在应用程序中创建一个采用某种行为的模块时，我们就在 Ecto 的回购模块周围创建了一个包装器。

```
defmodule MyApp.Repo do
  use Ecto.Repo,
    otp_app: :my_app,
    adapter: Ecto.Adapters.Postgres
end 
```

Enter fullscreen mode Exit fullscreen mode

现在，我们在代码中的任何地方都使用 MyApp。Repo，而不是直接使用 Ecto 来运行 SQL 命令。我们以这种方式使用回购还有其他原因，但我发现这是一个很好的概念模型来表示包装器模块。

### 如何走全六角形

想象一下这样一个世界，您选择的 CRM 有一个用 Elixir 编写的受支持的库，因此您认为您会在应用程序中使用它。叫 ExCRM(顺其自然)。为了实现六边形架构，我们需要通过创建一个模块来包装库的行为，从而将这种依赖性推到应用程序的边界。现在，每当我们想把一些东西推到我们的 CRM，我们需要调用这个包装器模块，而不是直接调用库。这样做，我们只在一个地方引用库，并通过包装器模块创建与应用程序其余部分一致的接口。

它可能看起来像这样:

```
defmodule MyApp.CRM do
  def save(user) do
    user
    |> to_crm()
    |> ExCRM.save()
  end

  defdelegate list_users, to: ExCRM

  defp to_crm(user) do
    %{"name" => user.name}
  end
end

defmodule MyApp.Data do
  alias MyApp.{CRM, Repo}

  def create(user) do
    with {:ok, user} <- Repo.create(user) do
      CRM.save(user)
    end
  end
end 
```

Enter fullscreen mode Exit fullscreen mode

起初，这看起来有点间接，因为这是一个人为的例子，很难立即看到好处。

以这种方式编写代码的效果是，如果库或我们自己的应用程序的需求发生变化，它会限制爆炸半径。通过在您的应用程序中限制库的入口点，我们能够最小化任何此类更改的影响。虽然在开始设置时需要花费更多的努力，但是当业务需求发生变化时，您可以改变您的实现，而无需重构代码库中的大量不同文件。

通过使用这种方法，测试您的代码变得更加容易，因为您只需要在代码库的所有其他部分模拟您的内部模块，而不是库本身。隔离依赖关系并不是一个新概念，在大多数其他编程语言中都有明确的例子来说明如何做到这一点，尤其是在 PHP 或 Ruby 等面向对象的语言中。

人们通常认为函数式编程和面向对象编程是相互矛盾的，并且有非常不同的方法来解决这些类型的问题，但是它们实际上有许多重叠的概念。这两种方法的目标都是创建可维护的、无错误的应用程序，它们共享概念，但在实现上有所不同。

在 Elixir 中，我们考虑将数据从一种形式转换为另一种形式，而不是对象的实例具有状态，我们仍然可以使用类似的模式，并将其应用于 Elixir。相似之处比你想象的要多。