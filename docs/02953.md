# 没有信任的绝对安全

> 原文:[https://dev . to/_ aafshar _/absolute-security-with-no-trust-p55](https://dev.to/_aafshar_/absolute-security-with-no-trust-p55)

我已经开了一个关于理论安全和软件工程的博客。这是我的第一个帖子。希望你喜欢:)

设计和实现安全的软件解决方案通常涉及到对安全级别以及实现该安全级别的努力和成本的讨论。成本和工作量是开发的前期成本、上市时间和安全问题被利用时的修复成本的函数。根据产品、公司和问题的严重性，后期成本还可能包括重新获得客户的信任(例如，[脸书](https://techcrunch.com/2018/09/28/everything-you-need-to-know-about-facebooks-data-breach-affecting-50m-users/)的多次安全违规)或失去业务的重要部分，如 [VFEmail](https://krebsonsecurity.com/2019/02/email-provider-vfemail-suffers-catastrophic-hack/) 的情况。根据风险承受能力和其他因素，软件产品属于以下安全范围。

*   没有保安！它开发起来快速、简单、便宜，但是风险很大，并且需要很高的成本来保证它的安全性。
*   已经考虑并实施了一些安全级别，其余的则通过 NDAs 或其他非技术手段进行保护。
*   不信任任何第三方的绝对安全(更正式的说法是信息论安全或无条件安全)。

在本帖中，我将谈论最后一项，并讨论它的可行性或实用性。我认为，尽管绝对安全在实践中是不可能的，但重要的是，我们要努力研究“安全多方计算”等领域，以提供必要的工具，就产品的安全性和我们必须信任的事物的数量做出合理的妥协。

让我们从一个简单的例子开始，来演示绝对安全是否可以实现。在这个例子中，我们有一个`client`,它想要加密一个`secret file`,并将其外包给一个`cloud`进行存储，这样云就永远找不到文件的内容。

## [](#theory)理论

您可以通过使用一个简单的`XOR`函数来实现信息理论上的安全性。考虑一下`secret file`的内容是二进制字符串`101010`的情况。现在假设客户端选择了一个密码，也是一个二进制字符串，比如说`100101`。客户机将文件内容与密码进行异或运算(使用下面的函数),并将结果发送到云。

```
def encrypt(content, password):
  m = int(content, 2)
  k = int(password, 2)
  c = m ^ k
  return "{0:b}".format(c).zfill(6)

encrypt("101010", "100101")
#=> prints '001111' 
```

*为什么这种加密方式是安全的？*假设你是云，你已经从客户端收到了`001111`。还假设您有无限的 CPU 和内存，并且您决定尝试所有可能的密码(即，执行暴力攻击)来找到秘密文件的内容。您注意到消息有 6 个字符长，因此您使用下面的函数尝试了从`000000`到`111111`之间的所有密码。

```
def brute_force(secret):
  c = int(secret, 2)
  possible_results = []
  for possible_password in xrange(int("111111", 2)+1):
    possibility = "{0:b}".format(possible_password ^ c)
    possible_results.append(possibility.zfill(6))
  return possible_results

brute_force("001111")
#=> Can you guess what it prints? 
```

如果您运行这个函数，您会注意到它正在打印`000000`和`111111`之间的所有值。换句话说，它将打印秘密文件的所有可能内容！这意味着强制完全没有帮助，您(即云)仍然不知道哪种可能性更大！这就是我们所说的信息论安全:不管你的计算能力如何，你最多只能**猜测**所有可能的内容中哪一个是答案。

好了，我们已经实现了信息论安全，我们完成了，对吗？不要！我们还没有检查实际的一面。

## [](#practice)练习

在我们的暴力例子中，云在所有的可能性中寻找正确的答案。细心的读者可能已经注意到`secret file`的内容是`101010`或`42`，当然 [42 是答案](https://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy)！玩笑归玩笑，当攻击者对秘密的形式有所了解时，这显示了一种攻击。即使我们不考虑这种类型的攻击，实现仍然会有问题。例如，考虑加密函数的以下实现。

```
def bad_encrypt(content, password):
  m = int(content, 2)
  k = int(password, 2)
  c = m ^ k
  print "DEBUG: Encrypting {0} with {1} resulting in {2}".format(m, k, c)
  return "{0:b}".format(c).zfill(6)

bad_encrypt("101010", "100101")
#=> prints DEBUG: Encrypting 42 with 37 resulting in 15
#          '001111' 
```

嗯，那看起来不太安全！很明显，即使使用给你信息理论安全的算法，你仍然*相信*开发者已经实现了一个安全的程序。现在，我们假设程序是安全编写的，代码中没有漏洞。下一个问题是在哪里存储密码。如果攻击者能够找到密码，那么一切都完了。因此，即使有理论上安全的算法和*假设*你的程序没有漏洞，你仍然*相信*你的操作安全是完美的！

现在，假设您的代码是安全的，您的操作实践是安全的，并且没有恶意的内部人员泄露您的秘密，您会选择 XOR 函数来满足您的加密需求吗？大概不会！注意，要加密长度为 6 的消息，您需要创建长度为 6 的密码。类似地，要加密外包给云的 10tb 数据，您需要在本地存储 10tb 的密码！这是实现信息理论安全的巨大而无意义的代价。

## [](#reality)现实

在这一点上，你可能想知道为什么我们甚至要为理论上的安全性而烦恼！到目前为止，我所描绘的这幅图是一个极端的例子，它表明了安全性在软件开发的所有方面的重要性，同时也指出了高级别的安全性并不便宜，在绝大多数情况下，您需要通过更多的计算或更多的内存/网络使用来支付。解决方案是研究如何使理论方法更有效，并在实际安全性上找到合理的折衷。在过去的几十年里，有一些重要的研究使我们更加接近高效合理的理论和实践安全。

在我的博士论文中，我对“安全多方计算”领域的进一步研究( [AMPR14](https://link.springer.com/content/pdf/10.1007/978-3-642-55220-5_22.pdf) ， [AHMR15](https://link.springer.com/content/pdf/10.1007/978-3-662-46800-5_27.pdf) ， [AMR17](https://eprint.iacr.org/2017/062.pdf) )做了一小部分工作，我相信这是最有前途的领域之一。在我以后的博客文章中，我将从一个软件工程师的角度介绍这个领域，目的是鼓励其他软件工程师适应和使用这个领域正在进行的惊人研究的结果。