# 按位运算符

> 原文:[https://dev.to/rpalo/bitwise-operators-14ad](https://dev.to/rpalo/bitwise-operators-14ad)

在[上一篇二进制/十六进制文章](https://www.assertnotmagic.com/2018/09/16/binary-and-hexadecimal-part-2-conversions/)中，我们完成了十进制数、二进制数和十六进制数之间的转换。在本帖中，我们将介绍一些你可以对数字进行的新操作，因为你知道它们都是由 1 和 0 秘密组成的。

## [](#math-gt-computing)数学- >计算

在我们深入研究这些操作之前，让我们先来看看计算机科学中使用的一些术语，这些术语可能会在关于这个主题的其他资源中看到。

**位**:

数字(以及计算机内部表示的任何其他数据)由 1 和 0 组成。看了前面两个帖子，你就知道这种格式叫做 called binary。你可能*不*知道的是，这些 1 或 0 中的每一个都被称为一个**位**，它是计算机存储信息的最小单位。由于只有两种状态(1 或 0)，计算机可以将此信息存储为电或磁测量值:一个位可以是“开”(1)或“关”(0)。想象一下，如果你想通过打开和关闭一排手电筒来存储一个数字。开和关的模式将代表你试图代表的全部数据/数字。

**字节**:

纯粹由于历史原因(T3)，计算机以 8 位为一组存储比特。每组 8 位被称为一个**字节**。即使您以前从未遇到过二进制，这个词也可能很熟悉，因为您可能熟悉诸如“兆字节”、“吉字节”、“太字节”等术语。当我们用完“Gee-Bees”(Gbs)时，我们的手机会毫不犹豫地告诉我们。我不会去探究[各种前缀](https://en.wikipedia.org/wiki/Binary_prefix)背后的数学，但是知道它从何而来是很好的。可以说，我们已经标准化了用**字节**来处理事情。因为**字节**值可以在`0b00000000`和`0b11111111`之间(即 0 和 255)，数字 256 在计算机环境中可能看起来很熟悉。这是一个方便存储数据的范围。

**轻咬:**

在二进制空间中，我个人最喜欢的是**轻咬**。一个**半字节**是半个字节，即 4 位。因此，您将拥有值在`0b0000`和`0b1111` (0-15)之间的半字节。这是 16 种可能性。你们当中特别聪明的人可能会把 16 种可能性识别为可以存储在一个十六进制数字中的准确的数字。出于这个原因，转换一个十六进制数字会产生一个二进制的半字节。将二进制分成 4 块有助于我在二进制和十六进制之间来回转换时保持跟踪。

## [](#bitwise-operations)按位运算

好吧！现在我们知道了什么是位，我可以引入**位操作**。如果你正在想象一个 1 和一个 0 在一起，两个人都留着巨大的灰色胡子，说着睿智的话...我也是。你并不孤单。

但是位运算不仅仅是一些明智的老数字。它们是只能通过比较组成两个数的位来计算的运算。我们来看几个。如果你熟悉逻辑/布尔，你可能会看到一些相似之处。

### [](#not)不

NOT 也称为补语。这是一个*一元*运算，也就是说你只对一个数做。这类似于普通数学中的负号。

为了不是一个数字，你把它的每一位翻转过来。如果是 1，你就把它变成 0。如果是 0，你就把它变成 1！

```
NOT 0011 (decimal 3)
  = 1100 (decimal 12) 
```

如果你正在处理十进制数，你可以走一点捷径。如果你知道你正在使用的位数，不知道你的位数的结果是`max value of bits - your number`。

例如:如果我们用一个**字节**来表示我们的数字，我们的数字是 200，那么一个字节的最大值是 255。所以:

```
NOT 200

= 255 - 200
= 55! 
```

有时候捷径会有帮助。有时候把所有东西都转换成二进制并翻转比特更容易。

### [](#and)和

你可以想到下面这句话中的 AND:如果两个输入都是上的*，那么结果只有*上的*。如果任一输入为*关闭*，则结果为*关闭*。这有点像你有一根水管，在龙头上有一个阀门，在水管末端有一个喷头。只有当龙头和喷头打开时，水才流动。如果喷雾器是开着的，但龙头是关着的，那么什么都不会出来，你看起来很傻。如果龙头是开着的，但喷雾器是关着的，那么什么都不会出来(如果你有一个漏水的喷雾器，你就会被淋湿)。* 

```
.   01001110  (decimal 78)
AND 11000010  (decimal 194)
=   01000010  (decimal 66) 
```

本质上就像你把每一组比特一个接一个地相乘。`0 * 1 = 0, 1 * 1 = 1, 0 * 0 = 0`等。

在一些编程语言中，你会看到并显示为一个单独的`&`操作符。

在数学符号中，他们使用一个`^`符号来表示“交集”，如果你把这想象成两个数之间的维恩图，这是有意义的。“与”运算的结果是两个数之间共享的图形中间重叠部分的所有位。78 有`{2, 4, 8, 64}`作为它的二进制数字，194 有`{2, 64, 128}`。两者重叠的“交集”里面是`{2, 64}`，所以结果是 66！

对于做一个叫做“位屏蔽”的事情是非常有用的，在这个过程中，你需要取出一个数字，屏蔽掉某些数字，这样只有某些数字才能“通过屏蔽”

例如，假设我要问你一个数字，然后我想告诉你它是否有一个 8 的位置位。我能做的是通过阻塞来“屏蔽”所有其他位，只让 8 的位通过。然后我就可以检查它是否通过了！

```
.   01001110 (decimal 78)
AND 00001000 (decimal 8)
=   00001000 # Yes!  There *was* a 1 in the 8's place!

.   11000010 (decimal 194)
AND 00001000 (decimal 8)
=   00000000 # Nope!  No 1 in the 8's place 
```

所以，对于你给我的这个神秘数字，一旦我把它和 8 进行“与”运算，我就可以检查结果是否是 8，这意味着你*在 8 的位置上有 1，或者 0，这意味着你的数字*在 8 的位置上没有 1。**

清澈如泥？这整个“让你的大脑在十进制和二进制之间来回切换”的事情是一种来自实践的技能。尝试使用和，只显示 254 最右边的两位二进制数字。十进制数的结果是什么？ <sup id="fnref1">[1](#fn1)</sup>

你可以做的另一件有趣的事情是检查一个数字是奇数还是偶数！想想二进制。每个数字都是 2 的幂，所以一个数字只有在最右边的数字是 1 的情况下才是奇数。所以，为了检查一个数是否是奇数，我们可以用 1 和我们的数相加！

```
.   01010101  (decimal 85)
AND 00000001  (decimal 1)
=   00000001  (decimal 1 means ODD!)

.   01010100  (decimal 84)
AND 00000001  (decimal 1)
=   00000000  (decimal 0 means EVEN!) 
```

`683 AND 1 = 1`，所以 683 是奇数！手工计算时，这似乎不是很有用——为什么不简单地看一下数字，然后说它是否是偶数呢！—但当你开始做编程方面的事情时，“只是看看”就有点难了。

### [](#or)或

OR 类似于 AND 的哲学，但它要慷慨得多。如果两个输入中的任何一个*在*上，OR 的结果将是上的*。它更像一个桶，桶上有两个洞，正在被打开和关闭。如果其中一个或两个孔打开，水就会流动。只有当*的两个孔*都没有打开时，水才会停止。* 

```
.   01110010 (decimal 114)
 OR 10110001 (decimal 177)
=   11110011 (decimal 243) 
```

在一些编程语言中，这由`|`单垂直管道符号表示。

在数学符号中，你会看到它是`∨`，向下的插入符号，也称为“并集”。用维恩图的术语来说，这代表了左圆、右圆和中间重叠区域内的一切。如果在任一集合或两个集合中存在一个位，那么它将被传递。114 有`{2, 16, 32, 64}`，177 有`{1, 16, 32, 128}`。将两个集合中的所有数字组合起来得到`{1, 2, 16, 32, 64, 128}`，它等于 243！

你可以用它来“设置”一个未知数中的某个特定位。假设我要向你要一个数字，不管它是什么，我都要确保在我的结果中设置 4 的位置位。我要做的是给你的号码加个 4！

```
.   01010001 (decimal 81)
 OR 00000100 (decimal 4)
 =  01010101 (decimal 85, and the 4's bit is set!)

.   00001111 (decimal 15)
 OR 00000100 (decimal 4)
 =  00001111 (decimal 15\.  4's bit was aleady set, so no change!) 
```

2019 年 3 月 27 日编辑:修正了示例中的一个错误结果。53 - > 85。感谢 [@houdiiny](https://dev.to/houdiiny) ！

### [](#xor)异或

这一个比其他的稍微复杂一点，但是并不可怕。XOR，也称为“异或”，如果任一输入为 1，将输出 1，但*不是两个*都为 1。如果两者都是 1 或都是 0，它将输出 0。更简单地说，当两个输入相同时，它输出 0，如果不同，则输出 1。

```
.   01001110 (decimal 78)
XOR 11001100 (decimal 204)
=   10000010 (decimal 130) 
```

在一些编程语言中，`^`符号用来表示 XOR(有点令人困惑，因为这是 AND 的数学符号)。然而，XOR 用最酷的数学符号:`⊕`带圆圈的加号在数学符号中弥补了这一点。我认为我们错过了一个称之为“plussircle”的大好机会

XOR 对于在一个数内“切换”一个位非常有用。为了切换一个位，改变它的值，无论它是什么，你用一个在你想要切换的位置上有 1 的数来异或你的数:

```
.   11010101 (decimal 213)
XOR 00010000 (decimal 16, let's flip the 16's place bit!)
=   11000101 (decimal 197, the same number as 213, except for the
              bit that's been flipped!) 
```

XOR 的另一个非常好的用法是加密东西！XOR 很酷的一点是它*撤销自己*。

```
.   11010101 (decimal 213)
XOR 01101100 (decimal 108)
=   10111001 (decimal 185, a totally different number)
XOR 01101100 (decimal 108, XOR-ing with the same number again)
=   11010101 (decimal 213, the same number we started with!) 
```

所以，如果你想加密一个数字(或者一个被编码成二进制的句子，但那完全是另一回事)，你选择一个数字作为你的“密钥”，并用它来编码你的数字。我的安全码是 10，20，30，40，50(超级安全！).我要用 42 作为我的密钥。现在，如果我的朋友已经知道了钥匙号码，我可以告诉他我的安全密码是:

```
.   00001010 (decimal 10)
XOR 00101010 (decimal 42)
=   00100000 (decimal 32)

.   00010100 (decimal 20)
XOR 00101010 (decimal 42)
=   00111110 (decimal 62)

.   00011110 (decimal 30)
XOR 00101010 (decimal 42)
=   00110100 (decimal 52)

.   00101000 (decimal 40)
XOR 00101010 (decimal 42)
=   00000010 (decimal 2)

.   00110010 (decimal 50)
XOR 00101010 (decimal 42)
=   00011000 (decimal 24) 
```

我可以告诉我的朋友我的安全密码是:32，62，52，2，24...(*眨眼*)。我的朋友可以把这些数字和密钥进行异或运算，得到 10，20，30，40，50！

### [](#left-and-right-shifts)左右移位

换档采取模式`67 >> 3`或`12 << 4`。本质上，你得到的是二进制数，并把位的模式向左或向右移动这个量。在二进制数的两端，随着位数的增减，有几种策略可以选择。

#### [](#logical-shift)逻辑移位

最简单的情况(也是一些编程语言所做的)被称为“逻辑移位”，也就是说，每当我们需要移入一个新的数字时，我们只需使用 0。我们来看一个例子:

```
.   00011100 (decimal 28)
<<         4
=   11000000 (decimal 192)

.   11100000 (decimal 224)
>>         3
=   00011100 (decimal 28) 
```

看到我们如何保持比特的相对模式不变，但是它们被“移位”了一定的量了吗？如果我们处理的是字节，从末端出来的位会被丢弃，每次我们移位时，我们必须在“输入”端引入一个额外的 0。然而，您也可以将二进制数视为具有所需的位数。在这种情况下，当我们向左移动时，数字不会从左边消失。我们只会越来越大。这将产生乘以或除以 2 的效果。左移(`<<`)相当于将你的值翻倍，右移(`>>`)相当于减半(并向下舍入！)你的价值。

还有其他类型的移位不太常用:“算术移位”和“循环移位”。为了完整起见，我将简要地提及它们，但是不要对它们强调太多。

#### [](#arithmetic-shift)算术移位

在算术移位中，左移还是一样的。零在需要时出现。然而，即使在移位之后，右移位也保持最左边的位不变。这是因为，有时，使用该值作为“符号”位来指定您的数字是负数还是正数是很有用的。在这种情况下，最左边的位是符号位，字节中的其他 7 位代表数值。

```
.   11101100 (decimal 236)
<<         2
=   10110000 (decimal 176)

.   11101100 (decimal 236)
>>         2
=   11111011 (decimal 251, see how the 1 on the left side
              causes us to shift in more 1's?) 
```

#### [](#circular-shift)循环移位

循环移位是指回收掉下的比特，并用它来填充进来的比特:

```
.   11101100 (decimal 236)
<<         2
=   10110011 (decimal 179\.  See the two ones from the left brought
              in on the right?)

.   11101100 (decimal 236)
>>         2
=   00111011 (decimal 59) 
```

## [](#feeling-a-bit-more-powerful)感觉一个“位”更强大？

位运算有许多巧妙的小应用。您可以使用位作为[标志](https://www.alanzucconi.com/2015/07/26/enum-flags-and-bitwise-operators/)来指定不同的不相关选项，并根据需要打开或关闭它们。您可以对 CPU 使用移位-快速加倍和减半，并且您可以使用不同的屏蔽和移位技术来专注于一个数字中的特定位！

我很快会有更多关于如何在编程环境中使用这些新知识的帖子。

还有一些像“Endianness”这样的题外话，这只是一种奇特而吓人的说法，有时计算机被编程为期望具有最大值的位(最高有效位:MSB)从左到右，而不是从右到左！作为参考，您在这里看到的所有示例都是“大端”的，MSB 在前。(懂了吗？big-endian =首先是“大端”？我不知道他们为什么要说得这么吓人。)我们将在以后的文章中更多地讨论字节序。

* * *

1.  `254 = 0b11111110`。用`0b00000011`选择最右边的两位数字。`0b11111110 AND 0b00000011 = 0b00000010 (2)`。 [↩](#fnref1)