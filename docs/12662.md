# 木偶师的随机性和适时停顿

> 原文:[https://dev . to/ddhogan/puppet eer-stochasticity-and-time-pauses-3kb 6](https://dev.to/ddhogan/puppeteer-stochasticity-and-timely-pauses-3kb6)

[![Underneath ocean wave with a fish](../Images/dd76673bf1273927e72dd357d3083f31.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--BOlQOmWT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/http://i.imgur.com/mNvMtqX.jpg)

### [](#when-only-the-watched-tests-are-passing)只有被观看的测试通过时...

我用 Jest 和木偶师为我用 React 建造的 SPA 写了一些测试。非常简单的事情:启动浏览器，导航到 localhost 的页面，输入一些文本并单击一个按钮，然后等待下一个页面加载并找到一个特定的选择器，类似的事情。

我在一个视图中添加了一个小特性，这给我的测试带来了一些意想不到的混乱。我甚至没有编写任何新的测试来覆盖新的组件，但是我注意到我的测试突然只有在用`{headless: false}`运行时才通过。好像它需要我看着才能工作。

我认为这是一个时间问题(我很接近！)所以我在不同的`waitForSelector`和整个套件上不断提高超时，并在那里暂停(我就快成功了！)，还是没运气。当它在 headless 模式下运行时，它会不一致地失败——不是每次都在同一个地方，而是随机地在几个不同的地方之一失败。

我谷歌了一下(我的一个搜索结果只有 9 次点击！)，疯狂地阅读文档，加入木偶师 slack 社区(实际上非常安静)，在 GitHub 论坛上阅读所有(比如，3 个)来自看到类似结果的人的问题，他们似乎都遇到了无头浏览器被一些网站阻止的问题。有意思，但绝对不是我的问题。我希望找到类似于`{stochastic: false}`模式的东西😆

思考我必须改变什么来引入额外的小组件，我记得我需要添加一个生命周期方法(`componentDidUpdate`)到测试开始失败的同一个视图中。

因此，在测试中，在登陆该页面/视图并识别所有选择器和其他东西之后(我已经用截图确认了该页面已经有足够的时间加载)，但是在模拟其中一个链接上的点击事件之前的*,我为发生该事件的两个实例添加了 3 秒钟的暂停...突然间，测试一致通过了！只用了 9 秒钟！*

我知道暂停不是测试中的最佳实践，如果我用 Enzyme 编写这些测试，我可能不需要担心这一点，但在这种情况下，在与页面上的链接交互之前让生命周期方法解决似乎是最好的方法。事实上，这更接近于模拟用户的体验，因为每次它与`{headless: false}`一起工作时，我也有`{SloMo: 250}`，这正好有足够的时间让生命周期方法来解决。这意味着我可能可以安全地将这些停顿减少到半秒或更少(但这为 Travis CI 的慢行留出了足够的余地)。

看似混乱的测试行为实际上是一个简单得多的过程(我没有看到),比观察期稍微慢一点。

也许这篇博文会成为搜索结果的第 10 名，并为其他人节省一点调试测试的时间！