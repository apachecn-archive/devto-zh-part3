# 为什么你需要看到你的测试失败

> 原文：<https://dev.to/koffeinfrei/why-you-need-to-see-your-test-fail-2gfm>

> 原帖:
> 
> [www . koffeinfrei . org/2019/04/07/why-you-need-see-you-test-fail](https://www.koffeinfrei.org/2019/04/07/why-you-need-to-see-your-test-fail/)

## 红色/绿色(/重构)

当使用 TDD 或 test-first 进行开发时，第一步是编写一个测试。这个测试最初会失败，因为还没有实现。

测试优先的工作流隐含地确保测试在变绿之前失败。如果你不熟悉 TDD 的周期，请仔细阅读。

当在编写产品代码之后编写测试时，您永远不会看到测试失败，因为正确的实现已经存在。

## 所以？这有什么问题？

问题是，如果你从未看到你的测试失败**，你就不知道你的测试实际上是否测试了正确的东西**，或者根本不测试任何东西。

测试的主要目的是确保您的代码正常工作。(如果你正在进行 TDD，驱动你的产品代码的设计实际上是编写测试的主要目的。)

如果你不知道你的代码是否真的在测试正确的东西，你就不能对你的测试有信心，也不能对你的产品代码有信心。

如果您在之后编写测试，您需要临时更改实现来查看您的测试是否失败。不要改变测试，**改变生产代码**。

## 现实生活中的例子

假设我们想修复一个 bug。在修复它之前，我们首先创建一个测试来断言 bug 存在。这意味着测试需要失败。我们正处于 TDD 周期的第一步。

只有在编写完测试之后，我们才能修复 bug。修复错误后，测试变成绿色。

想象一下，我们在修复 bug 之后编写测试。我们如何知道测试实际上测试了 bug 不再存在？最坏的情况是我们实际上没有修复这个 bug。

为了确保我们确实有，我们需要撤销修复，运行测试并确保测试失败。通过这样做，我们验证了 bug 对我们的测试有影响，该测试代表了我们的产品代码的预期行为。

当重新应用修复并且测试变绿时，我们可以非常确信我们正在测试 bug 修复，因此 bug 不再存在(至少不是以我们的测试用例覆盖的形式)。

## 底线

如果你想信任你的代码，你需要能够信任你的测试。除非你看到你的测试失败，否则你不能这样做。

所以不要偷懒。不要只是假设你的测试没问题。**见**。**它**。**失败**。