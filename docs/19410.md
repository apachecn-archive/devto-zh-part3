# 将外部服务集成到应用程序中的实现策略

> 原文:[https://dev . to/cohere/implementation-strategies-for-integrating-external-services-into-your-application-30kh](https://dev.to/cohere/implementation-strategies-for-integrating-external-services-into-your-application-30kh)

许多现代软件依赖外部服务来负责产品特性集的某些方面。这种趋势只会继续下去，因为大多数单一用途、非数据库、API 优先的服务，如 [Auth0](https://auth0.com/) 、 [Drip](https://www.drip.com/) 、 [Twilio](https://www.twilio.com/) 、 [Nylas](https://www.nylas.com/) 和 [Stripe](https://stripe.com/) 会继续发展并进入市场。

这是好事！它为开发人员提供了杠杆，因此我们可以专注于解决客户的痛点，而不是一遍又一遍地解决特殊目的、非常困难的问题。

然而，采用外部服务是有成本的。(概括地说)开发人员倾向于用三种方式集成这些外部服务，每种方式都有不同的优缺点。这里从“最简单”到“最复杂”对它们进行了排序:

*   将对服务或其 SDK 的调用直接嵌入到现有的应用程序代码中。在 Rails 中，这可能看起来像是直接从模型或控制器中调用服务。在 React 或 Vue 中，您可以直接从组件中调用这些服务。
*   将服务或其提供的 SDK 包装在自定义库中，并从您的应用程序代码中调用该库。
*   编写一个内部服务(微的或其他的),包装外部服务或它的 SDK 和一个调用该服务的内部库。

这些选项中的每一个都完全有效。不同的组织环境、团队动态、技术能力和约束更适合不同的解决方案。我问自己一些问题，想知道应该采用哪种策略:

*   我是在尝试了解服务是如何工作的，并在概念验证中应用它，还是在发布一个产品特性？
*   服务或 SDK 的接口与现有代码库中的约定和共享理解有多接近？当库的启示与代码库中建立的规范冲突时，认知负荷会增加。
*   我是否在代码库中的不同位置与服务交互？该服务还有其他内部消费者吗？
*   我是在使用无法访问进程内存的灰盒或黑盒策略进行测试吗？或者我在某种程度上提供了方便的过程中的测试——替身或假货？
*   服务或其 SDK 以要求我们更改代码的方式更改其接口的可能性有多大？
*   我打算如何处理服务失败？是否有可能在不阻止最终用户使用该功能的情况下恢复，或者我必须告诉用户稍后再试？

### [](#the-simplest-case-embedding-calls-to-an-external-service-directly)最简单的情况:直接嵌入对外部服务的调用

如果这是依赖于服务的特性的第一个实现，并且我可以轻松地将处理服务故障模式的责任封装在 ruby 类或节点模块中，我会选择最简单的方法:将服务调用直接写入现有的应用程序代码中。