# 用 Koa.js 测试驱动开发 HTTP 服务器

> 原文：<https://dev.to/lucifer1004/test-driven-development-of-an-http-server-with-koajs-25b8>

## ![GitHub logo](img/a73f630113876d78cff79f59c2125b24.png)[pkuosa-Gabriel](https://github.com/pkuosa-gabriel)/[KOA-http-server](https://github.com/pkuosa-gabriel/koa-http-server)

### PKUOSA Web 全栈 HW02

<article class="markdown-body entry-content container-lg" itemprop="text">

# koa-http-server

[![License: MIT](img/703c1a9bcacb5b6337daa880686dcc21.png)](https://opensource.org/licenses/MIT)[![codecov](img/cac5f04f5bffc008dab84a1a2e17a37a.png)](https://codecov.io/gh/pkuosa-gabriel/koa-http-server)[![codebeat badge](img/eb6a92a2f46124001ebec6600c1692ec.png)](https://codebeat.co/projects/github-com-pkuosa-gabriel-koa-http-server-master)

基于 [koa.js](https://github.com/koajs/koa) 的简单 http 服务器。一个玩具版本被部署在 [Heroku](https://koa-http-server.herokuapp.com) 上，请随意尝试。

笔记可以在这里找到[。](https://github.com/pkuosa-gabriel/notes/)

如果您有任何问题或建议，请发送电子邮件给我。如果您发现任何错误，请在此库中创建一个问题。拉请求也是受欢迎的。

</article>

[View on GitHub](https://github.com/pkuosa-gabriel/koa-http-server)

## 本项目的目标

这个项目旨在使用 [koa.js](https://github.com/koajs/koa) 实现一个简单的 http 服务器。在*节点初学者手册*中，一个类似的服务器在没有任何框架的情况下被实现。

在接下来的章节中，我们将一步步介绍这个项目的开发过程。

## 初始化

### 依赖关系

首先，需要安装所有基本的依赖项，例如，node、npm(或 yarn)。由于我使用的是 MacOS，我已经通过自制软件安装了所有的必备软件:

```
# Install node and yarn
# If you want to use npm, you can install node only, which includes npm
brew install node yarn 
```

我个人更喜欢 yarn 而不是 npm 做包经理。如果你想用 npm，那肯定是可以的。

如果要在不同的节点版本之间切换，可以通过 brew 安装 nvm，然后通过 nvm 安装不同的节点版本。

```
# Install nvm
brew install nvm

# Install different node versions
nvm install 10
nvm install 8

# Select a version to use
nvm use 10 
```

现在，您已经安装了节点 8 和节点 10，而节点 10 正在当前环境中使用。

### 知识库初始化

接下来，是初始化存储库的时候了。有许多可用的脚手架，但我们将从头开始建立这个项目，所以没有脚手架将被使用。

```
# Create project directory
mkdir koa-http-server
cd koa-http-server

# Initialize git
git init

# Initialize package.json
yarn init

# Create .gitignore
touch .gitignore

# Create the entrypoint
touch index.js 
```

注意`yarn init`会交互式的问你一系列问题，你可以随便回答。

要忽略不相关的文件，您可以使用下面的`.gitignore`文件作为模板，并根据需要添加或修改其中的任何内容。

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next

# IDEs
.vscode
.idea

# public
public/*
!public/favicon.ico 
```

### 共基本包

之后，需要安装一些基础包。

为了启用热重载，我们将使用 nodemon。

```
yarn add nodemon 
```

然后我们可以给`package.json`
添加一个脚本

```
"main":  "index.js",  "scripts":  {  "dev":  "nodemon --watch"  } 
```

注意，我们不需要在脚本中指定`index.js`，因为它已经在`"main"`中定义了。如果在`yarn init`期间没有指定入口点文件，那么应该在脚本中指定它。

我们将在这个项目中遵循 BDD(行为驱动开发)。我们将使用 Mocha+Chai 作为测试框架。这些包应该作为开发依赖项安装。此外，我们将使用伊斯坦布尔来计算代码覆盖率。

```
# Install test-related packages as dev dependencies
yarn add mocha chai chai-http nyc --dev

# Create a subfolder for tests
mkdir test

# Create our first test file
touch test/index.spec.js 
```

然后是相应的脚本:

```
"scripts":  {  "coverage":  "nyc report --reporter=json",  "test":  "nyc mocha test/*.js"  } 
```

我们总是希望我们的代码干净整洁。为此，ESLint 是最佳选择。

```
# Install ESLint as a dev dependency
yarn add eslint --dev

# Interactively configure your rules
node_modules/eslint/bin/eslint.js --init 
```

之后，我们可以再添加一个脚本:

```
"scripts":  {  "lint":  "eslint *.js test/*.js --fix"  } 
```

使用`--fix`是为了在我们运行`yarn lint`时自动修复样式错误。

为了在 mocha 环境中启用 ESLint，我们需要手动修改生成的 ESLint 配置文件(在我的例子中是`.eslintrc.yml`)。

```
env:
  es6: true
  node: true
  mocha: true 
```

现在我们已经完成了大部分配置。在我的项目中，我还配置了 codebeat、renewal、codecov、mergify、travis 和 heroku，从而赋能一个全功能的 CI/CD 流。这些细节将不在本笔记中讨论，但是您可以参考代码，或者搜索并阅读上面提到的每个工具的文档。

## 启动服务器

因为我们要使用 koa 框架，所以我们应该首先安装这个包。

```
# Install koa
yarn add koa 
```

我们将首先编写测试。

```
// test/index.spec.js

const chai = require("chai");
const chaiHttp = require("chai-http");
const { server } = require("../index");
const expect = chai.expect;

chai.use(chaiHttp);

describe("Basic routes", () => {
  after(() => {
    server.close();
  });

  it("should get HOME", done => {
    chai
      .request(server)
      .get("/")
      .end((err, res) => {
        expect(res).to.have.status(200);
        expect(res.text).equal("Hello World");
        done();
      });
  });
}); 
```

然后我们可以运行`yarn test`，它无疑会失败，因为我们还没有实现相应的函数。我们现在就去做。

```
// index.js

const Koa = require("koa");
const app = new Koa();

app.use(async ctx => {
  ctx.body = "Hello World";
});

const server = app.listen(3000);

module.exports = {
  server
}; 
```

现在我们可以再次运行`yarn test`。测试应该通过，覆盖率应该是 100%。万岁！

## 使用路由器

http 服务器不能只是一个“Hello World”的广播者。需要不同的路线来提供不同的内容。

```
# Create a file to save all the routes
touch router.js 
```

### 迁移现有代码

我们将首先把“Hello World”代码迁移到`router.js`，同时不让测试失败。

```
// router.js

const router = require("koa-router")();

const route = router.get("home", "/", home);

async function home(ctx) {
  ctx.body = "Hello World";
}

module.exports = {
  route
}; 
```

```
// index.js

const Koa = require("koa");
const { route } = require("./router");

const app = new Koa();

app.use(route.routes());

const server = app.listen(3000);

module.exports = {
  server
}; 
```

现在在`router.js`中定义了路线'/'，测试应该还是通过了。

### 添加新路线

这里以“发布/上传/文本”路线为例进行讨论。

测试第一。

```
// test/index.spec.js

// ...
it("should upload a text", done => {
  chai
    .request(server)
    .post("/upload/text")
    .set("content-type", "application/json")
    .send({ textLayout: "hello" })
    .end((err, res) => {
      expect(res).to.have.status(200);
      expect(res.text).equal("You've sent the text: hello");
      done();
    });
});

// ... 
```

然后实施:

```
// router.js

const route = router
  .get("home", "/", home)
  .post("upload-text", "/upload/text", uploadText);

// ...

async function uploadText(ctx) {
  const text = ctx.request.body.textLayout;
  ctx.body = `You've sent the text: ${text}`;
}

// ... 
```

但是，测试会失败！

原因是需要一个主体解析器，这样 chai-http 才能流畅地工作。这里，我们将使用 koa-body，因为它支持 multipart。

```
# Install koa-body
yarn add koa-body 
```

```
// index.js

// ...

const koaBody = require("koa-body");

// ...

app.use(koaBody());
app.use(route.routes());

// ... 
```

测试现在应该通过了。恭喜你！

## 渲染页面

koa-ejs 用于渲染。细节可以在代码中看到。

## 上传文件

细节可以在代码中看到。

## 回执

我必须感谢 PKUOSA 为我提供了如此宝贵的机会来学习、实践和加强 web 开发技能。