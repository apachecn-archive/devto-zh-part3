# 论抽象——扎克·特尔曼-克洛胡特 2017

> 原文:[https://dev.to/cjthedev/on-abstraction-扎克-特尔曼-克鲁尤特雷-2017-42a3](https://dev.to/cjthedev/on-abstraction--zach-tellman---clujutre-2017-42a3)

扎克·特尔曼是《Clojure 元素》一书的作者。在这个题为“论抽象”的演讲中，他试图定义什么是抽象，以及我们如何通过更好地理解什么是抽象来构建更好的系统。

这本书的目标是你阅读的关于 Clojure 的最好的第二本书，当你知道你能用这种语言做什么，但是你不知道用语言的哪一部分来解决一个特定的问题。

第一章是关于名称:“命名和必要性”。尽管众所周知命名是一个困难的问题，但 CS 并没有足够的文献来解决这个问题。“心理分析学派”已经极其详细地探讨了这个话题。

第二章是关于抽象的，但是没有任何直接针对它的文献，也没有其他范例深入讨论这个主题。

# [](#abstraction)抽象

抽象一词用于指代两个截然不同的概念，通过以下两个概念来证明:

*   教堂数字

    阿隆佐·邱奇的λ演算引入了这些。这些数字被表示为函数，数字 3 是一个函数，它接受一个函数并将其应用于一个值 3 次。

*   Cons 细胞

    通常用于创建链表，基本情况是`Nil`代表一个空集合。

计算机科学中没有使用教堂数字，因为在计算密集型中表示数字，它们在数学中被广泛使用(这是永恒的)。Cons 单元在 CS 中被广泛使用，因为跟随一个链接是快速的，但是情况已经迅速改变，计算机处理的增加比存储器延迟的减少更快。

CS 文献中最常见的抽象的形式化定义来自于东尼·霍尔的论文:《数据表示正确性的证明》，他还给我们带来了《沟通的顺序过程》。

本文介绍了两个主要概念:

> 抽象将内部模型建模到外部语义上。
> 
> 不变量约束内部模型。

抽象是内部实现到外部接口的映射。不变量允许不同的实现，而不需要彼此正确，它们只需要满足不变量。然而，它没有谈到对象运行的环境。

为了定义一个抽象，我们需要 3 个部分:

*   模型

    实施

*   连接

    与模型互动的方式

*   环境

    其他一切

## [](#model)型号

该模型最初是空的，所有数据都来自环境，因此在某种程度上该模型反映了环境。这与物理学为现实世界概念创建模型的方式非常接近。我们不能在软件中做到这一点，因为物理学使用演绎推理来创建一个基于观察的模型，并不断调整它，直到预测是正确的，在软件中建模将需要一个非常复杂的模型。

比物理学家积极参与计算机编程早 50-60 年。1959 年，人工智能的第一次尝试是在一个名为“通用问题求解器(GPS)”的项目中进行的，该项目使用了手段-目的分析。

相反，大多数软件依赖于基于类比的归纳推理，这允许我们跳过许多细节，使模型更加简单。例如:一只扁虱——它附着在某个产生热量或分泌丁酸超过一定阈值的物体上。我们无法为此创建一个完美的模型，但我们也不需要这样做。模型只需要足够精确。

> 该模型只能满足。

希尔伯特·西蒙(全球定位系统的首席研究员)在《人工科学》一书中创造了“实用蹩脚的解决方案”这个术语。

建立演绎模型很容易，但建立一个有用的模型却很难。我们可以在演绎模型的算术上减少一些东西，但这并不意味着预测是正确的。

模型假设它们忽略的一切要么不变，要么不相关。当假设泄露时，我们必须使用约定。这并没有使假设总是有效，而是降低了无效的可能性。

## [](#the-interface)界面

> 随着时间的推移，接口代表许多模型或一个模型的交集。

## [](#consequences-of-our-model)我们模型的后果

抽象就是忽略。

> 思考就是忘记差异、概括和抽象。在极度混乱的娱乐世界里，除了细节什么都没有，几乎是连续的细节。

我们不能在程序中考虑到世界的所有细节，我们必须做出假设来有效地推理。

一个抽象只有在假设是合理的情况下才是有用的。

这意味着软件的有用性是其使用环境的功能。

为了知道一个抽象的假设，我们必须知道它的模型。占有并不意味着理解。

如果模型假设太多，我们可以:

*   将模型放大
*   替换我们的模型
*   缩小我们的预期用例

> 后来的几代人不像他们的祖先那样喜欢研究地图学，他们看到了巨大的地图毫无用处。

如果抽象不能解决用户的问题，他们可以:

*   抛弃抽象
*   包装抽象
*   创建约定

如果一个抽象不能被抛弃，它就变成了强制性的。它看不见的东西可能会消失。

如果没有不断变化的环境，软件会很容易。

环境由三部分组成:

*   整个世界
*   用户
*   其他软件组件

## [](#systems-of-abstractions)抽象的体系

有两种方法:

*   有原则的

    让所有事情都有可预测的结构，这样就可以准确预测变化的副作用。

*   适合的

    使各部分稀疏连接，这样当我们做出改变时，我们只需要对系统进行局部推理。

有两种文化:

*   自我意识

    有一个人叫建筑师，他是建筑设计和建造方面的专家。

*   不自觉的

    每个人都建造自己的家，他们没有创造太多其他的建筑。

有原则的系统有等级制度。每样东西都有它的位置，每样东西都在它的位置。

适应性系统就像图表一样，它们没有一个中心组织原则，我们可以对它们进行局部改变。

如果抽象是一个岛，我们的代码就变成了加拉帕戈斯。只有当变化反映了正在解决的问题时，它才是有用的。

原则性代码是脆弱且可预测的。自适应编码是灵活且不可预测的。没有中间地带。我们能做的是将它们分层。

原则性框架中的适应性组件。自由度变得退化和消失。环境不改变也没什么好适应的。

适应性框架中的原则性组件被称为复杂适应性系统。如果原则性的系统太小，那么我们必须写很多粘合代码。如果它太大，那么更换成本就会变得非常高。

> 一起失败的假设，属于一起。

原则性组件更小更快，可以增量理解。

由于缺乏全面的了解，我们对环境的假设过于乐观，因此我们往往偏向于原则性成分。

平衡是这里的关键，像日志库这样的东西应该是主要组件，每个人都不需要自己开发。而定制需求应该形成适应性环境。

[演讲的原始链接](https://www.youtube.com/watch?v=x9pxbnFC4aQ)

这是我在这个系列的第四篇文章，看看之前的吧:)