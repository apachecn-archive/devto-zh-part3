# Python 依赖堆栈

> 原文:[https://dev.to/dbanty/the-python-dependency-stack-n0d](https://dev.to/dbanty/the-python-dependency-stack-n0d)

任何新的 Python 项目都需要做出很多决定。开发人员投入了大量的精力来为任何工作选择合适的框架和插件。一个我认为经常被忽视的不那么吸引人的决定是我称之为“依赖堆栈”的东西。这些工具涵盖了各种各样的任务，都围绕着如何管理开发和部署中的依赖关系。这篇文章将定义什么是依赖堆栈，它的用途是什么，以及在选择要使用的工具时应该考虑的事情。在后续的一系列文章中，我将讨论一些选择的利弊。

## [](#the-stacks)一迭声

| 名字 | 力量 | 弱点 |
| --- | --- | --- |
| [香草](https://dev.to/dbanty/vanilla-python-stack-99a) | 标准选择 | 最难使用 |
| Pipenv | TBD | TBD |
| 诗意 | TBD | TBD |

## [](#declaring-dependencies)声明依赖关系

几乎每个 Python 项目都需要做的最基本的任务是声明依赖关系(也称为需求)。简而言之，这列出了需要安装的所有库，以便使用您的包。每个依赖项通常都会受到约束，从而限制了已知可用于您的代码的版本。如果您正在创建一个要在某个生产环境中部署的应用程序，那么您的依赖项列表也将充当该应用程序所包含内容的清单，从而更容易检查您正在使用的任何第三方库中的已知安全漏洞。随着项目变得越来越复杂，您可能最终会有多个需求列表，定义一些只为开发人员所需的，或者一些为您的项目提供额外功能但不是严格必需的。您将用于声明依赖关系的“工具”实际上是一个文件，根据您使用的堆栈，有几种格式可供选择。

## [](#virtual-environments)虚拟环境

Python 中一个非常常见的开发模式是为每个项目创建一个单独的“虚拟环境”。这使得拥有不同版本的依赖关系(以及不同版本的 Python！)针对不同的项目。对于可重现的结果来说，拥有独立的依赖关系是非常重要的。许多语言都将本地依赖作为默认行为(npm 的 node_modules)，对于 Python，您需要选择一个工具来管理您的环境，这是依赖堆栈的一部分。

## [](#installing-packages)安装软件包

一旦您定义了依赖项并有了放置它们的地方，您将需要使用一个工具来实际安装它们。理想情况下，这个工具会产生可靠的结果，这样当你旁边的开发人员从相同的需求文件安装时，你们两个都会有匹配的设置(减少“它在我的机器上工作”综合症)。您还希望该工具能够从各种来源进行安装。一些例子可能是公共的 PyPI 存储库、私有的 PyPI repo、Git repo 或本地文件夹(比如说 Git 子模块)。私人 PyPI repos 通常需要认证，所以这个安装工具必须能够处理认证，并且理想情况下能够将您的凭证存储在某个地方，这样您就不必在每次更新时从您的密码管理器中复制它们。

## [](#packaging-your-package)包装您的包裹

虽然 Python 项目的简单源代码分发有很多用例，但您通常希望能够将代码捆绑成另一种格式。特别是，如果你计划发布一个库，你会希望能够建立一个轮子。您选择的工具必须能够包含一系列关于您的项目的元数据(比如版本号及其所有依赖项)。这个过程对你来说越简单越好。开发者应该专注于开发。

## [](#publishing)出版

如果你正在开发一个库(一个被设计为被其他包导入和使用的包)，你很可能想要发布。上传到 PyPI repo(公共或私有)是分发 Python 代码并进行适当版本管理的最简单方法。您的堆栈将需要一个工具来简化这个过程(以及前面的构建步骤),并且可以使用您上传到的任何 PyPI repo 进行身份验证。

## [](#distribution)分布

这个有点重复，因为出版是发行的一种形式，但是出版通常只用于图书馆。如果您正在创建一个应用程序，您将需要一种方法来将该应用程序发送到实际运行它的设备上。您可以发布到 PyPI 回购，但是如果您的包依赖于私有代码，那么任何需要运行该应用程序的机器也需要您的私有回购凭证(至少可以说是不方便的)。有时，下载应用程序依赖的所有库并将其与应用程序捆绑在一起进行分发是非常有用的。这是一个步骤，我在以后的文章中没有一个栈会让它变得更容易，但是有些栈会让它变得更困难。还有另一种形式的分配叫做“冻结”，但我不会涵盖它，因为以我的经验来看，它的麻烦大于它的价值。

就是这样！这些都是 Python 中的常见任务，包含在“依赖堆栈”中。正如我所说的，我将继续发布关于我每天使用的不同堆栈的帖子。你用什么工具来完成这些任务？你认为有什么相关的东西是我漏掉的吗？让我知道！