# Dnsmasq +网络管理器+专用网络设置

> 原文:[https://dev.to/karlredman/dnsmasq-网络管理器-私人-网络-设置-258l](https://dev.to/karlredman/dnsmasq--networkmanager--private-network-setup-258l)

这是用于最小配置的 how to/方法，它提供本地专用网络，本地主机可以使用该网络进行在线和离线(internet/DHCP)连接。目标是为虚拟机和裸机应用系统提供一个可扩展和网络可切换的开发环境。这种方法旨在为开发人员提供漫游(通过笔记本电脑等)和维护一致的网络开发环境的能力。注意，这种配置要求您习惯使用`NetworkManager`。

*   一个 TL；这篇文章的 DR 版本可以在[这里](https://github.com/karlredman/Articles/blob/master/content/dev.to/tldr-dnsmasq-nm.md)找到。

## [](#features-of-this-howto)本 howto 的特点:

*   通过集装箱之间的名称引用码头集装箱。
*   使用主机和容器中的通配符引用主机(专用网络)。
*   离线或在线(几乎)无缝工作/开发。
*   从 docker 容器中引用 internet 主机(如果已连接-很可能是 DHCP)。
*   参考本地主机网络主机(如果已连接-很可能是 DHCP，并且正在运行 DNS)。
*   `/etc/hosts`没有额外的配置
*   实施能力(您的扩展配置):
    *   DNS 缓存。
    *   主机本地专用网络上的 DHCP。
    *   从主机界面通过网络管理器共享网络。
    *   完全支持本地 DNS 的专用网络上的各种虚拟机。

## [](#caveats-limitations)警告/限制

*   您的裸机服务需要针对专用网络(即 10.127.127.1)进行配置，以便利用“docker 容器到主机”DNS 解析。
*   此过程*不*提供从主机解析容器主机名的方法。
*   此过程*不*提供从 from 容器解析容器主机名的方法(见下文解释)。
    *   然而，容器可以使用 Docker 的内部 DNS 通过容器名来解析容器。

## [](#tested-systems)被测系统:

*   MX Linux v18.1
*   ubuntu18.10
*   Debian v9.8

## [](#disclaimer)免责声明:

我**强烈建议**首先用一个虚拟机来测试这个过程。我发现 Virtualbox 是桌面系统最简单的沙盒安装平台，但你的里程可能会有所不同。无论哪种方式，使用备用裸机系统或虚拟机来测试这种方法，看看它是否适合您和您的环境。如果你搞乱了你的系统，数据等，我不负责..此信息按原样提供，使用风险由您自行承担。

此外，我倾向于用你可能不关心的额外信息写罗嗦的 howto 正如这个句子所证明的。我会尽量把它减到最少。；)

## [](#introduction)简介:

TL；大卫:跳过这一部分——这是一个动机陈述...

跨无数虚拟机/容器选项(Docker、kubernetes、singularity、libvert、singularity、LXC 等)开发可联网服务。)具有挑战性。另一个挑战是，作为一名开发人员，在网络间漫游的同时，尝试开发这些类型的服务。对我来说，答案是尽可能模拟各种网络环境。实现这一目标的一个步骤是建立一个基本平台，通过该平台，单个系统(即笔记本电脑)可以在不同的网络环境之间漫游，并保持一致的类似生产的网络模拟——无论是在线、离线、在工作中、在聚会上、在朋友家、在商场、在路上还是在家里(等等)。).

在开发任何软件应用程序时，都有许多“活动部件”。对于每个系统资源，移动部件的数量以数量级增加(也就是说，基本的网络连接使任何应用变得复杂——添加任何可伸缩性的概念，应用的复杂性都会急剧增加)。我在这里的尝试是提供一个极简的配置，这样读者就不必理解现在*的一切是如何工作的*。相反，随着对各种开发环境和工具的需求变得相关，这个基本的网络结构(希望)应该提供一个通用的基线，以便为将来的开发功能添加仿真功能。最后，这个 howto 真的很简单——然而，在一个带有漫游系统的私有网络中进行开发的能力(例如，笔记本电脑)让许多许多开发人员感到困惑。构建一个合适的开发环境的活动部分对我们许多人来说变得非常混乱和令人沮丧。这是压倒性的，因此，我们黑客...

我想出了这个解决方案，以便我可以在一台机器(笔记本电脑)上跨许多虚拟机/容器选项进行开发，而不管我工作的环境/位置和网络。通过 NetworkManager IP addressing +系统级 dnsmasq 的简单配置，我现在可以为任何 IP(在专用网络上)创建任何服务，并最终将它(通过任何 proxypass 工具)代理传递到我的主机网络域——允许我在网络间提供共享服务和/或在隔离系统上开发任意数量的组合虚拟系统；全部在一个系统(笔记本电脑)上。

希望这种方法是向提供一个环境的基础迈出的一步，这种环境有助于独立的、企业的和云的开发。

## [](#configure-networkmanager)配置网络管理器

想必各种 linux 版本的全新安装将在安装时配置 NetworkManager。以下信息假设您已经安装了 linux，能够通过 DHCP 连接到互联网，并且您的网络没有其他问题。

### [](#add-private-network-ip-to-network-manager)向网络管理器添加专用网络 ip

本节为本地主机实现了一个静态 ip 地址，以用于未来的网络和服务。系统上所有未来的网络都将使用此处配置的基本网络基本地址。为了将这个网络用于虚拟系统，您需要识别您的虚拟接口来使用这个网络——或者配置一个桥(超出了本文的范围)。

*   参考[网络管理器-如何添加 dnsmasq 并保持 systemd-resolved (18.04) -问 Ubuntu](https://askubuntu.com/a/1041742)

*   确定要使用的连接(即 eth0、wlan0 等。)

    *   命令

```
nmcli connection show 
```

```
* example output 
```

```
NAME                UUID                                  TYPE            DEVICE
Wired connection 1  xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  802-3-ethernet  eth0
br-0a159c4a8cf4     xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  bridge          br-0a159c4a8cf4
br-b1bce84765b8     xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  bridge          br-b1bce84765b8
docker0             xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  bridge          docker0 
```

*   向我们的网络管理器连接添加一个`10`网络地址

```
nmcli con mod 'Wired connection 1' ipv4.address 10.127.127.1/24
nmcli con mod 'Wired connection 1' connection.autoconnect yes 
```

*   设置连接的(自动)连接优先级
    *   这将强制首先附加此连接，然后附加下面配置的脱机(克隆)版本

```
nmcli connection modify 'Wired connection 1' connection.autoconnect-priority -998 
```

*   更新连接(即保存更改)

```
nmcli con up 'Wired connection 1' 
```

*   注意:不要让*而不是*将新的 IP 地址添加到你的`/etc/hosts`文件中。稍后将通过 Dnsmasq 配置此新地址的网络/主机名。

### [](#clone-connection-and-configure)克隆连接并配置

当您连接到一个不提供 DHCP 连接的网络时，NetworkManager 将(看起来)无限期挂起。克隆工作连接并进行一些调整将提供“脱机”工作的能力，同时维护带有系统 dnsmasq 实例及其(如果已配置)DHCP 功能的专用网络。

当网络*不*提供 DHCP 功能时，您将使用此连接来访问您的本地专用网络。

注意:在网络管理器连接之间切换可能需要您重新启动`dnsmasq` : `sudo service dnsmasq restart`。当从完全 DHCP 认证的互联网连接切换到不完全 DHCP 认证的互联网连接(即不支持 DHCP/互联网的连接)时，通常会出现此问题。相反，我发现，当从隔离网络切换到启用 DHCP 的网络时，很少需要运行`sudo dhclient`。此外，当从 DHCP 网络切换到非 DHCP 网络时，我不得不在各种情况下重新启动，反之亦然——相似性可能非常——抱歉有歧义——这就是网络的状态...).

*   克隆连接

```
nmcli connection clone 'Wired connection 1' 'Wired connection 1 offline' 
```

*   更改克隆的连接设置以支持隔离

```
nmcli connection modify 'Wired connection 1 offline'  ipv4.method manual 
```

## [](#optional-install-resolvconf)(可选)安装解决方案

*   这是网络管理器的一种变通方法，允许更细粒度的解析器配置

```
sudo apt install resolvconf 
```

## [](#install-and-configure-dnsmasq)安装并配置 Dnsmasq

*   安装 dnsmasq

```
# uninstall network manager version of dnsmasq
sudo apt remove dnsmasq-base -y

# install actual dnsmasq
sudo apt install dnsmasq -y 
```

*   启用 dnsmasq 服务

```
sudo systemctl enable dnsmasq 
```

## [](#configure-dnsmasq)配置 dnsmasq

### [](#dnsmasq-configuration-raw-etcdnsmasqconf-endraw-)Dnsmasq 配置`/etc/dnsmasq.conf`

```
address=/private.home/10.127.127.1
listen-address=127.0.0.1
listen-address=10.127.127.1
bind-dynamic       # could use bind-interfaces instead
domain=private.home,10.127.127.0/24
domain=docker.devnet,172.17.0.0/24 
```

### [](#restart-dnsmasq-and-inspect-hosts-file)重启 Dnsmasq 并检查主机文件

*   重新启动 dnsmasq 服务

```
sudo service dnsmasq restart 
```

## [T1】！！！！**重启**！！！！！](#-reboot-)

这是一个值得畏缩的必要性。重启就好，很简单。接受移动部件比你想处理的要多，重新启动的时间真的很少。我个人讨厌这种说法，但是...这就是事情的现状——要么接受它，要么花些时间找到一个通用的方法来绕过重启，然后向:D 报告

*   您的`/etc/resolv.conf`文件将如下所示:

```
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 127.0.0.1
search your-isp.net 
```

*   您的`/etc/hosts`文件看起来会像这样

```
127.0.0.1   localhost
127.0.0.1   this-laptop

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
fe00::0     ip6-localnet
ff00::0     ip6-mcastprefix
ff02::1     ip6-allnodes
ff02::2     ip6-allrouters 
```

## dnsmasq 测试

### [](#after-reboot)重启后:

*   测试本地专用网络(应打印为`10.127.127.1`)

```
ping -c 4 private.home 
```

*   测试 google DNS(从 DHCP 连接的网络)

```
ping -c 4 google.com 
```

*   测试主机主机名

```
ping -c 4 [your hostname here] 
```

*   测试网络上的另一台主机

```
ping -c 4 [a local network hosthame here] 
```

## [](#things-should-be-working-so-far)事情应该到此为止了...

如果在这一点上你没有正确的回答——如果有什么东西似乎坏了——那么要么这个方法在你的操作系统上不适合你，要么你跳过了一个步骤(或者我弄错了，文档是错误的)。

如果您不能通过名称 ping `private.home`和/或`google.com`，那么一定是出了问题。请做平 8.8.8.8(谷歌名称服务器)明确，看看你是否有网络接入，并从那里向后工作。...

## [](#add-docker-container-dns-resolution)添加 Docker 容器 DNS 解析

**重要**:

本节演示了 docker 容器的动态主机名解析，用于*容器到容器*和*容器到主机*的解析。现代的 Docker 容器名称可以通过桥接网络进行解析——我们将创建桥接网络。此外，因为我们已经建立了一个私有网络，容器将能够将主机的主机名解析回我们的私有 10.127.127.1 ip 地址(之前建立的)。

注意:在生产环境中，通常不需要将主机解析为容器主机名(甚至被认为是一个好主意)。观点是，虚拟机将端口导出到主机，而不考虑(或者更恰当地说，不管)本地主机。容器中的不是主机的本地主机，即容器的本地主机在其自己的名称空间/地址空间内是 127.0.0.1，而主机的本地主机相对于主机系统的物理组件是 127.0.0.1。容器有自己的本地主机**，与主机系统分开**。

### [](#install-docker)安装 docker

1.  做一个`sudo apt update`
2.  手动下载并安装`.deb`文件(因为 mx linux 本身不支持/etc/apt/sources.list)
    *   参考:[获取 debian 的 ce 坞站| docker documentation](https://docs.docker.com/install/linux/docker-ce/debian/#install-from-a-package)
    *   参考:[顶层下载路径](https://download.docker.com/linux/debian/dists/stretch/pool/stable/amd64/)
        1.  [下载并安装 docker-cli](https://download.docker.com/linux/debian/dists/stretch/pool/stable/amd64/docker-ce-cli_18.09.1~3-0~debian-stretch_amd64.deb)
        2.  [下载并安装 containerd.io](https://download.docker.com/linux/debian/dists/stretch/pool/stable/amd64/containerd.io_1.2.2-1_amd64.deb)
            *   docker 守护进程将自动启动
        3.  [下载并安装 docker-ce](https://download.docker.com/linux/debian/dists/stretch/pool/stable/amd64/docker-ce_18.09.1~3-0~debian-stretch_amd64.deb)
3.  测试对接器

```
sudo docker run hello-world 
```

### [](#install-docker-compose)安装坞站复合材料

*   参考[安装 Docker 撰写](https://docs.docker.com/compose/install/)
    *   [发布 docker/compose](https://github.com/docker/compose/releases)

```
# be sure to get the latest version (that is compatible with docker -most likely latest...)
#
sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose 
```

### [](#build-an-image-for-testing)构建一个映像进行测试

此图像用于测试本文档中指定 Docker 的地方。

```
git clone https://github.com/karlredman/lighttpd-docker.git
#
cd lighttpd-docker
#
sudo docker build -t lighttpd . 
```

### [](#create-common-docker-network-for-containers)为集装箱创建公共码头网络

*   这个部分创建了一个公共网络，所有的`docekr run`命令和`docker-compose`实例可以相互通信——包括从各自的容器实例中解析 docker 容器名称的能力。

*   为要求 FQDN(完全限定的域名)的挑剔应用程序指定一个用`.`(点)分隔的网络名称。

*   注意:在可能的情况下(如果需要)在名称中使用`-`而不是`_`,以保持与各种工具的兼容性。

```
sudo docker network create docker.devnet 
```

### [](#add-dns-to-docker-daemon)将 DNS 添加到 Docker 守护进程

*   /etc/dock/daemon . JSON 文件

```
{  "dns":  ["10.127.127.1",  "8.8.8.8"]  } 
```

*   重新启动停靠守护程序

```
sudo service docker restart 
```

### [](#testing-host-to-docker-container-dns-resolution)测试主机对 Docker 容器的 DNS 解析

*   开始测试容器

```
# start FQDN hostname docker container 1
sudo docker run -d -p 8081:80 -p 4441:443 --rm -t --name docker-container-1-name -h docker-container-1.docker.devnet --net docker.devnet lighttpd

# start container 2
sudo docker run -d -p 8082:80 -p 4442:443 --rm -t --name docker-container-2-name -h docker-container-2 --net docker.devnet lighttpd

# start container 3
sudo docker run -d -p 8083:80 -p 4443:443 --rm -t --name docker-container-3-name -h docker-container-3 --net docker.devnet lighttpd 
```

*   测试 DNS 解析

```
####### normal docker behavior with user-defined network 'docker.devnet'
#
# ping container 3 *container name* from container 2 sudo docker exec -ti docker-container-2-name sh -c "ping -c 4 docker-container-3-name"
#
# ping private network host wildcard from a container
## Note: if this part isn't working then you likely are being blocked by your own firewall sudo docker exec -ti docker-container-1-name sh -c "ping -c 4 a-wildcard.private.home" 
```

## [](#thats-it)就是这样！

我希望这对你有用...