# C#/中的界面分离原理。网

> 原文:[https://dev . to/scotthannen/-the-interface-segregation-principle-applied-in-net-2edd](https://dev.to/scotthannen/-the-interface-segregation-principle-applied-in-net-2edd)

接口隔离原则(ISP)的常见定义是:

> 不应该强迫任何客户端依赖它不使用的方法。

这要早于。NET 框架，那么如何才能把它应用到。网码？

*   “客户端”是一个依赖于另一个类或接口的类。
*   “接口”一词并不是特指`interface`关键字。一个类可以依赖于另一个类的公共成员。但是我们经常编写我们的“客户端”类来依赖用`interface`关键字定义的接口。

因此，虽然这篇文章(以及许多其他文章)将该原则应用于用`interface`关键字声明的接口，但该原则并不仅限于此。

在这种情况下,“depend”这个词可能会有点令人困惑。我们怎么能依赖一个方法却不使用它呢？这实际上意味着我们不应该依赖于包含我们不使用的方法的接口。

### [](#a-very-simple-example)一个很简单的例子

```
public interface IDoesStuff
{
    void DoSomething();
    void DoSomethingElse();
    void DoesEvenMore();
}

public class ClientThatDependsOnInterface
{
    private readonly IDoesStuff _dependsOnThis;

    public ClientThatDependsOnInterface(IDoesStuff dependsOnThis)
    {
        _dependsOnThis = dependsOnThis;     
    }

    public void ClientMethod()
    {
        _dependsOnThis.DoSomethingElse();
    }
} 
```

在这个例子中,`ClientThatDependsOnInterface`依赖于`IDoesStuff`,但是没有使用它的三个方法中的两个。这并不意味着我们
应该改变`ClientThatDependsOnInterface`，让它使用所有三种方法。相反，它应该只是依赖于一个不同的接口，只有
有它需要的方法。

### [](#what-it-isnt)这不是什么

我看过几个关于接口分离原则的帖子，看起来更多的是关于单一责任和 Liskov 替换。

一些人指出我们的接口应该小，方法要少。的确如此，但这更多地与单一责任原则有关。如果我们的接口有 23 个方法，并且一个类依赖于所有的 23 个方法，那么我们有一些严重的代码气味，但是客户端是被迫依赖于它不使用的方法的。接口实现和依赖它的类可能都有太多的责任。

其他人指出，如果我们的接口有太多的方法，我们可能会发现自己创建了实现该接口的类，但是为我们还没有实现的某些方法抛出了一个`NotImplementedException`
。有一个 ISP 违规，因为依赖接口*的类不能*依赖它的所有方法。如果有，它会抛出一个`NotImplementedException`。但是违反 ISP *而不*抛出`NotImplementedException`，
仍然是可能的(也是更常见的)，所以它仍然不能很好地说明 ISP。抛出这个异常更像是一个 Liskov 替换问题。ISP 是关于依赖一个带有我们不需要的方法的接口，
不创建不能完全实现接口的类。

顺便说一句，我有时觉得这些原则的名字有点自命不凡，好像它应该听起来很聪明，或者让我与制定这些原则的大人物站在一起。那不是我的意图。如果是的话，我觉得没用。我提到它们是因为，在我看来，它们是非常好的原则。
它们不是凭空发明的。它们是多年经验和分析的结果。然后，根据我自己的经验，我发现我工作的代码
中的许多问题都可以追溯到对这些原则的违反。这使它们成为很好的遵循准则。没有人说我们必须毫无例外地严格遵守它们，
但我们应该明白，这种异常的积累是导致我们的代码一团糟的原因。

### [](#what-it-is)这是什么

引用鲍勃叔叔的文章，他在文章中定义了这个原则:

> ...当一个客户端依赖于一个包含该客户端不使用但其他客户端使用的接口的类时，那么该客户端将会受到其他客户端强加给该类的变化的影响。

假设我们有一个包含三个方法的接口。然后我们有三个依赖于接口的类，每个依赖于不同的方法。这三个类别虽然互不相关，但在某种程度上是相互联系的。如果我们改变一个方法来满足依赖它的一个类的需求，我们仍然在
改变另外两个不需要改变的类所使用的接口。那么对接口实现的更改更有可能影响
依赖于其他两个方法的类。

实际上，依赖于该接口的所有类都变得相互耦合:

*   一个类需要改变接口来支持它自己的需求。
*   对接口的更改会迫使实现它的类发生更改。
*   对类的更改可能会影响接口的其他客户端。

这篇文章确实提到了“胖”接口，但不是关于方法的数量:

> 具有“胖”接口的类是接口不内聚的类。换句话说，类的接口可以分成成员函数组
> 。每个小组为不同的客户群服务。因此，一些客户端使用一组成员函数，而其他客户端使用其他组。

正如开始提到的，这不仅仅是关于接口。它适用于不同的客户使用同一个类的不同方法的情况。如果十几个类依赖于十几个接口，但是一个类实现了所有十二个接口，那么我们可以将这个原则应用到我们的接口上，而在我们的类中忽略它。我之所以将这更多地应用于接口，是因为单一责任原则独立地防范了做太多不相关事情的类。

如果我们在接口中违反了它，那么我们在类中也会违反它。我对一个代码库进行了独立分析，发现了一个由大型接口实现的大型类。两组客户使用了两套方法。NDepend 将其标记为没有凝聚力的 T2，并建议将其解散。它怎么知道的？因为
因为两组方法使用了两组不同的依赖项和成员变量，没有重叠。正如上面所描述的，
这个类实际上是两个不相关的类，当它可以被清晰地分成实现两个接口的两个类时，它们最终成为一个。当我们需要为类中大约一半的方法提供完全不同的实现时，这就是我不得不做的事情。它需要对许多类进行修改，如果它们不都依赖于一个巨大的接口，我就不会去碰它们。

我们为什么要这么做？在某些时候，有人需要与任何现有类都不相关的新功能，并选择将其添加到现有类中
，而不是创建一个新的类。这并不像我们每次使用`class`和`interface`关键词时都要支付额外的许可费。

### [](#how-to-created-segregated-interfaces)如何创建隔离接口

尽管大接口是一个潜在的问题，ISP 并不关心接口的大小。它是关于类是否使用它们所依赖的接口的成员。还记得违规的例子吗？问题不在于这个类需要使用整个接口。那就是
接口需要被限制在类所需要的范围内。除了一些广泛的通用接口，如记录器，只有当
接口是从需要依赖它的类的角度编写的时候，这才是可能的。

总而言之，这就是我们如何在 C#中应用接口分离原则:

从依赖接口的类的角度定义接口。

不要只是拿一个看起来和你的类需要的接口相似的现有接口，然后修改它或者向它添加方法。确定你的类需要依赖什么，用接口描述。

假设您的类需要验证一个销售订单，以确保它不包含错误。可能会有一些像
`IOrderService`这样巨大的、名字模糊的接口，有 36 种方法。不要再加了。也许该接口已经包含了您需要的方法。无论如何，请考虑不要使用该接口。

相反，只需定义您的类需要的接口:

```
public interface IOrderValidator
{
    void ValidateOrder(Order order);
} 
```

如果没有实现，那么你可以创建一个新的单一责任类来实现它。如果有，那么您可以将现有的
实现应用到您的接口中，或者将它的一部分重构到一个单独的类中。通过这种方式，您可以防止不必要的耦合，或者至少避免使其恶化。

我发现这种方法帮助我一次处理一个类，而不是纠结于如何实现依赖关系。
该类需要验证其订单，因此它依赖于`IOrderValidator`。我现在不关心实现。我可以下一步、以后或者永远不做那个

。我所说的“从不”是指另一个开发人员可以实现该接口。一次上一门课让我不断前进。

有时我也看到 StackOverflow 问题，开发人员试图找出复杂的泛型类型和继承，这没有任何意义，浪费了很多时间。我自己已经在一遍又一遍地做过了。
这与 ISP 有点跑题，但这种方式也能让我们摆脱常规。我们不是创建复杂的类，然后弄清楚如何使用它们，而是以另一种方式工作——从我们需要实现的接口开始，然后实现它。这促使我们
去写我们需要的代码，而不是去解决我们无缘无故想出来的奇怪的、无意义的问题。

### [](#delegates-are-segregated-interfaces)委托是隔离的接口

这引起了我最近的兴趣。你会认为我买了代表的股票，希望价格上涨。但简而言之，委托是一个方法的
接口，这使得它们尽可能地分离。

如果我定义并依赖于这个委托:

```
public delegate OrderValidationFunction(Order order); 
```

...那么我不会依赖一个我不需要的方法。

另一个好的副作用是没有带有奇怪、冗余名称的单方法接口，如`IOrderValidator`和`ValidateOrder`。
`IOrderValidator`就是“用一个`ValidateOrder`方法接口”的意思如果它是一种检索数据的方法，情况会变得更糟。如果方法
是`GetOrderValidationRules`，那么你怎么称呼这个接口？`OrderValidationRulesProvider`？如果我正在保存和检索数据，那么
也许那就是一个存储库。但是如果我只是“得到”一些东西，那么我可能不需要一个全新的界面。

### 分离的接口使单元测试更容易

你是否曾经不得不对一个依赖于一个有 40 个方法的接口的类进行单元测试，但是使用了其中的 6 个，也许这个方法中有一个，这个方法中有两个，等等？您必须通读各种方法，以确定哪些测试要模拟哪些接口成员。在某些情况下,
开发人员只是放弃并创建一个巨大的测试设置来模仿一切。它工作了，但是现在测试是不可理解和不可维护的。

用一些方法模仿一个接口很容易。嘲笑代表甚至更容易。

所有这些在某种程度上都与单一责任原则有关。对我来说，违反 SRP 才是真正令人头疼的地方。ISP 帮助我们避免给现有的类增加责任的压力。像其他坚实的原则一样，它不会阻止我们编写糟糕的代码。它影响我们写出更好的代码。