# 类型系统:动态对静态，强对弱

> 原文：<https://dev.to/jiangh/type-systems-dynamic-versus-static-strong-versus-weak-b6c>

几乎每种实用的编程语言都有一个类型系统，该系统指定如何将类型分配给语言中的各种构造，以及这些类型的构造如何相互交互。大多数程序员用两组属性来描述类型系统。一个与类型系统的规则何时被执行有关(也称为类型检查):动态的还是静态的；另一个与类型系统提供多少安全保证有关:强还是弱。

这是一个令人困惑的话题。我在多个声誉良好的网站上看到一些文章，声称静态类型意味着变量需要在使用前声明，而动态类型则不然。这是非常误导的。Haskell 是一种静态类型语言，然而程序员不需要声明每个名字的类型 <sup id="fnref1">[1](#fn1)</sup> 。类型是从名称的使用方式推断出来的。它的可选类型注释主要是为了方便读者而不是编译器。也看到过把动态等同于弱，静态等同于强的文章。这也是不对的。动态类型语言可以比静态类型语言具有更强的类型。

为了理解这种区别，我们需要将名称和值分开。名字是你在程序中用来引用实体如对象和函数的标识符。价值观就是实体本身。一个名字在不同的时间可以引用不同的值，一个值可以用不同的名字引用。

在静态类型语言中，名字有类型，名字的类型通常不能在其作用域内改变。某种类型的名称只能引用该类型的值。在像`a = sum(b, c)`、`a`、`b`、`c`、`sum`这样的语句中，都有类型。编译器检查`a`和`b`的类型是否与`sum`的参数类型匹配，以及`sum`的结果类型是否与`a`的类型匹配。否则，它会发出一个类型错误，并拒绝编译程序。

在动态类型语言中，名字本身没有类型，但是它们引用的值有。在最后一个例子`a = sum(b, c)`中，当程序运行时，语言运行时查看值`b`和`c`，并确保它们是可以应用`sum`的类型。例如，`sum(b, c)`可能被实现为`b + c`，语言运行时检查`b`和`c`是否引用了操作符`+`所定义的类型。如果没有，它抛出一个异常。

让我们通过一些例子来看看类型安全的优势。

C 和 Rust 都是静态类型的，但是它们提供不同级别的类型安全。考虑下面的 C 程序:

```
#include <stdio.h> 
int main() {
  int numbers[] = {0, 1, 2};
  printf("%d", numbers[6]);
  return 0;
} 
```

它有一个明显的问题，但可以编译成功。根据您使用的编译器，您可能会看到一个警告，但这只是编译器为帮助程序员而添加的一个启发。C 语言标准允许程序被编译。当我在 Mac 上运行这个程序时，它会打印出`32766%`,也就是那个内存位置上发生的任何乱码。如果这是一个复杂的程序，它很可能是一个令人沮丧的 bug。

下面的 Rust 程序试图做同样的事情:

```
fn main() {
    let numbers = [0, 1, 2];
    println!("{}", numbers[5]);
} 
```

但是在编译时，会发出下面的错误。它没机会跑了。

```
error: index out of bounds: the len is 3 but the index is 5
 --> array.rs:3:20
  |
3 |     println!("{}", numbers[5]); 
```

这是因为在 Rust 中，长度是数组文字类型的一部分，所以`[0, 1]`和`[0, 1, 2]`实际上是不同的类型。在这种情况下，编译器可以通过查看类型来检测对数组文字的非法访问。要验证这一点，请在 rust 代码中添加一行:

```
fn main() {
    let numbers = [0, 1, 2];
    let foo: () = numbers;  // <- add
    println!("{}", numbers[5]);
} 
```

您将从编译器中看到以下错误:

```
error[E0308]: mismatched types
 --> array.rs:3:19
  |
3 |     let foo: () = numbers;
  |                   ^^^^^^^ expected (), found array of 3 elements
  |
  = note: expected type `()`
             found type `[{integer}; 3]` 
```

这是我们故意添加的类型不匹配错误，用来显示`numbers`的类型。最后一行说是`[{integer}; 3]`，其中`3`是数组的长度。对于可变大小的向量，Rust 使用一个`Result`类型来迫使程序员检查越界错误的可能性。

声名狼藉的 Perl 和 PHP 类型系统折磨了无数编程灵魂。以下是从官方 PHP 手册一字不差地复制过来的:

```
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11) 
```

PHP 和 Perl 对类型不匹配非常宽容，尽可能将参数转换成任何需要的类型。对于快速和肮脏的脚本，它们可能允许程序员用尽可能少的代码完成事情，但是对于大型项目，它们擅长隐藏错误。今天广泛使用的大多数其他语言都需要在不相关的类型之间进行显式转换，无论它们是动态类型还是静态类型。例如，在 Clojure 中，您需要调用`Integer/parseInt`将字符串解析为整数。

静态类型检查和强类型系统都有助于尽早发现错误，通常是以使程序更加冗长为代价，但它们是不同的东西。

* * *

1.  Haskell 没有值“可变”的变量，所以我在这里避免使用这个术语。 [↩](#fnref1)