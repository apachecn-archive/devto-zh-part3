# 编写测试的最佳时间

> 原文:[https://dev . to/siddharthkp/the-best-time-to-write-tests-45l 5](https://dev.to/siddharthkp/the-best-time-to-write-tests-45l5)

我为我的时事通讯写了这篇文章，[在这里注册](https://sid.studio/newsletter)每周都会收到这样的邮件。

> 我，来自过去:
> 
> “为我的代码编写测试毫无意义。我只是测试了我的代码，为它们编写测试并没有增加任何额外的价值。
> 
> 每次我修改代码，我也必须修改测试，因为它们已经过时了。"

我花了一段时间才意识到测试代码不是无用的，我的测试工作流程是无用的。

维护一个代码覆盖率高的测试套件是很难的。它总是让人感觉有更多的工作要做，并且是当你时间不够时第一个被忽略的事情。如果您想保持一个健康的测试套件，您应该在编写代码之前还是之后立即编写测试？

我是这样做的:当我写一个新特性时，我不写测试。我在不得不改变它之前写下它们。

让我解释一下，

> 对于每个想要的改变，让改变变得容易(警告:这可能很难)，然后让改变变得容易

这是我最喜欢的维护代码的名言。我读了几遍才明白这是什么意思-

当你写一段代码时，你是用你当时最好的理解和最新的信息来写的。

几个月后，您必须扩展这段代码来添加对另一个用例的支持。您必须在现有代码的基础上安装新的逻辑。这是可行的，但并不总是最好的结果。您的代码变得复杂，因为它最初并没有考虑到这个新特性。下周，你团队中的某个人会称之为“遗留代码”。

如果您从一开始就知道所有这些信息，那么您将会编写出非常不同的原始代码。它将能够以一种干净的方式适应这个特性。但是，当然，我们不擅长预测未来。

Kent Beck 建议，不要试图在现有代码的基础上强行添加新的用例，而是分两步进行更改:

> 使改变变得容易(执行)

首先，重构现有的代码，让它看起来好像你从一开始就知道这个新特性。

> 然后做出简单的改变

接下来，添加代码来支持新的用例。这一部分相当简单，因为您的代码是为这种变化而构建的。

这种做法真的让我产生了共鸣。你总是在重构代码以保持它的新鲜。

你不必要求时间或许可来支付技术债务，因为你在增加新功能的同时不断减少它。代码永远不会成为“遗产”。

从表面上看，这可能会让你慢下来，因为你做了更多的工作。根据我的经验，这几乎总是比做出*硬改变*要快，因为你没有花任何时间去试图理解复杂的代码或修复回归错误。

可以想象，在这种情况下进行测试会非常方便。但是，我已经有了吗？大概不会。

以下是我的工作流程:

1.  我首先为现有的代码块编写测试。

2.  然后，我重构它，使新的变化更容易引入。这些测试有助于在不破坏任何现有功能的情况下更快地进行这些更改。

3.  完成后，我做了一个简单的改变，添加了新的特性和测试来支持它。

让改变变得容易，然后让改变变得容易。

当需要时，我会创建两个不同的 pull 请求——一个引入测试并显示它们在重构后仍然通过，另一个添加新特性。

这两个拉请求都轻松地通过了评审过程，因为评审者看到的是简化的代码，并且对测试有信心。对于试图在现有逻辑之上实现*硬更改*的拉请求，情况就不一样了。

##### 注:在懒惰的一天，我经常会毫不费力地添加新功能。没关系，你不可能每天都处于最佳状态。然而，这确实会反过来困扰我，要么是冗长的代码审查，要么是溜进去的 bug，要么是下一次我需要接触这些代码时需要更多的重构。

在此工作流程中，我希望您指出两件事:

1.  为一个特性编写测试的最佳时间是在你改变它之前。

如果你正在一个没有测试的代码库上工作，你可以在任何你必须做出一个看起来很困难的改变的时候开始添加测试。

您的代码库中经常变化的部分是从测试中受益最大的部分。为了代码覆盖率而追求代码覆盖率不会改善你的应用。

2)测试不仅仅是为了捕捉 bug。

有了上面的方法，测试可以帮助你创建一个可以一个接一个检查的用例清单✅

一旦你知道需要写什么逻辑，剩下的工作就是简单地输入它。

这个工作流程帮助我从测试中获益，即使我不能预先投入很多时间。

我明白了最好的方法是为你工作的方法，帮助你写出更好的应用程序。

希望这对你的旅程有用！

（同 suddenionosphericdisturbance）电离层的突然骚扰

* * *

[![newsletter](../Images/92e996eac08edab05705ed94cc61f7e7.png)T2】](https://sid.studio/newsletter)