# 基本算法

> 原文:[https://dev.to/vrnsky/basic-algorithms-4bhc](https://dev.to/vrnsky/basic-algorithms-4bhc)

## [](#basic-termins-of-the-algorithms)算法的基本术语

算法调用步骤序列，通过执行它们得到一些结果。
更多详细信息，请看维基[算法](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)

算法执行的速度用大 O 符号表示。其显示了随着输入数据增加，操作计数增加了多少。

## [](#binary-search)二分搜索法

二分搜索法。这个算法是为在数组中搜索元素而设计的。在开始搜索之前，我们需要对输入数据进行排序。如果输入数据没有排序，则算法失败。我们如何找到搜索元素的元素索引

1.  在数组中查找中间元素:`(middle=array.length-low)/2`

1.  将 array[middle]中的元素与 search 元素进行比较，使事情变得更糟。
2.  如果`array[middle]`大于搜索元素，则将指针从中间移动到高位- 1
3.  如果上述表达式为假，则使 low = middle + 1
4.  当低< =高时，重复步骤 1-4

## [](#selection-sort)选择排序

效率-在最坏的情况下`O(n^2)`
该算法通过以下方式工作:

1.  查找数组中最小元素的索引。
2.  获取位于步骤 1 中创建的索引处的值。
3.  将值保存到新数组中，我们接受该数组已排序。
4.  从位于步骤 1 中创建的索引处的原始数组值中移除。
5.  当数组不为空时，重复 1-4

## [](#bubble-sort)冒泡排序

效率`O(n^2)`(使用内部 for 循环实现)

1.  从零索引开始循环。
2.  进行另一个循环，从一个索引开始。
3.  从位于循环的外部和内部索引计数器的数组中获取元素。4.比较元素，如果需要，交换元素。

## [](#fast-sorting)快速排序

这个算法用在`java.lang.util.Collections.sort`的
效率`O(nlog(n))`

1.  选择任何标记为基本元素的元素(最好选择中间的元素)。
2.  在基本元素的左边，收集所有比基本元素小的元素。
3.  在基本元素的右边，收集大于基本元素的所有元素。
4.  重复步骤 1-3，直到我们没有一个长度为 1 的数组。

## [](#deepth-search)深度搜索

该算法适用于图形数据结构。以人们的朋友为例。例如，如何在你的环境中找到书籍的卖家。

1.  首先检查我们没有在我们的朋友或朋友的朋友的书店
2.  如果图书销售商在步骤 1 检测到。很好！
3.  如果找不到卖书人，我们就去更深的地方。开始搜索你朋友的朋友的朋友。
4.  重复步骤 1-3，直到我们没有结果。

## [](#greedy-algorithm)贪婪算法

这种算法专为寻找可接受的解而设计，并不理想。
例如，将按箱装载车辆

1.  在所有箱子中，需要找到最大的箱子，并把它搬到车上。
2.  在剩下的箱子中，需要找到最大的箱子并把它搬到车上。
3.  重复步骤 1-2，直到我们有一个箱子或在车辆上有一个空间

## [](#k-nearest-neighbors)k 个最近邻居

用这个算法可以建立一个建议系统。
更深入地说，网飞的建议系统依赖于这种算法。

1.  当用户登录时，用户必须评价他喜欢的电影和连续剧的类型。用户制作后，我们将其转换成数字信息。
2.  在毕达哥拉斯找到具有相似偏好的用户后
3.  建议用户已经看到它的邻居按照它的兴趣排序。

## [](#sha)沙

SHA 是安全散列算法的缩写。这是安全算法。我们需要它来保护我们的密码和其他敏感数据
这个算法接受的是输入字符串值，在输出我们有给定字符串的散列:god - > 2aec4f....

这个算法只有一个工作方向。您不能将哈希反转为字符串。
此算法也是局部独立的。例如，如果我们有两个字符串:dog，dot。
两者的哈希会有所不同。

## [](#blum-filters)百隆过滤网

当我们需要提高某些操作的速度时，使用这个过滤器。例如，我们需要检查网站是否无效。问题包括，我们有一个巨大的所有网站的表。搜索将会花费很长时间。
百隆过滤器允许我们做出一些猜测——站点有效和站点无效。
过滤不理想，通过这种方式我们有假阳性。这使得无效站点被标记为有效。排除假阴性。

## [](#ocr)OCR

OCR 作为光学字符识别的 acronim——Google Translate 中的算法用于直接翻译论文。首先，我们必须研究我们的算法。之后，我们可以将标准具图像与纸上的轮廓进行比较