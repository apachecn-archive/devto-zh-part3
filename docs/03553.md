# 詹金斯管道教程:连续交付初学者指南

> 原文:[https://dev . to/zulaikha 12/Jenkins-pipeline-tutorial-a-beginner-s-guide-to-continuous-delivery-1hf 1](https://dev.to/zulaikha12/jenkins-pipeline-tutorial-a-beginner-s-guide-to-continuous-delivery-1hf1)

# [](#jenkins-pipeline-tutorial)詹金斯管道教程

我们都知道 Jenkins 已经被证明是实现持续集成、持续测试和持续部署以生产高质量软件的专家。谈到持续交付，Jenkins 使用了一种称为 Jenkins pipeline 的功能。为了理解为什么要引入 Jenkins pipeline，我们必须理解什么是持续交付，以及为什么它很重要。

[![Alt text of image](../Images/efe3a771512df51289ef5c9f983da24d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--FOk1gZGl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/jenkins-pipeline-diagram.png)

简而言之，持续交付就是始终发布软件的能力。这是一种确保软件始终处于生产就绪状态的实践。

这是什么意思？这意味着每次对代码或基础设施进行更改时，软件团队必须以这样一种方式工作，即快速构建这些更改，并使用各种自动化工具进行测试，然后将构建交付生产。

通过加速交付过程，开发团队将有更多的时间来实现任何需要的反馈。这个过程，以更快的速度将软件从构建到生产状态，是通过实现持续集成和持续交付来实现的。

持续交付确保了软件的构建、测试和发布更加频繁。它降低了增量软件发布的成本、时间和风险。为了实现连续交付，Jenkins 引入了一项名为 Jenkins pipeline 的新功能。本詹金斯管道教程将帮助您了解詹金斯管道的重要性。

# [](#what-is-a-jenkins-pipeline)什么是詹金斯管道？

管道是通过使用自动化工具将软件从版本控制带到最终用户手中的作业的集合。这是一个用于在我们的软件开发工作流程中合并连续交付的特性。

多年来，已经有多个 Jenkins pipeline 版本，包括 Jenkins 构建流、Jenkins 构建管道插件、Jenkins 工作流等。这些插件的关键特性是什么？

它们以管道的形式将多个 Jenkins 作业表示为一个完整的工作流。
这些管道是做什么的？这些管道是 Jenkins 作业的集合，它们以指定的顺序相互触发。
我用一个例子来解释一下这个。假设我正在 Jenkins 上开发一个小应用程序，我想构建、测试和部署它。为此，我将分配 3 个作业来执行每个流程。因此，job1 负责构建，job2 负责执行测试，job3 负责部署。我可以使用 Jenkins 构建管道插件来执行这项任务。在创建了三个作业并将它们按顺序链接起来之后，构建插件将把这些作业作为一个管道来运行。

此图显示了在管道中同时运行的所有 3 个作业的视图。

[![Alt text of image](../Images/c14848b25ae9b1e026444bf19208f004.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--cztbqmIt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/build-pipeline-image.png)

这种方法对于部署小型应用程序非常有效。但是，当复杂的管道中有几个过程(构建、测试、单元测试、集成测试、预部署、部署、监控)运行数百个作业时，会发生什么呢？

这种复杂管道的维护成本是巨大的，并且随着工艺数量的增加而增加。构建和管理如此大量的作业也变得很乏味。为了解决这一问题，引入了一个名为 Jenkins Pipeline Project 的新功能。

这个管道的关键特性是通过代码定义整个部署流程。这是什么意思？这意味着 Jenkins 定义的所有标准作业都是作为一个完整的脚本手动编写的，它们可以存储在版本控制系统中。它基本上遵循“管道即代码”的原则。现在，您可以对整个工作流进行编码，并将其放在一个 Jenkinsfile 中，而不是为每个阶段构建几个作业。以下是您应该使用 Jenkins 管道的原因列表。

# [](#jenkins-pipeline-advantages)詹金斯管道优势

-它通过使用 Groovy DSL(域特定语言)
将简单到复杂的管道建模为代码-代码存储在一个名为 Jenkinsfile 的文本文件中，该文件可以被签入 SCM(源代码管理)
-通过将用户输入合并到管道中来改进用户界面
-它在 Jenkins 主程序的计划外重启方面非常耐用
-它可以从保存的检查点重启
-它通过合并条件循环、fork 或 join 操作来支持复杂的管道，并允许并行执行任务
-它可以与其他几个插件集成

# [](#what-is-a-jenkinsfile)什么是 Jenkinsfile？

Jenkinsfile 是一个文本文件，它将整个工作流存储为代码，并且可以将其签入到本地系统的 SCM 中。这有什么好处？这使得开发人员能够随时访问、编辑和检查代码。

Jenkinsfile 是使用 Groovy DSL 编写的，它可以通过 text/groovy 编辑器或 Jenkins 实例上的配置页面来创建。它基于两种语法编写，即:

1.  声明性管道语法
2.  脚本管道语法

声明性管道是一个相对较新的特性，它将管道作为代码概念来支持。它使管道代码更容易阅读和编写。这段代码写在一个 Jenkinsfile 中，可以签入一个源代码控制管理系统，比如 Git。

然而，脚本管道是编写代码的传统方式。在这个管道中，Jenkinsfile 写在 Jenkins UI 实例上。虽然这两个管道都基于 groovy DSL，但是脚本管道使用更严格的基于 groovy 的语法，因为它是第一个建立在 groovy 基础上的管道。因为这个 Groovy 脚本通常不是所有用户都想要的，所以引入了声明性管道来提供更简单和更多可选的 Groovy 语法。

声明性管道在标记为“管道”的块中定义，而脚本化管道在“节点”中定义。这将在下面用一个例子来解释。

# [](#pipeline-concepts)管道概念

## [](#pipeline)管道

这是一个用户定义的模块，包含所有流程，如构建、测试、部署等。它是 Jenkinsfile 中所有阶段的集合。所有阶段和步骤都在该块中定义。它是声明性管道语法的关键块。

[![Alt text of image](../Images/e740f3452fde0cfcf46b7b0a8789082d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--9uMcoE1p--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/pipeline-new.png)

## [](#node)节点

节点是执行整个工作流的机器。它是脚本化管道语法的关键部分。

[![Alt text of image](../Images/53a5953360763340c82d0a3611145c66.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--pamG5-cu--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/node-new.png)

声明式管道和脚本式管道都有各种通用的强制部分，例如必须在管道中定义的阶段、代理和步骤。这些解释如下:

## [](#agent)代理

代理是一个指令，它可以仅使用一个 Jenkins 实例运行多个构建。该特性有助于将工作负载分配给不同的代理，并在一个 Jenkins 实例中执行多个项目。它指示 Jenkins 为构建分配一个执行程序。

可以为整个管道指定单个代理，也可以分配特定的代理来执行管道中的每个阶段。代理使用的几个参数是:

**Any**
在任何可用的代理上运行管道/阶段。

**无**
该参数应用于管道的根，表示整个管道没有全局代理，每个阶段必须指定自己的代理。

**标签**
在带标签的代理上执行流水线/阶段。

**Docker**
该参数使用 Docker 容器作为管道或特定阶段的执行环境。在下面的例子中，我使用 docker 来获取一个 ubuntu 图片。这个映像现在可以用作运行多个命令的执行环境。

[![Alt text of image](../Images/4e44150a1d4054550f49cf61c7971411.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--yQoWZQ1Q--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/agent-300x143.png)

## [](#stages)阶段

该块包含所有需要执行的工作。这项工作是以阶段的形式规定的。该指令中可以有多个阶段。每个阶段都执行特定的任务。在下面的例子中，我创建了多个阶段，每个阶段执行一个特定的任务。

[![Alt text of image](../Images/974c281260230680331e6e260f9ff65f.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--X7Di9WDM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/4.png)

## [](#steps)步骤

可以在一个阶段块中定义一系列步骤。这些步骤按顺序执行以执行一个阶段。steps 指令中必须至少有一个步骤。在下面的例子中，我在构建阶段实现了一个 echo 命令。该命令作为“构建”阶段的一部分执行。

[![Alt text of image](../Images/ca96ddaa9ae3911ad62e6b18757ba2d0.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--EcJedfdX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/six.png)

现在，您已经熟悉了基本的管道概念，让我们从 Jenkins 管道教程开始。首先，让我们学习如何创建一个 Jenkins 管道。

# [](#creating-your-first-jenkins-pipeline)创建您的第一条 Jenkins 管道。

第一步:登录 Jenkins，从仪表板中选择“新项目”。

[![Alt text of image](../Images/45b7fc0a466f24bc8e66a8eb21878d7b.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--qeUc10BA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/seven.png)

步骤 2:接下来，输入管道的名称，并选择“管道”项目。单击“确定”继续。

[![Alt text of image](../Images/3c99fb2679f757e76880657ae3bf62c0.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--nZnpcZY5--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/eight-768x283.png)

第 3 步:向下滚动到管道，选择您想要声明式管道还是脚本式管道。

[![Alt text of image](../Images/e2266eee104347b62d6d7f51e9af1d1b.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Qm1IQCpd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/nine-768x327.png)

步骤 4a:如果你想要一个脚本化的管道，那么选择“管道脚本”并开始输入你的代码。

[![Alt text of image](../Images/7a5b059c0981155399a7de75bf6d6426.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--oJTNko8e--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/ten-768x326.png)

步骤 4b:如果您想要一个声明性管道，则选择“来自 SCM 的管道脚本”,并选择您的 SCM。在我的例子中，我将在整个演示中使用 Git。输入您的存储库 URL。

[![Alt text of image](../Images/a72953559baf6abbe66bd342b71cc4f6.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--dXd-GL5J--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/eleven-768x283.png)

步骤 5:脚本路径中是 Jenkinsfile 的名称，将从您的 SCM 访问该文件以运行。最后，点击“应用”和“保存”。您已经成功创建了第一个 Jenkins 管道。

[![Alt text of image](../Images/0551bbee76d7df9515aff4666a8285c4.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--IVWxk9-K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/twelve-768x314.png)

# [](#declarative-pipeline-demo)声明式管道演示

演示的第一部分展示了声明性管道的工作方式。参考上面的“创建您的第一个 Jenkins 管道”开始。让我从解释我在 Jenkinsfile 中编写的代码开始演示。

因为这是一个声明性的管道，所以我在本地将代码写在一个名为‘Jenkins file’的文件中，然后将这个文件推送到我的全局 git 存储库中。在执行“声明性管道”演示时，将从我的 git 存储库中访问该文件。下面是构建管道以运行多个阶段的简单演示，每个阶段执行一个特定的任务。

-通过在管道块中编写代码来定义声明性管道。-在块中，我定义了一个标记为“any”的代理。这意味着管道在任何可用的执行器上运行。接下来，我创建了四个阶段，每个阶段执行一个简单的任务。
-第一阶段执行一个简单的 echo 命令，该命令在“步骤”块中指定。
——第二阶段执行一个输入指令。这个指令允许在一个阶段中提示用户输入。它显示一条消息并等待用户输入。如果输入被批准，那么该阶段将触发进一步的部署。
-在这个演示中，一个简单的输入信息“你想继续吗？”已显示。在接收到用户输入时，流水线要么继续执行，要么中止。

[![Alt text of image](../Images/48839e9bcfc595ced666c97de4f7bdd9.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--rkDa84g_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/thirteen-768x460.png)

-第三阶段运行带有“not”标记的“when”指令。此指令允许您根据“when”循环中定义的条件执行某个步骤。如果满足条件，将执行相应的阶段。必须在阶段级别定义它。在这个演示中，我使用了一个“not”标签。当嵌套条件为假时，该标签执行一个阶段。因此，当“分支为主”为假时，执行以下步骤中的 echo 命令。

[![Alt text of image](../Images/529bbac9bedf4c8530155059d135e08d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--o5cFt_ju--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/fourteen.png)

管道{
代理任何
阶段{
阶段('一'){
步骤{
echo '嗨，我是来自 edureka 的 Zulaikha '
}
}
阶段('二'){
步骤{
输入('要继续吗？')
}
}
stage('三'){
when {
not {
branch " master "
}
}
steps {
echo " Hello "
}
}
stage('四'){
parallel {
stage('单元测试'){
steps {
echo "运行单元测试..."
}
}
阶段('集成测试'){
agent {
docker {
reuseNode true
image ' Ubuntu '
}
}
步骤{
echo“运行集成测试...”
}
}
}
}
}
}

-第四阶段运行一个平行指令。该指令允许您并行运行嵌套阶段。在这里，我并行运行两个嵌套的阶段，即“单元测试”和“集成测试”。在集成测试阶段，我定义了一个特定于阶段的 docker 代理。该 docker 代理将执行“集成测试”阶段。
-舞台内有两个命令。reuseNode 是一个布尔值，当返回 true 时，docker 容器将在管道顶层指定的代理上运行，在这种情况下，在顶层指定的代理是“any ”,这意味着容器将在任何可用的节点上执行。默认情况下，该布尔值返回 false。
-使用并行指令时有一些限制:

一个阶段可以有一个并行或步骤块，但不能同时有两者

在一个并行指令中，不能嵌套另一个并行指令

如果阶段具有并行指令，则不能定义“代理”或“工具”指令

现在我已经解释了代码，让我们运行管道。下面的截图是管道的结果。在下图中，管道等待用户输入，单击“继续”，执行恢复。

[![Alt text of image](../Images/e9d48a5091ab85072c5bf6c7ae522811.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--3f7tE9Ft--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/fifteen.png)

[![Alt text of image](../Images/b9b04fbca44eaeee4f943431fcacd3fa.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--i8tyxop4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/sixteen-768x193.png)

# [](#scripted-pipeline-demo)脚本化管道演示

为了让您对脚本化管道有一个基本的了解，让我们执行一个简单的代码。请参考创建您的第一个 Jenkins 管道来创建脚本化管道。我将运行以下脚本。

[![Alt text of image](../Images/5f98ff37464d32037721e316d780f0aa.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--BQIduqeo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/new-new.png)

节点{
为(I = 0；一<2；i++){
Stage“Stage #”+I
打印 Hello，world！’
if(I = = 0)
{
git "[https://github.com/Zulaikha12/gitnew.git](https://github.com/Zulaikha12/gitnew.git)"
echo '在阶段#0 上运行'
}
else {
构建'声明管道'
echo '在阶段#1 上运行'
}
}
}

在上面的代码中，我定义了一个“节点”块，并在其中运行以下代码:

-条件“for”循环。该 for 循环用于创建 2 个阶段，即阶段#0 和阶段#1。一旦创建了阶段，它们就会打印“hello world！”消息
——接下来，我定义一个简单的‘if else’语句。如果‘I’的值等于零，那么阶段#0 将执行以下命令(git 和 echo)。“git”命令用于克隆指定的 git 目录，echo 命令只显示指定的消息
——当“I”不等于零时执行 else 语句。因此，阶段#1 将运行 else 块中的命令。“build”命令只是运行指定的作业，在这种情况下，它运行我们之前在演示中创建的“声明性管道”。一旦它完成了作业的执行，它就运行 echo 命令。

现在我已经解释了代码，让我们运行管道。以下屏幕截图是脚本化管道的结果。

**显示第 0 阶段的结果**

[![Alt text of image](../Images/bc8e0665bdeb25bf604788c5959bcfd7.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--d_L2eyrD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/eighteen-768x342.png)

**显示阶段#1 的日志，并开始构建‘声明性管道’**

[![Alt text of image](../Images/86c7716e8f616ba785d41c757bc72da0.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--oGCBp9eB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/nineteen-768x334.png)

**执行“声明性流水线”作业**

[![Alt text of image](../Images/6e4316d46ebe6b78891935fa3f66b4c9.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--lGJ9_9Bw--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/twenty-768x239.png)

**结果**

[![Alt text of image](../Images/e11ab4cb5b2e9d12e1a34065c7e26ece.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--DLynNRmK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1556540029/uploads/2018/07/twentyone-768x320.png)

我希望这篇博客能帮助你理解脚本化和声明式管道的基础。

来源: [Edureka](https://www.edureka.co/blog)