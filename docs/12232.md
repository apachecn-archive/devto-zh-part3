# 长期、敏捷的需求文档

> 原文:[https://dev . to/bertilmuth/long-term-agile-documentation-of-requirements-2nnh](https://dev.to/bertilmuth/long-term-agile-documentation-of-requirements-2nnh)

[![](../Images/b8f3a4a8531914a05ee1f548bf139a58.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--RMXwB_Iv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2AS60YI_RRtU2-tYeWIGg4NA.jpeg)

在我的培训课程中，我们讨论了许多话题，包括:如何在敏捷环境中记录长期的需求？

文档是存储的知识。随着事情被遗忘，文档的价值会随着时间的推移而增加。这就是为什么我认为长期文档的问题很有趣。

我想从在敏捷环境中没有意义的长期文档的两个选项开始。那么我想指出明智的选择。各有利弊。

#### [](#not-a-useful-option-detailed-upfront-specification)不是有用的选项:详细的预先说明

提前详细指定所有需求是没有意义的。在复杂的环境中，变化频繁。需求被重新划分优先级。这是敏捷开发的优势之一。考虑了一些需求，但从未实施。或者没有按计划进行，因为你在发展中获得了新的知识。

讨论和记录需求需要时间。如果需求没有按照文档实现，那就是浪费时间。发展中急需的时间。

#### [](#not-a-useful-option-either-the-backlog)也不是一个有用的选项:积压

假设你开始以敏捷的方式工作。也许你认为:没有任何详细的规范。而是积压。让我们用它来记录长期的需求。

但是积压服务于未来，而不是过去。这更像是一份待办事项清单。接下来我们实施什么？对于长期文档来说，积压不是一个明智的选择。它没有记录已经实现的内容。

#### [](#option-1-archive-user-stories-after-implementation)选项 1:实现后归档用户故事

在一次培训课程中，一位参与者告诉我，他的公司在 JIRA 管理用户故事。开发人员在实现后将它们归档。当然，你可以搜索这个档案。该参与者报告说，这对他们很有效。

一个敏捷的实用主义者很难不同意。有用的，有用的。至少在一定的背景下。

我认为这种方法有两个风险:

*   **太多细节:**为了能够长期使用这些故事，你当然必须记录许多细节。细节不能按计划实施怎么办？用户故事之后会调整吗？这些故事可能不再正确地记录实现。
*   **增量文档而不是系统文档:**用户故事描述需要做什么。从一个状态到另一个状态的“增量”。为了找出当前状态，可能需要分析几个过去的用户案例。故事缺乏上下文信息。它们不是系统文档，而只是小片段。

#### [](#option-2-incremental-adaption-of-the-system-documentation)选项 2:系统文件的增量适应

需求文档可以持续维护。

具体来说:在 Scrum 冲刺阶段，你记录当前的状态。刚刚实现的要求。文档会随着时间的推移而增长。它是递增补充的。

如果你坚持遵循这种方法，它有很大的优势。系统文档总是最新的。它记录了哪些需求实际上已经被实现。

这种选择的一个挑战是纪律。只有一致地记录，文档才会保持最新。这需要时间。

此外，并不是每个开发人员都是天生的文档作者。但是，如果开发人员不记录他们自己，而是委托给其他员工，那么就有信息丢失的风险。

在团队中推广这种纪律的一个方法是将它定义为完成。类似于“系统文档已更新”。在 Sprint Review 中检查。

#### [](#option-3-requirements-inside-the-code)选项 3:代码内的需求

一种完全被低估的长期文档是软件的代码。如果您适当地构造代码并使用命名约定，您可以从代码中生成文档。

为了简化，我已经开发了一个库。有了它，你可以在代码中指定可执行的用例模型。他们的行为[类似于一个国家机器](https://dev.to/bertilmuth/kissing-the-state-machine-goodbye-34n9)。

下面是一个信用卡用例的代码示例: