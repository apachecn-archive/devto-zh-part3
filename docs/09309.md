# PowerScheme 解释器

> 原文:[https://dev.to/naens/the-powerscheme-interpreter-46k9](https://dev.to/naens/the-powerscheme-interpreter-46k9)

[![alt text](../Images/94f0393bfe62db12b6e9963fe3ee231b.png "PowerScheme")T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Z7zAUwzI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/3pvnc6aag3xj6v17ey7l.png)

# [](#table-of-contents)目录

1.  [简介](#orgd7579bd)
    1.  [你好](#org15d8262)
    2.  [小片段口齿不清](#org48adc8a)
    3.  [重复](#org9f99bea)
    4.  [不同语言](#org046c284)
    5.  [关于 PowerShell](#orge3c788a)
    6.  [其他方案项目](#orga1b3de3)
    7.  [关于 Lisp](#org1e6c91b)
2.  [Lisp 和 Scheme](#orgb67babf)
    1.  [简介](#org871d40d)
    2.  [Lisp 简史](#orgeec54ca)
    3.  [方案简史](#orga8b253c)
    4.  [方案为一种语言编写口译员](#org8d256bd)
    5.  [方案属性和特征](#orgd5e6e91)
        1.  [解释/编译](#orgc7f0c08)
        2.  [语法:S 表达式，区分大小写，括号](#org0129870)
        3.  [类型:数据和函数](#orgf29bc3f)
        4.  [作用域:词法作用域](#orgd2a1f59)
        5.  [评价:热切的评价](#org0dff23a)
        6.  [垃圾收集](#org8264fdd)
    6.  [关于方案的更多信息](#org2b3b521)
3.  [关于 PowerShell](#orgfdd0515)
    1.  [简介](#orge63c38f)
    2.  [PowerShell 的历史](#org52dafc1)
        1.  【PowerShell 之前:Windows
        2.  【PowerShell 之前:UNIX
        3.  [PowerShell 的用途](#org3e12247)
        4.  [PowerShell 的时间线](#org1710db9)
    3.  [PowerShell 的特点](#orgfed5724)
        1.  [其他 shells 和编程语言的影响](#orga2bc134)
        2.  [类型](#org103f2e0)
        3.  [命令、功能和方法](#orgbab64fd)
        4.  [范围:动态范围](#org544a0a6)
    4.  [批评](#org82cdc8b)
    5.  [印象](#org50171bd)
4.  [特性](#orgba92615)
    1.  [符号和变量名不区分大小写](#org9ac70f4)
    2.  [同象性](#org4b3361f)
    3.  [类型系统](#orgd447b2f)
    4.  [词法范围和动态范围](#orgac85337)
        1.  [词法范围](#org2057e43)
        2.  [动态范围](#orge6f6b1c)
        3.  [关于词法和动态范围的结论](#orgc977ee1)
    5.  [一级函数和闭包](#orgdc316aa)
        1.  什么是一等公民？
        2.  [高阶函数](#org2bd6d36)
        3.  [匿名函数](#orgbb7c919)
        4.  [关闭](#org65f9726)
    6.  [尾音优化](#org2d1a4ad)
5.  [功能](#orga69bd0c)
    1.  [PowerScheme 是一个方案解释器](#org67ecbab)
        1.  [互动模式](#org0be5949)
        2.  [非交互模式](#orgfe02a07)
    2.  [power scheme 中的词法和动态范围](#orgff49e34)
    3.  [异常处理](#orga600ca2)
6.  [实施细节](#org1d9e685)
    1.  [代码的结构](#orgfcb3853)
    2.  [入口点](#org51d76d0)
    3.  [分词器](#orge6d6f85)
    4.  [袋子](#org3e4a907)
    5.  [解析器](#org14929dd)
    6.  [评价者](#orgbe5f85a)
        1.  [类型](#org9c2efb6)
        2.  [功能](#orge0db9fd)
        3.  [本地函数和 Thunks](#org353091c)
    7.  [环境](#org46bbbbe)
        1.  [词汇和动态环境](#orgbff7113)
        2.  [词法范围和动态范围的区别](#org4d6d863)
        3.  [尾部调用优化](#org3c539cb)
        4.  [环境表现](#orgc98fb63)
        5.  [分支堆栈](#org4de7a5c)
        6.  [定义-定义](#org935c8df)
        7.  [全局和局部数组](#org7ccf692)
        8.  [声明和更新词法和动态变量](#orgd0d76a5)
    8.  [关于实施细节的结论](#org459a244)
7.  【PowerScheme 还能做什么
    1.  [一辆 REPL](#org6e552d5)
    2.  [Y 组合子](#org0952fb5)
    3.  [功能对象](#org490cb0a)
8.  [缺什么？](#orgf66757c)
    1.  [矢量](#org6827570)
    2.  [让*](#orga574e9d)
    3.  [Caar 等等](#orgc444199)
    4.  [Set-car！和 Set-cdr！](#org954a996)
    5.  [延续](#orgb96da6d)
    6.  [异常情况](#orgf73afea)
    7.  [宏](#orge7ffb1c)
9.  [结论](#org3ab34b2)
10.  [参考书目](#org3ab34b3)

# [](#introduction)简介

## [](#hello)您好

你好。在这篇文章中，我想描述一下我用 PowerShell 编程语言编写的 Scheme 解释器。谈到 Lisp 和一般的编程，我仍然是一个初学者，所以我
决定写一个简单的解释器。

这个程序是开源的，每个人都可以用它做任何事情。所以这里是链接:
【https://github.com/naens/scheme-lisp/tree/master/chap02pwsh】T2。
授权它 GNU GPL v3.0。当然，没有人会想买它或将
用于关键应用，所以它只是为了好玩。

## [](#lisp-in-small-pieces)口齿不清的小棋子

我是在跟随克里斯蒂安·奎因内克写的《小片段的 Lisp》<sup id="520a1805e2957b91051e499a55918b81">[奎因内克 _lisp](#queinnec_lisp "Queinnec, Lisp in {Small} {Pieces}, ().")</sup> (常缩写为
LiSP)这本书。它展示了 Scheme 和 Lisp 在
general 中是如何工作的，以及如何编写不同种类的 Scheme 解释器
和编译器。

## [](#repetition)重复

在这本书的第十四页，作者说“好的教学需要一定量的重复”。所以在
中，为了避免欺骗，我不得不像作者
一样多次实现 Scheme。

## [](#different-languages)不同的语言

因为我想尽可能地避免作弊，简单地将解释器重写几次显然是不够的。随着时间的推移，看起来一切都是一样的，我会记住
变量、文件、事情是如何实现的等等。为了避免这个问题，我决定让
第一次体验到
的解释器或编译器的实现。有办法做到这一点吗？当然了。解决方案
是用不同的语言实现每个解释器和编译器。这就是为什么我为第一章写的解释器在 Kotlin 中。我从来没有用 Kotlin 写过任何东西，更不用说是一个
Scheme 解释器了！同时，这也是
学习一门新的编程语言和一个新的开发环境的好机会(我
使用了 Intellij IDEA，这对我来说并不是全新的，因为我
以前在 Java 中使用过它，但在 Kotlin 中它绝对是全新的)。

我刚刚读完这本书的第二章，是关于不同的环境。主要讲了功能环境和动态环境。

有趣的是，简单地通过
为函数添加一个单独的名称空间，一切变得复杂了许多，唯一的优势
是它提高了性能。

## [](#about-powershell)关于 PowerShell

所以，这第二章我决定在 PowerShell 中完成。有趣的是，它试图填补 shells 和编程语言之间的空白。我要说，结果是
更接近后者。它还试图解决 UNIX shells 中存在的问题，如字符串困难、管道、
,后者是纯文本的，使程序相互依赖。此外，它允许
使用算术表达式，这在许多早期的
shell 中是一个问题。

因为 PowerShell 可以在 Linux 上使用，而且现在很稳定，我
决定这是一个学习对我来说完全新的东西的好机会，而且在其他主流
语言中没有类似的东西。

最后，PowerShell 似乎是一种很好的编程语言，而且
有很多特性使得用它编写 Scheme 解释器
非常容易。它有所有需要的库和数据结构
，它不需要程序员释放所有使用的内存，
，在我看来，它实际上很快。我没有将它与
其他编程语言进行比较，但是对于一个解释
的解释器来说，速度是惊人的。

## [](#other-scheme-projects)其他方案项目

在我完成这个项目后，出于明显的原因，我决定调用 PowerScheme，我将继续用其他语言编写解释器，我知道完全有可能不用用同一种语言编写两次就能写出所有的解释器
。我想我会尽量避免一些需要大量努力才能掌握的语言。我
考虑像 APL、Malbolge、Haskell 和类似的语言。但是
几乎可以肯定我会在某个
点使用 Prolog，Assembly，PL/M。

## [](#about-lisp)关于 Lisp

所以这个程序是 Scheme 的一个实现，Scheme 是 Lisp 家族的一种编程语言
。Lisp 的第一个实现是解释器，后来也编写了编译器。Lisp 有一个
非常丰富的历史，主要是因为它一直是人们可以试验的
语言。据说语言是
同形异义的，这意味着数据的内部表示
与其词汇表示相匹配。这使得将语言作为数据来操作变得容易。由于这个原因，很多东西，像代码生成器和宏都可以很容易地用 Lisp 编写。

由于这种丰富性，Lisp 历史上曾经存在的所有东西中只有一小部分需要实现。另一方面，你可以决定实现任何你想做的事情。举个
的例子，如果你发现某个地方
存在某个编程语言(不一定是 Lisp)的某个晦涩的老特性，你可以
实现它。

在我情况下，这样的特征是动态变量。在这本书之后，我
实现了词法和动态环境，但是我决定
让它不像书中那样。所以用户可以选择
声明变量是词法变量还是动态变量。我的实现，在我看来
，更接近于 Common Lisp，但是我会在后面的
功能部分讲述更多。

还有一些我没有实现的特性。比如
vectors，在 Lisp 中其实并不需要。只需要它们来使某些操作更快，但是它们所做的一切都可以通过使用列表来完成
。

我没有实现的另一件事是延续。我认为
的实现很重要，但是当我实现了整个
语言并考虑如何添加延续的时候，我明白了
的意思，很多东西必须重写。这意味着，第一，这次没有
延续，第二，如果你想用你的
语言延续，你应该提前考虑如何实现它们，最好在
开始写代码之前。将有一小部分是关于
延续的，但是我将在
写一个解释器的时候更详细地描述它们，在那里它们将被实际实现。

顺便说一下，我没有发一个类似于这个的关于我用 Kotlin 写的第一个
解释器的帖子，因为它真的很简单和基本。此外，我还没有想法写一个关于我为这本书写的每个翻译的
帖子。回到
时间，试着写一篇文章，就好像我刚刚写的一样
似乎也不对。

# [](#lisp-and-scheme)Lisp 和 Scheme

## [T1】简介](#intro)

这个解释器 PowerScheme 解释的语言是
Scheme。Scheme 是一种诞生于 Lisp 的编程语言。可以说 Scheme 是 Lisp 的一种方言，因为它延续了 Lisp 的
传统，并且与 Lisp 家族的其他语言
有很多共同的特征，但同时，Scheme 与其他 Lisp 有一点点不同
。Scheme 的创建者并不真正关心现有的 Lisp 程序是否能适应 Scheme。他们
还决定放弃许多在某个时候
引入的功能，但在实践中并不真正有用。实际上，Scheme
通常被认为是一种非常紧凑的语言，具有简短的
规范。因此，他们没有创造复杂但对实际任务有用的东西，而是创造了一种从理论角度看起来更好、更适合探索理论概念的语言。

Scheme 被认为是一种函数式编程语言，尽管函数式编程语言的概念已经随着时间的推移而发展。起初，这仅仅意味着这种语言可以操纵
功能。当
Scheme 在 1975 年发布时，这个概念似乎获得了现代意义，所以 Scheme 是现代意义上的第一个函数式
编程语言之一。今天成为
功能意味着关注不变性，避免副作用、跳转、
和循环。

## Lisp 简史

所以，Scheme 是 Lisp 编程语言家族的后代。它继承了它的几个特点。例如，
语法，它的许多关键字的名称和含义都来自于
Lisp。

Lisp 是最早创建的编程语言之一。至少它是第一种成功的编程语言，它不是现有硬件的抽象，因为它是基于理论的，如逻辑和λ演算的 T2。

Lisp 出现在 1958 年。从那时起，只有一种语言仍然存在，那就是 FORTRAN。因为它起源于逻辑，Lisp 帮助
定义了几个编程概念，这些概念最初是
在 Lisp 中引入的。这些包括，例如，闭包、宏和匿名的
函数，以及作为一般数据的函数操作。

随着时间的推移，Lisp 中已经存在的许多思想被融入到其他语言家族中。有趣的是，
许多语言仍然基于 20 世纪 60 年代
已经存在的思想。例如，有人将 Go 编程语言
与 Algol 1968<sup id="216a89084fe47ba313861b0a64a9dbd7">[given _ re:_ 2009](#given_re:_2009 "@misc{given_re:_2009,<br>
    title = {Re: {Coroutines} and {Go}},<br>
    url = {http://lua-users.org/lists/lua-l/2009-11/msg00576.html},<br>
    urldate = {2019-03-24},<br>
    author = {Given, David},<br>
    month = nov,<br>
    year = {2009},<br>
    keywords = {compilers},<br>
    file = {Re\: Coroutines and Go:/home/andrei/Zotero/storage/VABJLNNL/msg00576.html:text/html}<br>
}")</sup>进行了比较，似乎 Go 并没有带来任何新的东西。因此，可以说从 20 世纪 70 年代开始以来,
编程语言的发展仅仅是,
在此之前已经存在的思想的重新组合，并且在这里,
越来越多来自 Lisp 的思想被合并。

## [](#short-history-of-scheme)方案简史

Scheme 出现于 1975 年，试图通过删除所有不需要的东西，将 Lisp 中所有好的东西与 Algol 中的词法范围结合起来。

Scheme 取得了很大的成功，因为它可以用来教授编程概念。多年来，在许多大学里，它被用作编程入门的语言。之所以称之为
是因为它作为一种语言的优势，在这种语言中，机器比其他语言更少
(毕竟 Algol
家族的许多语言，如 C 或 Pascal，只是机器语言的抽象
)。因此，它有助于专注于算法和理论上的
概念，而无需解释指针或
二进制补码整数如何工作的细节。

今天，Scheme 有几种实现方式。最重要的是 Guile(用于 GNU 项目)、rack(Scheme 最流行的实现之一)和 Chicken。

Scheme 如今有了一个标准，在所谓的
*修订版 <sup>n</sup> 报告中定义了算法语言 Scheme* (RnRS)，因此遵循它的
实现大部分是相互兼容的。

## [](#scheme-as-a-language-to-write-interpreters-for)Scheme 作为一种语言来编写解释程序

编写方案解释器是一项流行的练习。在许多语言中存在许多
实现。这一传统始于 Lisp 的第一个
年，当 Lisp 的第一个规范的作者约翰
麦卡锡认为用 Lisp<sup id="3beab3c5c207c3c1ab618cbd0a12a0a8">T5】编写一个 Lisp 的
解释器并不困难。后来 Lisp 变得越来越复杂，功能越来越丰富，所以容易重新实现的东西变得越来越不像实际的 Lisp。</sup>

Scheme 的目标之一就是回归这种简单性，所以这就是 Scheme 成为编写解释器的流行编程语言的原因。

## [](#scheme-properties-and-features)方案属性和特性

### [](#interpreted-compiled)解释/编译

当 Lisp 第一次出现时，它首先是一种解释型语言。但是后来人们开始为 Lisp 编写编译器。因为 Lisp 可以在执行过程中
生成新代码，然后执行它，所以代码也可以在执行过程中
被解释。所以程序
的一部分被编译，另一部分被解释。

Scheme 也经常是编译的，而不是纯粹的解释。通常 Lisps 不是直接编译成机器语言，而是编译成特定的字节码。球拍和 Guile 使用字节码，小鸡
编译成 C，所以可以生成二进制机器码可执行文件。

### [](#syntax-sexpressions-casesensitiveness-parentheses)语法:S 表达式，区分大小写，括号

Scheme 的语法是基于 s 表达式的，就像大多数其他的
lisp 一样。它延续了
a `cons`的`car`和`cdr`访问器的传统，并且与其他 Lisps 有许多共同的关键字，例如
`lambda`、`let`和`cond`。

方案可以区分大小写，也可以不区分大小写。我更喜欢让
不区分大小写，因为我用了很多普通的 Lisp，我认为`IF`和
`LAMBDA`不应该与`if`和`lambda`有不同的解释。Scheme 最初也是不区分大小写的。但是后来发布了一个标准
(R6RS，2007 年发布)，其中规定
区分大小写。在许多实现中，可以选择启用或禁用
。

### [](#types-data-and-functions)类型:数据和函数

Scheme 是一种动态的强类型语言，这意味着
即使类型不是静态地为所有东西指定的，
它们在执行期间就在那里，并且一个值不能在执行期间突然被
解释为其他东西(与 C 相反，在 C 语言中
将一个字符串作为一个整数读取，将一个浮点数作为一个指针读取
，以及类似的事情是可能的并且完全正常的)。

Scheme(以及其他 Lisps)的一个有趣的特性是，它
可以用它们的执行环境实例化函数。因此，根据评估的环境，评估两次的
函数值可以给出两个不同的函数
。这使得
让函数保存数据并充当对象成为可能。

### [](#scope-lexical-scope)范围:词法范围

Scheme 和当今大多数编程语言一样，使用词法范围。对于一个 Lisp 来说，当它是一个词法作用域时，代码通常可读性更好，因为很容易看出变量的哪个实例引用了什么。Lisp 之所以这样，是因为传统上
函数式语言通常是以声明方式读取的。所以不模拟执行就能说出程序做了什么应该是
可能的。
这就是声明式编程的原理。动态范围根据它自己的定义与它背道而驰:它是变量，在这个
执行过程中，它碰巧被绑定到符号上。因此，对于一个 Lisp 来说，
将自己定位在更接近函数式编程风格的位置，
词法范围要自然得多。

### [](#evaluation-eager-evaluation)评价:热切的评价

Scheme 使用热切评估。这意味着在一个函数被调用之前，它的所有参数都必须被评估。在一些编程语言中，情况并非如此，这被称为懒惰求值。
正常情况下，对于纯函数式语言，惰性求值和急切的
求值应该返回相同的值，除非
求值是不可能的。在这些情况下，惰性求值有更高的
机会返回值，因为如果
不需要，有些东西就不会被求值。但是由于惰性求值更难实现并且通常更慢，所以它不经常在编程语言中使用。

像许多其他语言一样，Scheme 有一些行为类似于惰性求值的
方式的构造。这些是特殊的形式`if`、`and`、
、`or`、`case`和`cond`。它们可以在
特定条件下停止评估，并在评估所有
参数之前返回值。

### [](#garbage-collection)垃圾收集

像 Lisp 家族的大多数语言一样，Scheme 通常使用一个
垃圾收集器。原因是它创建了大量的`cons`
结构，即使不再使用
也将它们留在内存中。为了不耗尽可用内存和不使用多余的
，Scheme 使用了垃圾收集器并将这些未使用的结构返回到可用内存中以备后用。

## [](#more-about-scheme)更多关于方案

最后，写完这个解释器后，我明白了为什么很多人更喜欢 Scheme 而不是 Common Lisp。常见的 Lisp，做 Lisp2 是个
问题。它有一些丑陋的特征，来自于这样一个事实
，在求值过程中，一个列表的第一个位置有一个
不同的求值器，函数求值器。因此，它必须有
函数包装，以便通过使用它们作为数据。就不那么
干净了。我认为很不幸的是，他们决定让它成为一个
标准，而不是让它像 Scheme 一样，后者要干净得多。但是
方案依然强大。每年仍然有很多人学习它并为它编写翻译，尽管它在教育中的使用比以前少了。

# [](#about-powershell)关于 PowerShell

## [](#introduction)简介

作为编程语言，对于这个项目，我决定使用 PowerShell。
它是一个为 Windows 编写的现代 shell，有一些有趣的
特性。许多人说这是一种很好的编程语言，所以我
决定使用它一次，以便了解更多。

现在它可以在 Windows 和 Linux 上运行，这是我的主要操作系统，
并且安装起来非常容易。源代码发布的时候
还不是很稳定(我试着把它安装在 Arch Linux 上，但是
不工作)。现在安装很容易，它不需要
安装额外的包、插件、库和
等等。

PowerShell 的主要应用领域是在
Windows 机器上的管理，它的一些特性反映了这一点。例如，
的语法类似于 UNIX shell 和 C#，以便
熟悉 UNIX 和。NET 开发人员。它可以与操作系统的组件和 API 交互，这使它成为一个
有用的工具。

## PowerShell 历史

### PowerShell 之前:Windows

对 PowerShell 之类的东西的需求在 Windows 的早期就存在了，当时它已经变得足够复杂，可以用于日常使用，所以许多管理任务需要自动化。

PowerShell 之前还有另一个命令行 Shell 存在，`cmd.exe`。但是 T2 也有自己的问题。首先，它不是用 Windows
写的，因为它只不过是对 MS-DOS 上的
`COMMAND.COM`外壳的改编。所以，当然它可以
完成某些事情，但是它的功能仍然停留在 MS-DOS
的水平上，没有做任何事情使它在
Windows 上特别有用。

所以，这里有一些`cmd.exe`的问题的例子。首先
它的前身`COMMAND.COM`出现的时候就已经
过时了。它什么都用`GOTO`，没有功能。
`cmd.exe`试图改善情况，但仍然有限。

为什么`cmd.exe`对编程
来说如此不舒服，以及它是这样的一个解释是，它最初主要是为了
执行`.BAT`文件，这些文件应该是命令列表，而
不是真正的程序。然后需要引入一些额外的特性
，同时保持向后兼容性。这使得
它变得如此，随着时间的推移，它变得不可能改进，而且
仍然保持着从 MS-DOS 时代以来的样子，几乎没有变化。

### PowerShell 之前:UNIX

在 UNIX 世界中，情况稍微好一些。自从 1977 年引入 Bourne shell 以来，UNIX 有了一个强大的脚本环境，其中有循环、条件表达式、函数和 T2 变量。

通过将外壳的功能与操作系统的多任务处理能力结合起来，并通过使用外部程序，编写相对复杂的程序是可能的。

到 Windows 出现的时候，UNIX shell 已经进化，变得更加容易使用，并且有了更多的特性。Korn Shell 出现了，与最初的 Bourne Shell 相比,
在可用性方面有了很大的改进。

不幸的是，它有自己的问题，即使是在自己的操作系统上。它只能操作文本，而做
事情的通常方式是通过过滤从外部程序的
标准输出中提取特定的子字符串。这使得脚本和
程序相互依赖。在不破坏脚本的情况下，程序不容易被修改
。因此，一个程序不能被改进，一个
字段不能容易地从输出中添加或删除。我认为
这就是导致 POSIX 规范的原因，这样脚本编写者
就可以确信某个程序的输出在未来
不会改变。

在 Windows 平台上，问题甚至更大。管理任务有 GUI 程序
<sup id="220428e48f1fa84778351fd1ac9437e5">[Jones _ learn _ 2017](#jones_learn_2017 "Jones \& Hicks, Learn {Windows} {PowerShell} in a month of lunches, Manning (2017).")</sup>不是一件平常的事情。这通常是通过使用库和
API 来完成的。有人试图使用 UNIX shells。例如，
已知有一个 Korn Shell 端口，但最终这并不能解决问题。

### PowerShell 的用途

因此，我们决定 Windows 需要一个新的脚本环境，
，它既不同于`cmd.exe`，也不同于 UNIX shells。

借鉴了其他不同 shell 的经验，新 shell 的目标
是给 Windows 一些真正的脚本
功能。因此，新的脚本语言被认为是 T2，是 Windows 函数和库数据类型以及 API 的接口。

PowerShell 的制作方式反映了它的目的:它可以访问操作系统组件，它支持对象，这也使操作系统更容易工作，因为. NET 使用 C#，一种面向对象的语言
。

它试图改进的另一件事是试图摆脱基于文本的模式。当然，作为一个 shell，很多东西仍然是文本，
比如命令行参数、标准输入和
标准输出。但是，它尽可能地尝试处理
对象。一个有趣的例子是管道。通过管道将对象
从一个程序传递到另一个程序，避免了解析来自管道的
输入的需要。

### PowerShell 的时间线

Powershell 的历史始于 2002 年，有所谓的 Monad
Manifesto<sup id="456b887553631891bf21f8255f316cf5">[【the _ devo PS _ collective _ Monad _ 2016](#the_devops_collective_monad_2016 "The DevOps Collective, The {Monad} {Manifesto}, {Annotated}, Leanpub (2016).")</sup>，一段文字描述了 Windows
操作系统需要一个新的 shell，它应该有什么特性，以及应该避免哪些错误
。

第一个版本 PowerShell 1.0 是针对 Windows Vista 的。然后它仍然是可选的。它在 2008 年成为操作系统的一部分，包含在 Windows 7 中。

2016 年开源，2018 年在 Linux 上使用
PowerShell 成为可能。目前还不清楚他们为什么开放源代码，可能是因为他们想吸引新用户，或者向 T2 展示他们的软件是以一种可以轻松移植的方式编写的，或者如果他们想将 Windows 切换到 Linux 内核，他们可以确保有足够多的人尝试过，在不同的内核上不会有太大的问题。

对我来说，这是一个很好的机会去尝试一些我不会尝试的事情，因为我在 Linux 上工作，仅仅为了尝试一种
编程语言而在虚拟机或真机上安装 Windows 是不值得的。我喜欢编程语言设计师尝试新的或不同的方法，所以当我
听说它可以在 Linux 上工作时，我就想尝试一下。

## PowerShell 的特点

### [](#influences-of-other-shells-and-programming-languages)其他 shells 和编程语言的影响

PowerShell 受到了在它之前出现的几种编程语言的影响。首先是 UNIX shells，即 Bourne shell 和 Korn
shell。

它从它们那里借用了变量的语法，这些变量必须以带有符号`$`的
为前缀。为了使其更加一致，每次使用变量时都必须加上前缀
，这与
示例中的 *zsh* 相反，它试图让用户尽可能避免使用`$`
。

另一个影响是 Perl。Perl 被认为是一种基于 Unix shell 语法的编程语言
,但是它的目标
是作为一种真正的编程语言使用，因此，它使得
更容易使用。其主要特点是正则表达式匹配和
替换。例如，它可以在一个
`if`中使用布尔匹配测试，这是非常有价值的。这是 PowerShell 也可以做的事情，
同时仍然保留在 Shell 的领域中。

第三个影响是 C#。作者知道很多 Windows
用户使用 C#，所以他们从 C#
借用了一些语法元素(例如，类和数组)。

### [](#types)类型

关于类型，我认为 PowerShell 比其他 Shell 更严格。这不是一件坏事。主要规则是
当进行转换时，不应丢失任何数据(除了涉及
浮点时)。

这使得编程更容易。当检查数据类型时，如果
有错误的类型，则不会强制转换，并报告一个
错误。另一个好处是，
拥有一个包含对象或数组的数组变得更加容易。或者是一个
包含数组的对象。在一些语言中，比如在 UNIX shell 中，如果你想做类似的事情，那么
就变得非常复杂。

关于类型的另一个有趣的特性是对
对象的支持。尽管 PowerShell 并不完全是面向对象的语言(作者称之为基于对象的 T2 语言)，拥有对象 T4 确实有助于使程序更加结构化。它们就像是
结构，可以有一些函数，叫做附在
上的方法。

对对象的支持是 PowerShell 的一个重要特性。首先，
它允许与操作系统交互。Windows 的很大一部分都有面向对象的界面。所以为了与
交互，拥有对象意味着 PowerShell
和操作系统之间的转换很容易。第二，将对象与使用管道的
结合起来，使得使用管道将数据从一个程序传递到另一个
程序变得容易。

### [](#commands-functions-and-methods)命令、功能和方法

PowerShell 有两种可以被“调用”的东西:
命令和方法。命令是独立的，方法是类的一部分，在对象上被调用。

有四种命令。第一个叫做 *cmdlet* ，其中
读作“command-let”。它是一个编译成
的函数。NET 类并内置。它是命令
中最快的，因为它是编译过的。我认为这是一个有趣的功能。极少数
shell 允许扩展内置命令集。

它有一个特殊的命名约定，`<Verb>-<Name>`，即动词
后面跟一个名字，两者都以大写字母开头，并用破折号隔开
。

第二种命令是函数。它们是用户定义的
函数，出现在 PowerShell 脚本中。

第三种命令是脚本命令。当一个完整的脚本被当作一个函数时。这类似于 bash:你可以用参数调用一个
文件，这个文件将接收用户
给出的参数。就好像整个脚本是一个大函数。

第四种命令是本地命令。这些文件
与 PowerShell 完全无关，但碰巧可以在
操作系统上执行，因此可以让 PowerShell 请求
操作系统执行它们。这也是 UNIX 和
Linux 用户都知道的一个概念:它对应于调用外部二进制文件，比如
`cat`或`mknod`。

### [](#scope-dynamic-scope)范围:动态范围

从作用域的角度来看，PowerShell 延续了动态作用域 Shell 的传统
。作者说他们考虑了
不同的策略，但还是选择让它动态地限定范围。
为什么处理与系统相关的事情的语言经常被动态限定范围，这应该是有原因的。

以下是动态范围语言的一些其他示例:

1.  UNIX shells。

    UNIX shells、bash、ksh、zsh)被动态地限定范围，以使调用外部程序和函数时保持一致。当一个
    外部流程被创建时，它接收一个
    环境的副本(或 COW)。当它结束时，它所做的对调用它的
    进程没有影响。这就是动态范围的原理。

2.  Emacs Lisp。

    Emacs Lisp 的作用域是动态的，这并不是因为作者懒惰或者不知道如何实现词法作用域。在面向系统的
    编程的上下文中，
    决策是有意义的，因为 Emacs 有点像
    操作系统的仿真器，所以让它动态地限定范围是有意义的。动态作用域的
    优势在于可以在调用函数之前设置
    环境，并在
    退出当前函数之后禁用更改。

3.  常见的口齿不清。

    Common Lisp 允许创建词汇范围的变量和动态范围的变量。这是一个非常有趣的例子，
    因为公共 Lisp 规范的作者之一是第一个完全词汇化的 Lisp Scheme 的作者
    。这个
    意味着它已经被承认，词法范围并不总是最好的
    ，也不是所有人的解决方案。除此之外，用编译过的语言实现
    动态范围并不容易，因为
    变量必须通过名字来查找。在动态作用域中，我们
    并不真正知道变量名背后是什么，只有在执行过程中
    才知道。这就是它被称为动态范围的原因。

    我决定在这里给出这些例子，因为在我看来，所有这些例子都可以在 PowerShell 中应用。它也允许调用
    外部程序，用于操作系统。看起来
    这样做是正确的，为了避免给函数传递太多的
    参数。

## [](#criticism)批评

PowerShell 有些地方并不是每个人都喜欢的。因为
是经常发生的情况，编程语言设计者不得不做出
的选择，例如，不可能以相同的方式表示字符串和
变量。一些语言，如 C 或 Lisp 更喜欢用
来表示没有特殊指示的变量和引号内的字符串
。其他语言，主要是脚本语言使
反过来，所以它们必须标记不同的变量，例如
，通过在它们前面加上前缀`$`。

对于第一次看到 PowerShell 的
的人来说，奇怪的事情之一是，用于数字比较和逻辑运算的运算符
不是符号，而是以`-`为前缀的单词，如`-gt`、
、`-and`等等。原因是普通符号
与其他操作冲突，比如代表
输出重定向的`>`，PowerShell 作者希望保留它们。

命令和
方法调用的语法不一致。调用命令时不带括号，参数
用空格分隔。另一方面，方法必须有
括号，并且里面的参数用逗号分隔。由于某些原因，作者不能保持所有病例的一致性。

## [](#impressions)观感

总的来说，我认为对于简单的任务来说这是一个不错的环境，这正是操作系统管理应该有的环境。我会说它
甚至太强大了。管理员真的需要用模块类等等创建复杂的
数据结构吗？但是对于编程
来说，测试简单的算法是可以的，因为类型足够强大
，所以很容易建立层次结构，而不用担心对象会以某种方式丢失或合并。

# [](#features)特性

## [](#caseinsensitivity-of-symbols-and-variable-names)符号和变量名不区分大小写

我的 Scheme 实现是不区分大小写的。我知道这不是现代编程语言中常见的
，甚至 Scheme
也变成了区分大小写。但是我还是决定让
不区分大小写。

当你用 Common Lisp 编写时，解释器，当它在 REPL 中显示
变量和函数时，它用大写字母显示它们，
尽管在代码中是小写字母。这是传统，而且一直保持着。这就是为什么当你熟悉普通的
Lisp 时，你经常会看到大写的关键词`LET`、
、`IF`、`LAMBDA`、`COND`。

当我切换到 Racket 时，这是 Scheme 的一个实现，它
并不是一个真正的问题，因为我总是以小写字母
键入这些关键字。

但是我真正不想要的是像`LAMBDA`和`IF`这样的词被
认为是与`lambda`和`if`不同的东西。使用 Common Lisp 的
程序员，至少是 CLISP 和 SBCL 已经被
训练成认为它们是同一个东西。这就是为什么它应该保持这种方式。这是一种习惯。

我认为根据这个案例改变单词的意思是不自然的。为什么有人会给一个变量取相同的名字，唯一的区别就是
?如果你想让它们不同，就给
取不同的名字。如今，人们已经认识到名字越长，程序越容易阅读。通过观察两个变量的口头
表述，你必须能够说出它们之间的
差异。如果唯一的区别是这样，那么你必须记住为什么不同。这要么是惯例(就像
常量必须是大写的)，要么只是随机的(为什么不给这个
变量一个大写的名字呢？).无论哪种方式，用一个更好的命名约定都是可以避免的。这就是为什么我认为区分大小写是一种倒退。

也许他们想支持不同的语言？那也是一个坏主意。字符可能看起来一样，但同时，它们可能
有不同的 Unicode 码位。这不是个好主意。总之，
在 Scheme 中很难找到区分大小写的符号和
变量名的正当理由。这就是为什么我的实现是
不区分大小写的。Scheme 的早期版本也是如此。

## [](#homoiconicity)同象性

Scheme 的这个实现，就像大多数 Lisps 和所有 Scheme 的情况一样，是同形的。这意味着源代码和程序在
内存<sup id="5d71417e23001a0ba429f599b4580b67">[wiki C2 _ homo iconic](#wikic2_homoiconic "@misc{wikic2_homoiconic,<br>
    title = {Homoiconic {Languages}},<br>
    url = {http://wiki.c2.com/?HomoiconicLanguages},<br>
    urldate = {2019-03-09},<br>
    keywords = {lisp},<br>
    file = {Homoiconic Languages:/home/andrei/Zotero/storage/74J3PNGR/wiki.c2.com.html:text/html}<br>
}")</sup>中的表示有对应关系
。也就是说，源代码是
AST 的一种形式，解释器将使用这种结构来执行
程序。

这使得在屏幕上打印程序变得非常容易，这在许多其他语言中是不可能的:当一种语言被编译时，结构就丢失了，而且有了解释器，在许多情况下它可能会被恢复，但是也有一些丢失。

Lisp 的一个很好的例子是，您可以通过
构建列表然后评估它们来生成函数。如果列表
构建正确，函数将被正确评估。

Lisp 不是唯一一种同形异义的语言。例如，Prolog 和 Tcl 也是同形异义的。

除了生成源代码和函数，同象性对于
宏来说也很方便，这可以被认为是在列表中使用
`eval`的一种稍微结构化的方式。从语法上讲，宏类似于函数，
的主要区别在于宏的参数在调用前不被求值
。由宏决定如何评估它们
以及是否必须评估它们。例如，
它可以探索它们的结构。这就是为什么有可能使用宏来为
编写一个不同的`define`，这会做一些不同的事情。

在我的 Scheme 版本中，没有实现宏。不是因为它们
很难实现(实际上它们比
函数更容易实现，因为你不需要计算参数)。
的主要原因是因为它们的行为很复杂，这更多的是一个
常见的 Lisp 特性而不是方案。但是由于我的
解释器的语法尽量接近 Scheme，所以很难
测试行为是否正确。也许在以后的
解释器中我会实现它们。

## [](#type-system)类型系统

我的 Scheme 实现，就像其他 Scheme
实现和大多数 Lisp 一般情况一样，是动态的和
强类型的。

动态类型化意味着在运行时检查类型。这给了
更多的灵活性。一个变量可以在不同的时间包含不同类型的值。例如，一个函数可以被不同类型的
调用，并且仍然工作，这使得 Lisp 非常适合
多态性。一个函数可以被传递，例如，一个任何类型的值列表
和一个可以比较它们的函数，这足以
实现一个排序算法，该算法可以处理包含
任何类型的列表。

与 Java 相比，这种类型的系统非常容易使用并且非常简单。而 Java 需要类、类型、接口和方法之间非常复杂的交互
来实现
类似的功能。正如我的实现中所示，它真的很容易实现。

另一个优点是变量不需要用
类型声明。该类型是动态分配和维护的。另一方面，
变量需要显式声明，这使得【Lisp 比其他几种语言更加严格。

Lisp 的一些实现，比如 Common Lisp，要求
明确提到没有使用声明变量的情况。我认为这是一个有趣的想法。在《铁锈》和《T2》的序言中也是如此。但是作为 Common Lisp 的
规范的几种倾向之间的折衷，它并不十分一致:仍然有一种
方法可以拥有可选的函数参数，在调用没有这些参数的
函数的情况下，它可以拥有一个由用户指定的
默认值。

Lisp 不仅仅是一种动态类型语言，它还是一种具有强类型的动态
类型语言。这意味着每次使用
值时都会检查其类型。不同的操作需要
不同的类型。例如，算术运算需要数字
并且不能处理其他任何东西，而`car`和`cdr`只能处理
的 conses，如果你试图将它们用于
其他类型的变量，就会产生错误。这与我们在
JavaScript 中看到的相反，似乎已经认识到这是一个设计
错误。我们看到，当语言本身
帮助开发人员编写更严格的代码时，这并不是一件坏事，就像我们在
Prolog、Rust 和 Common Lisp 中看到的那样，其中不允许使用未使用的变量。

有时 Lisp 被描述为弱类型。这个
的原因是强类型和弱类型的概念没有精确定义。例如，在 1974 年，Liskov 和 Zilles 认为如果一个函数只接受授权类型，那么语言
就是强类型的。
现在 Lisp 被称为强类型，因为即使它只在
运行时，类型总是被检查，未经授权的类型是不允许的
。

另一个让 Lisp 的类型系统不那么强大的原因是
有几个类型是基于 conses 的。Conses 类似于
原语块，允许构建任何数据结构。它可以是一个
列表或者一棵树或者程序员认为的任何东西。但是对于
编译器或解释器来说，它们看起来都是一样的:只是一个 cons，带有一个
`car`值和一个`cdr`值，它们本身可以保存任何可能的
值。

现在情况稍微好一点。在 Lisp
的现代实现中，用户被允许定义类型。它们通常是对象或
记录，可以在运行时检查其类型，所以
可以将复杂的数据结构如自定义列表或树嵌入到这些
类型中，所以现在，并不是每个复杂的数据结构都是`cons`。

在我的实现中，为了保持一切简单和愚蠢，
没有记录或对象这样的东西。链接数据结构的唯一方法是使用 conses。所以我的方案不是很强烈的
式的。

## [](#lexical-scope-and-dynamic-scope)词法范围和动态范围

许多编程语言都有变量的概念。变量
通常是代表一个值的东西，由
名称引用。这意味着，编程语言的职责之一是对名字的
管理。变量不是
程序中唯一有名字的实体，例如，模块、类、类型、
结构、子程序，以及语言需要的任何东西:
语言可以自由添加更多种类的实体，如果它们需要的话。但是
这里，重点是变量和
函数的名字。

为此，存在范围的概念。作用域意味着
某个名称引用某个实体的空间。当一个变量的
范围结束时，我们说它超出了范围。这意味着，
如果它的名字被再次使用，它要么引用了一个不同的
变量，要么它的使用是非法的。

这样或那样的名字需要被解决。一般来说，它从程序中的当前点
开始，也就是要被解析的名字
出现的地方，并且从那里开始搜索。为了做到这一点，
主要有两种策略:词法范围和动态范围。

它们的共同之处在于，它们都是通过进一步查看它们的范围来从名称
开始搜索。如果变量
没有在当前块中定义，那么他们需要更进一步，而
就是他们变得不同的地方。词法范围基于源代码的结构或者抽象语法树
的结构寻找名字
，抽象语法树在结构上是等价的(因为它是
源代码的表示)。另一方面，动态范围使用执行
堆栈来查找值。它首先查找
调用者的名字，然后是调用者的调用者，依此类推，直到找到值
。

这两种策略都有有趣的特性，并且都有优点和缺点。所以在这里我将更详细地描述它们。

### [](#lexical-scope)词法范围

词法范围，顾名思义，使用了
程序的词法结构，这意味着变量的解析方式
不依赖于堆栈的内容。在
编译时可以很容易的说:为了找到这个变量的值，需要进行这样和
这样的运算。

这意味着它可以在编译时被解析，这通常是在生成访问变量的代码时
。这使得
代码更快，因为关于
标识符名称的信息可以消失，因为不再需要它:重要的
是访问值的路径。

同时，出现了一些与词法范围相关的实现困难。为支持一级函数的语言生成
编译代码是一个相当困难的问题。
的确，当一个指向函数的指针被创建时，人们可以说它是
一个函数对象:它不仅包含需要被
执行的代码，还包含与这段代码相关联的变量，不仅仅是
每次函数被
执行时创建的局部变量，还包含引用封闭
环境的非局部变量。有必要能够保留对它们的引用，能够阅读它们并进行修改。

程序中可以同时存在几个函数对象，甚至是几个
同一个对象的副本。在这种情况下，不可能知道这些环境需要多长时间。由于这个
原因，具有这种功能的语言通常需要垃圾
收集。

从某种角度来说，一切都是垃圾收集。以
为例，当一个函数返回时，它的局部变量和参数
通过从堆栈中弹出来进行垃圾收集。只有在
函数对象的情况下，这个简单的策略不再有效，需要一个
更复杂的垃圾收集器。

词法范围的一个有趣的特性是，它使得阅读代码变得更加容易。名称引用的变量或者在当前
块中，或者在封闭块中，或者在上面的块中。事实上
它独立于程序的执行状态，这使得
像阅读声明式编程一样阅读代码成为可能。

例如，这是一个经典函数`map`，因为它是在 scheme
中实现的。它采用一个列表`l`和一个函数`f`，并通过应用函数`car`
so: `(car l)`获得的`l`的每个元素并将这些元素以相同的顺序放在一起，生成一个新的
列表。
函数`cons`以这种方式将一个元素和函数`cdr`返回的
列表的其余部分组合在一起:`(cdr l)`。

```
(define (map l f)
  (cond ((null? l) '())
        (#t (cons (f (car l)) (map (cdr l) f))))) 
```

正如我们所看到的，代码非常简洁，我们清楚地看到使用了哪些
变量以及它们是在哪里定义的。一个没有声明的
变量不可能来自外部。这个代码是
独立的。

现在让我们看看词法范围真正的亮点:我们将使用这个带有闭包的`map`
函数:

```
(define (map-mult l n)
 (writeln (map l (lambda (x) (* x n)))))

(map-mult '(1 2 3 4) 10) 
```

我们清楚地看到变量指的是什么。无需进一步搜索。
即使我们不知道`map`是做什么的，我们仍然能看出`n`是什么，
是什么，`x`是什么。

词法范围还保持了引用的透明性。这意味着
当可以用等价的
表达式替换一个表达式时，程序的行为将不会改变。至少
如果功能没有副作用的话是这样的。这样，一个带参数的
函数调用可以用它
返回的值来代替，而不需要修改程序的行为。它还允许
执行记忆，即记住函数
用给定参数返回的值，并返回第一次返回的值，而不是再次调用它
。

这里有一个例子来说明参照透明的含义。让我们来看一个幂函数的例子，
`pow`:

```
(defun pow (n e)
  (cond ((= e 0) 1)
        ((= e 1) n)
        (t (* (pow n (- e 1))
              n)))) 
```

这里，函数的幂是通过将`e`乘以数字
`n`来定义的。但是，如果我们以不同的方式定义函数幂，即
`n^e = ((n^2)^d)*n^r`，其中`e = 2*d + r`和`r`要么是(0)，要么是
(1)，那么可以编写另一个使用更少
乘法的函数:

```
(defun pow2 (n e)
  (cond ((= e 0) 1)
        ((= e 1) n)
        (t (let ((r (mod e 2))
                 (d (/ e 2)))
             (* (pow2 (* n n) d)
                (pow2 n r)))))) 
```

这里我们使用函数`*`的属性，即它是参照
透明的:我们可以通过使用这个函数更少的次数，使用函数的不同
定义来获得相同的结果。如果
`*`函数在引用上是不透明的，那么
可能就不会工作，至少很难确定
函数是否正确工作。

顺便说一下，这段代码是用 Emacs Lisp 编写的，它的作用域是动态的
。这个例子表明，如果我们小心，即使在
动态作用域语言中，也有可能写出引用透明的
代码。这里当然没有那么难，因为`*`
是一个内置函数。对于更复杂的情况，动态范围
可能成为更严重的问题。

词法范围也有助于代码优化:在保证保留
程序预期行为的情况下，编译器
可以更容易地分析和修改引用
透明代码。

因此，这些属性使得对代码进行推理变得更加容易:
代码可以被细分成几个部分，因为我们确切地知道每个名称所指的是什么
，并且引用透明性使得
有可能将代码作为一组具有
精确含义的不同表达式来阅读。

### [](#dynamic-scope)动态范围

另一个重要的作用域策略是动态作用域。它与词法范围不同的主要特征是搜索实体名称的方式。当一个动态范围的
名字需要被解析时，搜索从名字出现的代码块
开始。在这一点上它与词汇的
范围没有什么不同。如果代码写得足够仔细，在许多情况下，在同一种语言的词汇和动态范围版本之间编写可移植的代码是可能的。

当在当前块中找不到名称
时，词法范围的差异就开始了。词法范围在词法环境之外搜索，而动态范围在最近的
定义的名字中查找，这些名字在范围之内。

另一个重要的区别是作用域以定义变量或给变量赋值的块
结束。这个
意味着，只要程序块还没有完成
的执行，这个值就是有效的。被调用的函数有权临时用自己的值替换值
，只要它们执行。当
块一结束执行，变量的值就
丢失，而先前的值(如果存在的话)被恢复。

动态作用域的一个有趣的特性是名称引用可以
引用在不同地方用词汇定义的变量。
被调用的函数无法知道它引用了哪些变量。它
取决于程序的执行状态。

动态范围有一个很大的缺点。严重依赖
的代码很难阅读、修改和重构。原因是
当动态范围的变量被引用时，代码的几个
部分变得相互依赖，如果有人想将
一些代码隔离到一个模块或函数中，没有办法知道哪个
其他函数使用这些变量。

此外，没有引用透明性，这使得
很难将代码细分成几个部分，也很难对每个
部分进行局部推理。因此，代码可能变得不可维护。

过去，使用动态范围的语言比现在多得多。例如，第一个 Lisp 使用了动态范围。在第一次
实现之后，很明显
动态范围的行为不是在阅读
源代码时所期望的。此外，对 Lisp 有很大影响
的 lambda 演算使用了词法作用域:变量可以与当前函数之外的变量
绑定。

下面是一个比较词法范围和动态范围的例子:

```
(declare a 1)
(defun fn (b)
  (list a b))
(let ((a 2))
  (fn 3)) 
```

该代码的计算结果为`(2 3)`。如你所见，当`fn`被调用
时，`a`“参数”被设置为(2)并覆盖(1)值。

让我们看一个 Scheme 中类似的例子:

```
(define a 1)
(define (fn b)
  (list a b))
(let ((a 2))
  (fn 3)) 
```

这段代码的求值结果是`(1 3)`:我们使用第一个`a`
，它是由`fn`捕获的。另一个`a`，在 let 中，是一个局部
变量，从词法角度看与
函数无关。

那么为什么动态范围会导致问题呢？在第一个例子中，我们
不知道`a`是什么。它实际上可以是任何东西:一个数字、一个
函数、一对……这就是为什么动态重构
范围的代码如此困难:我们需要检查和测试`a`
出现的每个实例，只有这样我们才能决定我们可以用函数
`fn`做什么。

动态范围也使得使用闭包变得不可能:当查找变量的名称
时，它的封闭块会被忽略。
至于高阶函数，也有类似的问题。

另一方面，尽管不太适合大项目，尽管重构有困难，动态范围还是有它的特殊用途。例如，它对于临时设置一个或几个函数应该访问的一些
全局参数很有用。当
当前块结束时，所有的绑定都被撤销，但是在此之前
这些参数可以被调用的函数访问。这种用法的一个例子
是当你必须用特定的
日期格式写入文件时，但是一旦你完成了写入，你就不再需要
这种格式了。但是只要写入
文件的函数还活着，所有需要写日期的函数，在那个函数的
动态范围下，都会知道使用哪种格式。

动态范围的另一个重要用途是回溯。当测试
不同的可能性时，可以设置一些设置，并且可以
测试结果。如果失败，可以设置其他设置，并再次调用
计算结果的函数，以此类推。

动态范围通常用于异常处理。事实上，在代码块中定义的
处理程序在许多语言中是动态作用域的
。这些处理程序通常被定义为
代码块，通常称为`catch`块。例如，在 Java 中，有一个
`try`块，其中包含可能抛出异常的调用，而
中有`catch`块，描述当
出现异常时需要完成的步骤。catch 块内部的代码被称为
异常处理程序，可以被视为一个函数，当分配给它们的异常被抛出时，这个函数就会被执行
。
抛出异常的实际代码实际上可以远离`try`块和
`catch`块，但尽管如此，要找到需要
执行的处理程序，还是要遵循动态范围的规则。

### [](#conclusion-about-lexical-and-dynamic-scope)关于词法和动态范围的结论

所以最后我们看到了什么是作用域以及它是如何工作的。我们已经描述了当名字在当前块中是 T1 时，解析名字的两个主要策略。尽管看起来词法的
作用域已经胜出并且更适合编程，但是动态的
作用域仍然非常重要，许多语言甚至没有尝试过用
来摆脱它。一些语言甚至两者都支持。由此可见
动态范围的重要性。这里有一些同时使用这两种语言的例子:

*   Common Lisp 通常是词汇范围的，但是支持动态范围的变量，这在 Common Lisp 中被称为 special。
*   Java 和许多使用异常处理程序的语言:异常处理程序通常使用动态范围与异常相关联。
*   c 宏:当宏包含自由变量时，它们在动态范围内计算。它们通过替换代码中的宏名来工作，所以它不是真正的动态作用域，因为它不会在当前的执行堆栈中查找宏名。但是当这些自由变量在宏使用的范围内时，它们的行为就好像它们被动态地限定了范围。
*   Scheme 还在一些输入和输出例程中使用了动态作用域，例如在`with-output-to file`中，尽管它几乎在任何地方都是词汇作用域。
*   Perl 是一种在创建时就被动态限定了作用域的语言，后来增加了词法作用域，所以现在由程序员来决定使用哪种作用域策略。

有趣的是指出词法和动态作用域不是描述作用域规则的唯一可能性，
也不足以描述由
语言解析变量的方式。一个很好的例子就是很多
汇编语言中标签的区别，标签不需要前向声明，可以在声明前
使用，而 C 中的变量，需要在使用前
声明。从这个意义上说，C
中的每个变量都引入了自己的作用域。

对词法范围也有限制，例如在
中，Java 对象闭包只允许`final`变量，这意味着
其他变量在某种程度上更受限制的范围内。更多这样的
例子，Eric Tanter 在*超越静态和动态
范围*<sup id="9361e0bd08c4091cedfc72c12e00ee47">[Tanter _ 超越](#tanter_beyond "Tanter, Beyond static and dynamic scope, v(), 11 ().")</sup> 中有描述。

## [](#firstclass-functions-and-closures)一级函数和闭包

### [](#what-is-being-firstclass-citizen)什么是做一等公民？

我的实现中的另一个重要特性，也是通常存在于 Lisp 实现中的特性是一级函数。它
意味着函数以及其他类型，如整数、
字符或布尔，是给定的
编程语言中的一等公民。

具体来说，它有几个重要的性质。它可以作为参数传递给函数。为了做到这一点，函数的
名称不仅应该只可用于调用
函数，它还应该将函数表示为一个变量，可以将
视为具有特定值。或者可能有其他的
方法来给一个变量赋值，例如
使用 lambda 函数。

一等公民的另一个重要属性是，他们可以作为返回值从函数中返回。这当然是 Scheme 和 Common Lisp 的
情况。一切可以被操作的东西
作为一个有名字的变量可以被返回。这是因为 Lisp 有
动态类型系统，它不知道它
返回的值的类型。所以如果你有办法让一个变量引用某个东西，
你必须能够返回它。

成为一等公民的第三个必要条件是能够被分配。这里也一样，Lisp 是一种相当简单的语言，如果你有一个值，你可以自由地把它赋给你想要的任何东西
。任何表达式都可以被赋值给一个变量。

被认为是一等公民的最后一个属性是
必须能够辨别两个功能是否相等。这是相当困难的，因为首先，函数等式可以有几个 T2 的意思。例如，如果它们对于相同的输入有相同的输出，
或者，它们的内部结构是否相同，它们在内存中是否有
相同的地址。

也可以考虑执行时间。也很难判断它们是否相等，因为测试它的成本相当高(除了测试内存地址，这不是一个好方法
)。另外，一般来说，仅仅通过检查它们的源代码是不可能判断出
函数是否给出相同的输出的。我
认为在实践中并不经常使用。不提供动态方法来构建函数的语言，如 C，通过比较内存地址来提供或多或少的近似等式。在 Java 的情况下，需要比较
对象的类型:通常函数被放在一个类中，这使得
等同于函数。这类的好例子是
比较器和监听器。

### [](#higherorder-functions)高阶函数

Lisp 和许多函数式语言的一个有趣特性是对高阶函数的
支持。高阶函数是一个
函数，它接受其他函数作为参数，并且/或者可以
返回一个函数作为返回值。两种情况略有
不同，用法也不同。当一个函数被传递时，它是由接受函数执行的
，所以像 C 这样的
语言支持，无法用闭包捕捉环境。另一方面，当返回时，C 非常有限:它只能返回一个函数的内存地址，而不能创建一个新的函数，这在函数式编程语言中是可能的。因此，
可以说，c 只支持一半的高阶函数特性
。

高阶函数的使用给语言带来了很大的表现力和灵活性。它允许抽象一些动作和
概念。例如，可以使用高阶函数根据比较标准对列表中的
进行不同的排序。通过将不同的函数传递给排序函数，可以让
进行不同的排序。

以下是高阶函数的一些常见用法示例:

*   *map* 函数用于通过对每个元素应用一个函数来转换一个列表或创建一个新列表。
*   *过滤器*功能允许通过仅使用由用户提供的功能测试为阳性的元素，基于现有列表创建新列表
*   *fold* 函数处理整个列表并从列表中创建一个值。它可以是总和、平均值、最大值、最小值、计数或用户希望做的任何事情。
*   另一个例子是按照用户想要的方式执行动作。例如，它可以是一个 equal 函数，传递给一个检查元素是否在列表中的函数。并不是所有的相等都是相同的，有时，用户能够准确地判断两个值何时被认为相等是非常有用的。

下面是一个高阶函数的代码示例:

```
(define (fold-if list fold-fun filter-fun base-val)
  (cond ((null? list) base-val)
        ((filter-fun (car list))
         (fold-fun (car list)
                   (fold-if (cdr list) fold-fun filter-fun base-val)))
        (else
         (fold-if (cdr list) fold-fun filter-fun base-val)))) 
```

本例中的函数`fold-if`将一个列表、
折叠函数、一个过滤函数和一个基值作为参数。所以它只折叠传递给过滤函数时返回 true 的
值。

下面是该函数的一个使用示例:

```
(fold-if '(1 2 3 4 5 6 7 8 9 10)
         *
         (lambda (x) (= (modulo x 3) 0))
         1) 
```

它的意思是，给定一个 10 个数字的列表，它应用
乘法函数，从 1 开始到所有能被
3 整除的成员。所以它基本上与返回 162 的`(* 3 6 9)`，
相同。

### [](#anonymous-functions)匿名函数

Lisp 和 Scheme 的另一个重要特性是支持
匿名函数，也称为 lambda 函数。

意思是它们只是函数，但是没有名字。
调用它们的方式*λ*函数来自λ演算，
是抽象函数的系统。λ
演算中唯一的对象是一个函数，唯一允许的操作是函数
应用。函数没有名字。

lambda 演算中使用函数的方式给出了一个例子
如何在编程语言中使用匿名函数:通过
将它们作为参数传递。

的确，如果语言不支持一级函数，
匿名函数看起来可能是一个完全无用的概念:创建一个你没有办法引用的东西有什么用
？

不管怎么说，lambda 函数的概念是在第一个
编程语言诞生之前就诞生了，这也是为什么 Lisp，第一个
使用匿名函数的语言，使用 lambda 关键字来
引用它们的原因。

但是即使它们不被支持，仍然有可能通过创建普通的命名函数并传递它们来获得它们的全部功能。这里存在另一个问题:语言必须支持局部函数的
定义，因为 lambda 函数通常
用于局部上下文中，可以引用局部变量(顺便说一下，
对于 lambda 函数来说是非局部的)。所以简单地通过
传递一个顶级函数不会提供相同的功能。

另一种经常使用匿名函数的方式是返回一个
函数作为函数的返回值。这样，
就可以编写一个函数作为函数工厂，根据传递给它的参数创建
不同的函数。这是仅仅用函数指针不可能做到的事情，因为它们
不会捕获环境。

因此，下面是一个在 Scheme 中使用匿名函数的简单示例:

```
(define (fn f c)
  (+ (f 5) c))

(fn (lambda (x) (* x 100)) 3) 
```

代码创建了一个匿名函数，该函数简单地将其参数
乘以 100。`fn`函数用值 5 调用它，并将第二个参数添加到
中。所以结果是(503 = (100 * 5) + 3)。

### [](#closures)关闭

另一个重要的概念是闭包。闭包是指当
是一个具有非局部自由变量的内部函数时，这些变量被
所包围。它不一定是最近的
封闭块，也可以是高几级的块。
*闭包*一词来源于自由变量被周围的块
*封闭*的事实。

下面是一个 Pascal 中闭包的例子:

```
program test01;

function fn(c: integer): integer;
    function infn(x: integer): integer;
    begin
        infn := x * 100 + c
    end;
begin
    fn := infn(5)
end;

begin
    writeln(fn(3))
end. 
```

这段代码使用了一个内部函数`infn`，它可以访问一个外部
变量`c`，该变量是`fn`函数的一个参数。它工作
是因为代码不需要创建函数对象。只有
需要访问堆栈上封闭函数的框架。

闭包通常与一级函数相关联，因为
它们经常被用来返回一个函数，这是函数式编程中的一种循环模式
。但是它们也可以在没有一级函数的情况下用于语言的
。例如在 C 语言中，全局
环境可以被视为函数的闭包，因为函数
可以使用其中定义的全局变量。Pascal 中也有类似的
概念，支持嵌套函数，也就是函数内部的函数
。内部级别上的函数可以使用外部级别上的函数的变量
，因此，外部级别创建了一个
闭包。然而，内部函数不能被返回，因为当
返回这样的函数时，它们的环境必须以某种方式
保留，这在没有
垃圾收集的语言中不容易实现。

闭包通常用于回调。也就是说，当用户
指定在某些情况下要调用的函数时:当
异常、中断或事件发生时。

与闭包相关的是 *funarg* 问题。当一个函数作为一个值从另一个函数返回
时，它可以引用非本地
值。问题是，以这种
方式创建的所有函数必须能够共享值，如果它们引用相同的值的话。
例如，如果在同一环境中有不同的闭包，
或者用户复制一个闭包。在这种情况下，为了知道
何时释放不再使用的环境，语言(或其
运行时)需要一个垃圾收集器。

下面是一个返回函数的高阶函数的示例:

```
(define (make-multiplier n)
  (lambda (x)
    (* x n))) 
```

该函数需要保存传递的参数`n`。
通过另一个参数，它可以创建不同的功能。它可以
用在以下方面:

```
(let ((mul5 (make-multiplier 5))
      (mul2 (make-multiplier 2)))
  (writeln (+ (mul5 6) (mul2 4)))) 
```

我们创建两个函数:`mul5`和`mul2`。`mul5`返回乘以 5 的
参数和乘以 2 的`mul2`参数。

所以这个程序执行的时候，打印出来的是(38)，也就是((5 * 6) +
(2 * 4))。

## [](#tailcall-optimization)尾音优化

如果 Scheme 编译器或解释器不执行尾部调用优化，它就不能使用 Scheme 这个名字。在
规范中是这样写的。因此，我的解释器，即使是真正的
极简主义者，并且实现了 Scheme
编程语言的一个非常小的子集，为了被称为 Scheme，实现了一些
最基本的尾调用优化。

这个术语是什么意思？当一个函数调用另一个
函数时，它会将一些值放在堆栈的顶部。
至少它必须是返回值，而且通常它也是函数
的参数。

当一个函数在返回之前调用另一个函数时，an 因此使用
其结果作为当前函数的结果，这样可以避免
使用更多的堆栈空间。目的是让
调用者调用一个函数，但另一个函数返回。如果调用约定不是太复杂或者设计得不好，这通常很容易做到。需要做的是让最后调用的
函数相信它必须返回到当前函数
必须返回的地方。因此，它不把一个新值压入堆栈，而是直接跳到被调用的函数。
具体必须做什么取决于调用的
约定，当然，就像参数传递的方式等等
一样，但是思想总是相同的:执行返回，就好像
调用者调用的不是当前函数，而是最后一个函数。

这个想法并不依赖于栈必须在那里的想法。如果有一天我们发现栈已经过时，并且有一个更好的方法来实现函数调用，那么尾部调用优化的想法
可能仍然有效。

# [](#functionality)功能

因此，现在我将简单介绍一下
PowerScheme 的功能:它是什么，它的设计目的是什么，以及它的一些
属性，这些属性使它不同于通常的 Scheme 实现。
有时我会包含一个我认为有趣的特性，
有时我想包含一些东西，但后来意识到它
会太复杂而无法编码或者不实用。

## [](#powerscheme-is-a-scheme-interpreter)PowerScheme 是一个方案解释器

最明显的一点是，作为一个初学者，我不会一开始就从困难的事情开始。我尽量让一切都在可控范围内，将来，当我对
的工作方式有更好的了解时，我会添加一些更先进的技术和功能。为此
我的方案实现是一个解释器。解释器通常比编译器更容易编码，因为编译器需要关于目标架构、优化技术等等的知识。

我的解释器可以在两种不同的模式下运行。模式是在程序启动时确定的
，在运行时不能切换。

### [](#interactive-mode)互动模式

第一种模式是交互模式。当不带参数调用解释器时，PowerScheme 在
模式下启动。那个
意味着它像 REPL 一样工作:程序等待用户
输入代码行(当用户输入
单个字符时它不做任何事情)，然后看它是否能被解释。如果
输入包含一个完整的 s 表达式或单个值，它
解释它并在屏幕上打印结果值。在某些
情况下，当
程序执行过程中出现错误时，解释器会打印一条
错误消息，而不是打印一个返回值。这是通过 PowerShell 对异常
的支持来实现的。

这就是它的开始。在包含解释器的源代码
的目录中，只需通过键入`pwsh
-File PwScheme.ps1`来调用 PowerShell:

```
$ pwsh -File PwScheme.ps1
PowerScheme>(writeln "Hello, World!")
"Hello, World!"
PowerScheme>_ 
```

现在解释器可以在交互模式下使用。为了退出
，有一个专门的内置函数`exit`:

```
PowerScheme>(exit)
$ _ 
```

### [](#noninteractive-mode)非交互模式

第二种模式是非交互模式。为了进入此
模式，程序必须以一个被解释为文件名
的参数开始。文件名引用的文件必须包含一个能被 PowerScheme 解释的
程序。然后
读取并执行该程序。当 PowerScheme 完成执行
程序时，它什么也不做就退出。

下面是一个在非交互模式下运行的例子，从`tests`目录下名为
`y-combinator.scm`的文件中读取
方案源代码。正如你所看到的，在执行完程序后，
打印出程序告诉它要打印的内容，它立即退出。

```
$ pwsh -File PwScheme.ps1 tests/y-combinator.scm
6
3628800
$ _ 
```

## power scheme 中的词法和动态范围

我必须做出的另一个决定是关于范围规则。有两种主要的方法来查找变量:词法范围和动态范围。我以前的解释器，我用 Kotlin，
写的，完全是词汇范围的。对于这一个，由于我决定将
写成小片段的 *Lisp 第二章的练习，其中
讨论了动态范围的实现，我认为
在本书中没有进一步讨论，所以我决定同时实现
动态和词法范围。*

Scheme 根据其定义必须是词汇范围的。当它被
创造出来的时候，它被认为是来自
Algol 的外来特性。所以，不管怎么说，将词法范围
完全排除在外并不是一件好事。所以我决定两样都做。在书中,
展示了使用专门的关键字进行动态范围的
声明和访问的实现。现在我觉得这是个
好主意。想要修改一个变量，然后
发现它实际上是动态范围的，这应该很奇怪。正因如此，我
认为，在 Common Lisp 中有一个约定，为了区分
动态变量和其余变量，要在变量名称的前后预先加上并追加一个星号
。

我或多或少用了 Common Lisp 中的方法:访问动态
变量的方式与访问词法变量的方式相同。对于
声明，无论是变量还是函数，我都使用关键字
`dynamic`。如果用户试图对一个词法变量和一个动态变量使用
相同的名字，这会导致问题。一个更好的解决方案
是系统地检查它们是否重叠，或者在名称中强加
一个区别，比如只允许星号
之间的名称对于动态名称是合法的。这实际上会导致混乱
，因为在 Common Lisp 中，这样的变量都是全局范围的，但是在我的实现中，它们可以在任何级别定义。

下面是我写的一个小程序，用来测试我的动态范围的
实现是如何工作的:

```
(dynamic y 1)
(define (f x)
 (writeln (list 'f y))
 (set! y (* x 10))
 (writeln (list 'f y))
 (g 7)
 (writeln (list 'f y)))
(define (g a)
 (writeln (list 'g y))
 (set! y a)
 (writeln (list 'g y)))

(writeln (list 'top y))
(set! y 3)
(writeln (list 'top y))
(f 5)
(writeln (list 'top y)) 
```

它打印了以下内容，表明即使函数修改了
变量`y`，它们也只是在它们的作用域内进行修改，并且当它们返回时，以前的值
被恢复:

```
(TOP 1)
(TOP 3)
(F 3)
(F 50)
(G 50)
(G 7)
(F 50)
(TOP 3) 
```

## [](#exception-handling)异常处理

动态范围的另一个用途是处理异常。因此，我在 PowerScheme 中添加了一个非常基本的异常处理特性来测试它与动态范围的关系。所以让我们假设
每一个错误条件都有一个与
相关联的动态作用域函数。用户可以轻松定义它们，例如:

```
(dynamic (*zero-crasher*) (writeln '*zero-crasher*)) 
```

`dynamic`的语法类似于`define`，但是声明
是在动态环境中进行的，因此创建了动态变量
和函数。

假设它与某个东西试图被零除的情况有关。它是这样使用的:

```
(define (div a b) (if (= b 0) (crash (*zero-crasher*)) (/ a b))) 
```

当我们遇到为零的`b`时，我们通过
执行*崩溃程序*来崩溃程序。特殊形式`crash`评估它的
参数(这里它执行我称之为*崩溃程序*的函数)并且
使程序崩溃。

```
(div 6 0) 
```

比如这个，打印`*ZERO-CRASHER*`，崩溃。

该错误处理程序在被覆盖之前是全局工作的:

```
(let ((a 5)
      (b 0))
 (set! *zero-crasher* (lambda () (writeln 'test:from-let)))
 (div a b)) 
```

现在我们可以指定我们想要的处理程序。所以在这里，在这个特定的
动态范围(这个`let`)中，我们有我们自己的错误处理器，我们自己的
*破坏者！！*

当然，它的使用是有限的，对于许多使用情况来说不够强大。我认为可以实现它，这样程序
仍然可以继续执行。但即使我在那里实施了,
也是个问题。这种异常处理程序似乎变成了一种
反模式。当使用栈展开异常处理程序时，
代码变得容易出错并且难以推理。这就是为什么我没有完全实现它的
原因，只是
中的一个最小子集，以查看动态范围的作用。还有另一个
问题，即使它可以以某种方式得到解决:需要有一种方法从处理程序通过堆栈跳转到处理程序
被定义的地方。很多东西不重写
其实很难解决。一种可能的策略是返回值，
，但必须对其进行检查。无论如何，Scheme 值在我的
实现中是对象，所以一个整数值，例如，(0)可以
表示一个异常已经抛出并且需要被捕获。这种情况类似于延续的情况:它必须从一开始就在需求中指定。因为它是一个有缺陷的特性，即使做得对，我也没有实现它。
另一方面，在一个延续的方案中，实现起来并不困难，并且可以成为一个有趣的玩具。

# [](#implementation-details)实现细节

在这一部分，我将描述我为这个解释器所做的一些实现决定。我不会描述
实现的每一个细节，但我会关注部分，在那里我必须做出
选择，或者当我必须找到一个特定问题的解决方案。

所以，我将从头开始，当程序第一次被调用时:如何选择程序执行模式，等等。

然后我将描述如何读取输入。首先它通过
记号赋予器，它只留下程序的基本元素，
然后是解析器，它试图在
程序中找到一个结构，然后这个结构被评估。

评估也是解释器的一个相当复杂的部分，并且
它的各个部分也需要被描述。我所做的各种
实现决策，比如函数调用的方式
，环境如何工作等等将在这一节中给予一些
关注。

## [](#the-structure-of-the-code)代码的结构

所以描述代码结构的一个好方法是显示它被细分在什么
文件中。这是一个相当简单的程序，它只有七个源文件:

*   `PwScheme.ps1`是程序的入口点。它以 REPL 模式执行，或者在给定参数的情况下，从文件中读取代码。
*   `Tokenizer.ps1`:从输出中产生令牌。
*   `Bag.ps1`。在给解析器提供标记之前，最好有完整的表达式，这样就可以毫不延迟地执行进一步的步骤。所以`Bag`提供了一个迭代器，它只给出可以被解释为 Lisp 对象的东西:原始值或对/列表。
*   `Parser.ps1`。创建代码的结构表示形式。
*   `Evaluator.ps1`:将代码转换成正在执行的程序。由于它本身就足够复杂，所以需要前面的步骤，所以它可以完成工作，而不用担心与其不直接相关的步骤。
*   `Environment.ps1`代表执行的环境。有两种环境:词法环境和动态环境。它们的工作方式也不一样。但是我还是试图将它们放在一个程序单元中，因为它们的功能在某种程度上是相似的。
*   `System.ps1`。它是与操作系统交互所需的辅助单元。它还包含一些预定义的函数，比如乘法或模运算，这些可以用语言来表达，但是如果我使用 PowerShell 提供的函数会方便得多。

## [](#the-entry-point)进入点

文件`PwScheme.ps1`包含入口点。它的工作是
启动一切。如果你看代码，你会看到它
分成两部分。第一部分对应于
中的情况，它用一个参数调用，在这种情况下，它读取一个
文件。第一部分是在交互模式下，所以它的工作是
在用户输入命令时显示提示并执行。

如您所见，只有在第二种情况下才需要`Bag`。它是
,因为它需要知道是否有足够的输入，这样它才能
被评估。当从文件中读取时，这个问题不会发生，
因为程序只能读取到文件的末尾，如果
表达式未完成或非法，在程序执行的
期间不能改变。

另一个有趣的地方是出口函数如何发送一个异常
给 REPL，告诉它希望程序
终止。所以，是的，我用了一个`ExitException`。我不知道 PowerShell 的
人如何看待它，但是在一些编码社区中，它被
视为异常的`goto`使用，这是不受欢迎的。但是
在 PowerShell 中没有其他的`goto`机制，这种对
`goto`的使用就是其中一种情况，否则会使代码效率更低
更难阅读。我需要返回一个
特殊值，堆栈中的每个函数都必须检查
我是否想退出…

## [](#the-tokenizer)分词器

我的解释器中非常简单和通用的一个东西是
记号赋予器。它定义了一个`Token`类，这是一个专门用于创建令牌的
类。它读取输入，删除注释，
解释原始值(如字符、字符串、数字)，而
并不试图创建任何类型的结构。相反，当它
遇到一个特殊字符时，比如一个括号，它为这个字符创建一个标记
。

## [](#the-bag)袋子

`Bag`也是一个非常简单的单位。它所做的，就是确保
当`Parser`试图读取输入时，它得到的东西带有
数量平衡的括号。这就是为什么它在记号赋予器之后出现
的原因:它需要知道一个括号是否在
一个文字(一个字符串或者一个字符)里面，或者它是否真的是一个真正的
括号，它在那里给出代码的结构。

## [](#the-parser)解析器

然后是`Parser`。即使很多人说解析是
还是一个没有解决的问题，但是对于一些简单的任务，简单有效的
解析器是可以做到的。对于 Lisp 来说，情况确实如此。我有一种
的怀疑，它看起来今天的样子是为了使
解析问题更容易。很多解析
技术的发展是在 Lisp 看起来像现在这样的时候出现的。

所以我的解析器只有一种非终结符需要解析:s 表达式。也就是说，当它遇到一个左括号时，它
知道它所代表的是一个 s 表达式的开始。当它
遇到右括号时，就是 s 表达式的结束。没有更多的东西了。`Parser.ps1`文件的一半实际上是由类`Exp`的定义得到的
，它代表 AST 中的一个表达式
。基本上一切都是一个`Exp`:一个
文字，一对，一个函数…

## [](#the-evaluator)评价者

然后求值器的工作是读取
解析器产生的结构，并执行(或者用
Lisp 程序员的语言求值)表达式。有趣的是，通常编程语言中的
，有语句，也有
表达式。人们说语句被执行，而
表达式被求值。但是在 Lisp 中，语句和表达式
是一回事。表达式是语句，语句是
表达式。如果你仔细想想，这有点道理，因为
语句和表达式都是交给计算机
执行的任务。所以它们是密切相关的。人们决定把两者分开的原因很难理解。也许
与编程语言
的创建历史有关，就像最初一切都必须是一个语句，只有
一些算术表达式或类似的东西。

### [](#types)类型

我的解释器中有三种类型:原语类型
(数字、符号、字符串、字符、布尔)、对(它们是用 conses 表示的
)和函数，其中有三种类型
(自定义、内置和 thunks)。

### [](#functions)功能

函数是编程语言中的一个重要话题，尤其是 Lisp，它有时甚至被称为函数式编程语言。有许多主题与函数和
有关，有许多不同的方法来实现它们，还有很多事情
很难实现。因此，在这里我将介绍我在实现我的 PowerScheme 解释器
中的函数时遇到的几个
问题和解决方案。

首先，在我的解释器中有 3 种不同的函数:
用户定义的、内置的和 thunks。现在，在做了一些
选择并环顾四周之后，我发现一种
语言拥有不同种类的函数是很常见的事情。比如
C 有函数，宏，一些看起来像函数的关键词，
没有，像`sizeof`。Bash 有用户定义的函数、内置的
函数和外部命令。和 PowerShell 差不多
的情况。几乎在所有地方我都能看到这种模式。

因此，有些功能是由用户定义的。这些函数以 AST 节点的形式保存。他们还将环境保存在他们定义的
中，以便不丢失对非本地
变量的访问。

现在我将展示它们是如何产生的。有一个专门的函数
，它的工作是创建函数。叫`Make-Function`。
每当遇到
`lambda`或`define`时，从 Evaluate 函数中调用。

有趣的是，仅仅通过检查这个函数，你就可以
了解我的解释器是如何工作的。

```
function Make-Function($name, $env, $paramsExp, $body) {
    $function = New-Object Fun
    $function.defEnv = $env.Duplicate($name)
    $function.isThunk = $false
    $function.params = @()
    $paramsCons = $paramsExp
    while ($paramsCons.type -eq "Cons") {
        $function.params += $paramsCons.car.value
        $paramsCons = $paramsCons.cdr
    }
    if ($paramsCons.type -eq "Symbol" -and $paramsCons.value -ne "NIL") {
        $function.dotParam = $paramsCons.value
    }
    $function.body = $body
    return New-Object Exp -ArgumentList ([ExpType]::Function), $function
} 
```

它将函数名(这里仅为调试目的的
)、定义它的环境、保存参数的
表达式(在 Lisp 中通常是标识符的列表
)和函数体(当调用函数
时执行)作为参数。

你会发现函数实际上是一个对象。即使 PowerShell 的作者
说它不是一种面向对象的语言(他们称
it object-*based*<sup id="bc24fab90f95f459a9c20cc3d8e7a767">T5】payette _ windows _ 2007</sup>)，对象
的存在还是相当方便的，更容易编写代码。

奇怪的是我们复制了环境。不用
担心，不是环境的深度复制。之所以需要它，是因为
环境本身是一个对象，如果我们不复制，它的
状态将会改变(例如范围级别)，这不是
应该发生的事情。此外，`Duplicate`函数使得
环境可以为每个
变量设置分支堆栈。稍后我会更详细地解释。

然后我们标记它不是 thunk。因为它只是一个常规的
自定义函数。

然后我们遍历 conses 的链表，将
元素添加到`params`字段。然后我们需要处理点参数的情况
。真的很复杂，不太好
测试。我希望这不是 Scheme 的必备功能。

然后，最后，我们将主体插入到函数中，并将
函数放入到`Exp`中。因为`Exp`可以是任何东西，所以函数
不是 exp，但是它可以包含在`Exp`中。记住，`Exp`
是一种可以保存任何 Lisp 值的类型，包括函数。

有些功能是内置的。这些函数执行一些
输入和输出(如读取文件或写入控制台)、
算术函数、类型检查函数和`EXIT`
函数。

这些功能在`System.ps1`文件中定义。我会称它为
一个单元，因为我愿意称它为模块，但它在 PowerShell 中意味着
别的意思。

现在，让我们来看一些例子:

让我们从一个简单的函数开始，它的任务是将两个数相加。在我的实现中，只支持整数:

```
function SysPlus($a) {
    $result = 0
    foreach ($num in $a) {
        $result += $num.value
    }
    return New-Object Exp -ArgumentList ([ExpType]::Number), $result
} 
```

我们接收一个包含整数的数组，我们必须将它们相加。所以
我们把它们一个一个加起来，然后把它们放在一个
`Number`类型的`Exp`中。

下一个功能也很容易理解:

```
function SysWriteLn($a) {
    foreach ($exp in $a) {
        Write-Host -NoNewline $exp
    }
    Write-Host ""
    return $null
} 
```

它有几乎相同的结构。它返回一个`$null`，这个
表示缺少返回值。用户不应该期望
功能仅仅是为了副作用才有价值。

下一个函数很有趣，它叫做`EVAL`:

```
function SysEval($a) {
    return Evaluate $a[0] (Make-Global-Environment) (New-Object Environment "#<eval>") $false
} 
```

是的，它从赋值器调用 evaluate，并将它收到的值传递给它，不过是一个新的全局环境。第二个
环境是动态环境，是空的。

另一方面，Apply 稍微大一点:

```
function SysApply($funExp, $argsExp) {
    $function = Evaluate $funExp $env $denv $false
    $env = Make-Global-Environment
    $denv = New-Object Environment "#<apply>"
    if ($function.type -eq "BuiltIn") {
        return Call-BuiltIn $function.value $argsExp $env $denv $false
    } elseif ($function.type -eq "Function") {
        return Invoke $function $argsExp $env $denv $false
    }
    return $null
} 
```

根据
是否是内置函数，它使用`Invoke`或`Call-BuiltIn`。

这是我的异常处理函数:

```
function SysCrash($args) {
    Evaluate $args[0] $env $denv $false
    throw [ExitException] "CRASH"
} 
```

我知道这看起来像作弊，因为我使用
异常来实现异常，但这是一件相当难实现的事情，而且
需要更多的工作，而不是简单地在这里或那里改变一些东西。

这是用来读取标准输入的函数。它
显示一个提示，并等待一个跟在换行符后面的字符串:

```
function SysRead($a, $env, $denv) {
    if ($a.length -eq 1) {
        $msg = $a[0].value
    } else {
        $msg = ">"
    }
    $text = Read-Host $msg
    $tokens = Get-Tokens $text
    $exps = Parse-Tokens $tokens
    $exps | ForEach-Object {
        try {
            $exp = Evaluate $_ $env $denv $false
        } catch [EvaluatorException] {
            Write-Output ("Exception in SysRead: " + $($_.Exception.msg))
        }
    }
    return $exp
} 
```

这个函数需要首先从输入中读取，然后经过标记化、解析和评估的
步骤。然后有一个循环
，以防用户决定将几个表达式放在同一行。
返回值是计算的最后一个表达式。

接下来是一个函数的例子，它检查一个
值的类型是否是一对。在这里你可以看到布尔值是如何放入
T0 中的:

```
function SysIsPair($a) {
    return New-Object Exp -ArgumentList ([ExpType]::Boolean), ($a[0].type -eq "Pair")
} 
```

这里是`EXIT`函数。当然，这没有什么令人惊讶的。

```
function SysExit() {
    throw [ExitException] "EXIT"
} 
```

### [](#local-functions-and-thunks)局部函数和 Thunks

Scheme 有一个构造来定义递归函数，使它们成为
局部函数，它被称为`letrec`。这里有一个例子来说明
是如何工作的:

```
(letrec ((odd
           (lambda (lst)
            (cond
             ((empty? lst) empty)
             (else (cons (car lst) (even (cdr lst)))))))
         (even
           (lambda (lst)
            (cond
             ((empty? lst) empty)
             (else (odd (cdr lst)))))))
  (writeln (even '(1 2 3 4 5 6)))
  (writeln (odd '(1 2 3 4 5 6)))) 
```

这个表达式的输出是:

```
(2 4 6)
(1 3 5) 
```

所以它定义了两个互相使用的局部函数，
如果这有意义的话。关于`letrec`的实现
有问题。那就是`let`表达式是在它们的
环境中被求值的，并且不能访问存在于
let 中的其他东西。

这里我们看到，这两个局部函数都想访问另一个函数，这意味着这两个函数必须相互了解。

那么，该怎么办呢？一个简单的解决方案是为 let 参数定义一个环境
，用一个将被
覆盖的临时值添加这些名称，然后将 lambda 函数赋给这些变量。
这样，当它们被定义时，它们就在
这些本地函数可见的环境中。

这种策略似乎行得通，因为它或多或少是好的。但是，不幸的是，我发现这种方法有一个问题。让我们看一下
下面的代码:

```
(letrec ((f (lambda (x) (+ (g (+ x 1)) 1)))
         (x (g 4))
         (g (lambda (x) (* x 10))))
  (writeln (+ x (f 7)))) 
```

事实上，参数之一`x`不是函数，但是它依赖于函数`g`的存在。所发生的是
力矩值被赋值函数`g`还不可用
，但是`x`的值应该被定义:它是(40)。而整个表达式的值
就是`(+ 40 (+ (g 8) 1)) = (+ 40 81) = 121`。

我们如何让它发挥作用？其实很简单。我们已经看到
与函数一起工作，这意味着如果我们将`(g 4)`转换成
函数，它将会工作。那么我们该怎么做呢？实际上
也很简单:`(lambda () (g 4))`，不需要更多。这种
功能被称为 thunk。从字面上来说，这意味着程序需要
进行一些思考来设置值。这就是为什么它被称为 thunk。

这是创建 thunk 的方式:

```
function Make-Thunk($exp, $env) {
    $function = New-Object Fun
    $function.defEnv = $env
    $function.params = @()
    $function.isThunk = $true
    $nil = New-Object Exp -ArgumentList ([ExpType]::Symbol), "NIL"
    $cons = New-Object Exp -ArgumentList ([ExpType]::Cons), $exp, $nil
    $function.body = $cons
    return New-Object Exp -ArgumentList ([ExpType]::Function), $function
} 
```

所以这是一个在词法环境中评估的函数，没有
参数，标记为一个 thunk，其主体的唯一元素是对应的表达式
，然后它被包含在返回的`Exp`和
中。

但实际上这种方法还有另一个问题。如果我们简单地将
转换成一个函数，那么引用将指向一个
函数，并且不再起作用:如果`x`是一个函数，那么像`(+ x 10)`这样的表达式就没有意义。这种情况下应该是
转化为`(+ (x) 10)`。

由于这个原因，需要一种特殊的函数，我在实现中称之为
thunk(在其他使用中，这个术语可能有稍微不同的
意思)。它是这样工作的:第一次需要
`x`时，执行 thunk 函数，然后将值
存储在`x`变量中，覆盖 thunk，并返回值
。第二次评估`x`时，使用该值。这意味着 thunks 只为一种用途而存在，以后就不再需要它们了。

## [](#the-environment)环境

环境是一种数据结构，当给它一个名字时，它提供可变的
实体。这使得
可以使用包含可修改值的变量。

因此，一个环境有三个基本操作:

*   声明一个变量
*   给变量赋值
*   获取变量的值

为了允许在块中使用变量，有两个
附加操作:

*   输入范围
*   留下一个范围

在进入一个作用域后，我们可以声明新的变量而不用修改旧的变量，而旧的变量仍然可见。这些变量
是在同一层上创建的。当离开一个作用域时，当前级别的所有
变量都被遗忘(不一定销毁)。

### [](#lexical-and-dynamic-environments)词汇和动态环境

PowerScheme 有两个范围:词法范围和动态范围。为了让两者都有，我使用了两个环境:一个词法环境和一个动态环境。

它们可以共享变量，但是我的
实现中的词法环境首先用于查找值。

为了在定义变量时区分使用哪一个，我使用了两个
不同的关键字:`define`用于词汇范围的变量，
和`dynamic`用于动态范围的变量。他们也是以同样的方式使用
。以下是一些例子:

```
(define a 1)
(define b 2)
(dynamic
 c 3)
(dynamic d 4) 
```

也可以声明词法和动态范围的
函数。因为函数只是值，所以这里不需要
限制。此外，动态作用域函数可以有一些有趣的用途，比如处理异常。

这里有一些函数声明的例子:

```
(define (lex-fun b)
  (+ 10 b))
(dynamic (dyn-fun b)
  (+ 100 b)) 
```

如您所见，我试图尽可能地复制动态作用域的
词法作用域语法。

### [](#differences-between-lexical-and-dynamic-scope)词法和动态范围的区别

现在我想从实现的角度比较一下词法范围和动态范围。

两者之间有两个重要的区别。当函数
被创建时，只有创建的词法环境被保存在函数
中。这就像当你写一本书时:在它的整个
生命中，它会提到和它写的时候一样的事件。

下面是实现
`define`的`Evaluate`函数的代码片段:

```
"DEFINE" {
    if ($cdr.car.Type -eq "Symbol") {
        $name = $cdr.car.Value
        $value = Evaluate $cdr.cdr.car $env $denv $false
        $env.Declare($name, $value)
        return $null
    } else {
        # (define (<name> . <params>) <body>)
        $name = $cdr.car.car.value
        $params = $cdr.car.cdr
        $body = $cdr.cdr
        $function = (Make-Function $name $env $params $body)
        $env.Declare($name, $function)
        return $null
    }
} 
```

它是`switch`的一部分，所以第一行检查我们是否有
遭遇`define`。然后，我觉得代码很好理解。对于
`dynamic`来说，代码非常相似。它将动态环境
用于环境
的定义和专用函数，因为声明动态实体可能不同于定义
词法实体。为了不传递不必要的值给
，返回任一种方式`$null`。

另一方面，当函数被调用时，当前的词法环境
根本没有被使用，就好像我们想要将
函数与现在发生的事情隔离开来，并通过
只给出必要的值，让它以一种受控的方式存在。

与当前的词法环境相反，
动态环境的内容可以被函数使用，这就是它的
名称的来源:它是动态提供给函数的。

下面是用于调用用户自定义的
函数的`Invoke`函数:

```
function Invoke($function, $argsExp, $env, $denv, $tco) {
    $funVal = $function.value
    $params = $funVal.params
    $defEnv = $funVal.defEnv
    $denv.EnterScope()
    $argList, $dotValue = Eval-Args $argsExp $params.length $env $denv
    if (!$tco) {
        $defEnv.EnterScope()
        Extend-With-Args $argList $dotValue $function $defEnv $denv
        $result = Eval-Body $function.value.body $defEnv $denv $true
        $defEnv.LeaveScope()
    } else {
        Extend-With-Args $argList $dotValue $function $defEnv $denv
        $result = Eval-Body $function.value.body $defEnv $denv $true
    }
    $denv.LeaveScope()
    return $result
} 
```

代表当前词汇环境
的参数`$env`仅用于参数的评估。然后，使用在创建
函数期间保存的定义环境，而不是
它。另一方面，动态环境`$denv`按原样使用，并直接传递给`Eval-Body`函数。

### [](#tail-call-optimization)尾部调用优化

我的解释器 PowerScheme 也提供了一个
尾部调用优化的实现。当一个函数是
函数块的最后一个函数时，可以执行一个简化版本的调用。

在上面的`Invoke`函数中，你可以看到对于尾部调用，
是当`$tco`为真时，我们不进入也不离开定义
环境。我们简单地评估主体，就好像它是我们目前解释的代码的
延续。

这是`Eval-Body`函数，它决定
一个特定的评估是否是最后一次:

```
function Eval-Body($body, $env, $denv) {
    Define-Defines $body $env
    $cons = $body
    $result = New-Object Exp -ArgumentList ([ExpType]::Symbol), "NIL"
    while ($cons.type -eq "Cons") {
        $tco = ($cons.cdr.type -eq "Symbol")
        $result = Evaluate $cons.car $env $denv $tco
        $cons = $cons.cdr
    }
    return $result
} 
```

当我们有最后一个缺点时，它的`cdr`是`NIL`。那就是我们
的试验。当然，身体本身必须是
功能的最后一项。实际上，主体是执行尾调用
优化所需要的，因为主体有自己的作用域。而且由于解释器里没有
所谓的程序栈，我只需要
关心变量。当然 PowerShell 有一个堆栈，但是从这个代码开始，我不能强迫它执行尾部调用优化。对于
来说，这个项目尾调用优化仅仅意味着在不需要的时候
不会在环境中累积值。因此，
如果无法访问堆栈，真实的总体拥有成本很难实现。

`Define-Defines`的目的是确保给定词法级别的所有定义
对块中的每个人都可用。
我将在后面讲述它允许解决的更多问题。

### [](#environment-representation)环境表象

现在让我们看看环境是如何在程序内部表示的。当我编写我的第一个解释器 *MUSH* 时，我决定
使用散列表实现这个环境，其中键是变量
的名字和它们的词法层(词法层是避免
为函数保存定义环境的一种方式，所以每个变量
除了名字之外还被赋予了一个词法层)。值
是值的堆栈。后来我发现有几种其他的方式来表示环境:单个列表，或者每帧一个列表，等等。那么似乎每个名字有一个栈的想法是实现
环境的一种相当常见的方式。因此，与 Kotlin 解释器不同，我在这里使用了
每个词法层一个列表，我决定使用一个关联数组
的名字来存放值。

现在我将描述环境中的基本操作是如何执行的。

1.  变量声明。

    环境包含一个对应于当前
    词法级别的变量。如果变量是先前未声明的
    ，则在当前级别声明该变量；如果变量名和级别
    匹配，则该变量未被赋值。如果变量存在，但其级别低于
    当前级别，则新值将被推至旧值之上。它
    的意思是新值被放入数组，旧值被链接
    到新变量作为它的`next`值。

2.  变量更新。

    如果变量是通过名字查找的，并且找到了，它就被赋值了。
    很简单。

3.  变量查找。

    类似于 update:按名称查找并返回值即可。如果
    不在数组中，那么名字就不能被解析。

4.  输入范围。

    这是通过提高当前的词汇水平来实现的。也不是真的
    复杂。

5.  离开范围。

    删除当前级别的所有变量。它们被从栈中弹出
    ，如果是最后一个，名字从数组中移除
    。词汇层次降低。

### [](#branching-stacks)分支堆叠

这些不是在
环境中执行的唯一操作。还有一个叫做`Duplicate`的操作，它是在创建新函数时使用的
。环境的副本被制作，
不是深层副本，而只是数组的副本。这样做的原因是
如果数组后来被修改(例如父块结束并且
级别降低)，我们仍然可以在函数执行时访问我们需要的一切
。

这意味着变量栈现在可以有
分支。因为它不是深度拷贝，所以数组的所有对象都是相同的。新函数及其父函数可以在旧函数的
上添加新元素，从而创建分支。

### [](#definedefines)定义-定义

分支堆栈的一个含义是，一个函数不是在它自己的环境中
定义的，这对于递归和
互递归函数来说是一个问题。为了解决这个问题，我创建了一个名为`Define-Defines`的函数
。它在函数`Eval-Body`中的
模块评估之前使用。它快速扫描整个
块并寻找定义。当它找到时，用一个临时值将它们添加到
环境中。这个值不为空，它实际上是一个我称之为 cell 的结构，包含了定义的词法层、值和指向下一个单元格的指针。因此，当
函数被创建时，它复制了数组。并且还复制对单元格的引用
,而不是复制它，这很重要
,因为一旦评估了所有的定义，这些单元格被填充，并且
它们的新值对于函数和定义函数的块
都变得可见。

### [](#global-and-local-arrays)全局和局部数组

这个`Define-Defines`函数显示了顶层的
、零词法层和其他层之间的根本区别。其他级别的
可以在实际工作之前轻松地向前扫描，以便将
定义添加到环境中。另一方面，对于全球环境来说，这是不可能的，因为目前的区块正在不断扩大。

假设我想在顶层定义相互递归的函数。让我们以深度优先搜索树
为例，其中每个节点都有一个赋值和一个子节点列表
，子节点可以是空的。一个节点用一个`cons`表示，在`car`中有
号，在`cdr`中有列表。

所以，这是我的实现版本，它返回树中所有数字的总和:

```
(define (tree-sum tree)
 (let ((n (car tree))
       (sub (cdr tree)))
  (+ n (tree-sum-list sub))))

(define (tree-sum-list list)
 (if (null? list)
  0
  (+ (tree-sum (car list)) (tree-sum-list (cdr list))))) 
```

正如你所看到的，它有两个相互递归的函数，这并不奇怪，因为数据本身由两种类型组成:节点和列表。所以，`tree-sum`对应节点，`tree-sum-list`
对应列表。实现很简单。

那么，让我们来测试一下:

```
(tree-sum '(5 . ((6 . ()) (9 . ())))) 
```

这棵树返回 20。

另一个例子:

```
(tree-sum '(1 . ((2 . ((4 . ((8 . ()) (9 . ()))) (5 . ())))
                 (3 . ((6 . ()) (7 . ())))))) 
```

和预期的一样，这个函数返回 45。

现在让我们更仔细地看看相互递归的问题。
函数`tree-sum`复制了环境，其中
不包含`tree-sum-list`。它不会出现在那里，因为如果我们谈论的是 REPL，它还没有进入
。那么如何解决这个
问题呢？

当它是局部的东西时，我们可以向前扫描，寻找所有的
定义，但是在这里，它还不存在，所以我们不能这样做。一个
解决方案是将`tree-sum`存储在某种等待列表中，这样
在`tree-sum-list`被定义时，我们可以定义`tree-list`。如果它们不是相互递归的函数，这就容易了。

所以，这是我的解决方案:我们不复制全球顶级
零词汇级环境。我们只是说它是全球性的，对每个人都一样。这样当`tree-sum-list`被定义时，它
可以被`tree-sum`使用，因为`tree-sum`没有进行复制，
也没有试图将自己与外界隔离，所以它知道
正在发生什么，并且在需要的时候可以调用`tree-sum-list`。

### [](#declare-and-update-for-lexical-and-dynamic-variables)声明和更新为词法和动态变量

不，在我对 PowerScheme 实现细节的
概述中，还有几件事我想说一下，即
变量是如何更新的。

一个观察是动态作用域不能使用与词法作用域相同的方法来更新。有趣的是
注意到，词汇变量的读写在某种程度上是
对称的:当我们阅读时，信息流向我们，当我们
写作时，信息从我们这里流出。它使用相同的路径，就像钟摆一样。

另一方面，动态变量是不对称的。当我们读的时候，
我们或者从上面读，或者从同等水平读，但是我们只写
到当前水平。这就好比我们对待
信息的方式:我们可以读旧书或新书，但我们只能写新书。

为此，有两种不同的方法来更新
功能:`Update`用于词法环境，
`UpdateDynamic`用于动态环境。~UpdateDynamic
所做的是，首先检查数组中是否有我们想要
更新的变量，如果有，要么覆盖该值，如果它在
相同的动态级别，要么创建一个新值，同时链接到
先前的。

## [](#conclusion-about-the-implementation-details)关于实施细节的结论

所以这是我的方案实现的一个快速概述。有趣的是，当事情不像
预期的那样运行时，总是有很多不同的实施和惊喜的可能性。我认为通过实现这样的程序，
不仅可以理解 Scheme，还可以理解 Lisp 和实现所用的语言
。我想我已经描述了需要注释的
主要细节，并且没有解释
源代码的很多部分和 PowerScheme 的功能。

# power scheme 还能做什么

在这一节中，我将描述一些你可以用 PowerScheme 解释器做的有趣的事情。我在
中描述了特性和功能部分的预期用途。但是除了预期的用途之外，你经常可以用编程语言做一些
很酷的事情。

## [](#a-repl)一个 REPL

REPL 是指读取评估打印循环，它是一个程序，
连续打印从标准输入读取的评估值。它对于测试和交互式运行小型 Lisp 会话
很有用。

实现它的代码非常简单:

```
(define (toplevel)
 (writeln (eval (read)))
 (toplevel))
(toplevel) 
```

这是一个 REPL 会话的例子:

```
ZSH:gproj/scheme-lisp/chap02pwsh>pwsh PwScheme.ps1 tests/toplevel.scm
>: (let ((x 5) (y 3)) (+ x (* y 10))))
35
>: (define (lola x) (writeln 35) (writeln x))

>: (lola 40)
35
40

>: (exit)
EXIT invoked
ZSH:gproj/scheme-lisp/chap02pwsh> 
```

正如你所看到的，它的行为和普通的 lisp
差不多。但是它有一些限制:当有需要几行的
表达式时，它不起作用。

## [](#ycombinator)Y 组合子

Y-Combiantor 是一个函数，当应用于另一个函数
时，返回其定点。也就是说，该函数在应用于
值时会返回自身。

这对于在 lambda 演算中实现循环很有用:通过使
函数调用下一个值的参数，它可以
执行一些循环计算。这里有一个小块书里的 Lisp
的例子(当然在其他
书里还有很多其他例子，像加法、减法等等)。它计算
阶乘。

首先是 Y 组合子:

```
(define fix
  (let ((d (lambda (w)
           (lambda (f)
            (f (lambda (x) (((w w) f) x)))))))
  (d d))) 
```

下面是与`fix`函数一起使用的修改后的阶乘:

```
(define (meta-fact f)
 (lambda (n)
  (if (= n 0)
   1
   (* n (f (- n 1)))))) 
```

如您所见，它用下一个值应用它的参数。它的
参数是`meta-fact`的不动点，这意味着，它用更低的值再次产生
同样的调用。

下面是它的调用方式:

```
((fix meta-fact) 3)) 
```

这里重要的是`(fix meta-fact)`相当于`meta-fact`中的
`f`。

根据 fix 的定义，`(fix f) = (f (fix f))`。

所以，`((fix meta-fact) 3)`

等于`((meta-fact (fix meta-fact)) 3)`，

如果你把
(3)插入到`meta-fact`的定义中，那么它又等于`(* 3 ((fix meta-fact) 2))`。

并且继续这样，直到它返回阶乘的值。

## [](#function-objects)功能对象

如前所述，我的实现使用了词法范围。在这里
我想说明它最强大的用途之一，我
会说，它充分利用了词法范围和词法
环境。

事实上，在很多情况下，可以用全局函数代替闭包，或者像 Java 一样只允许传递常量值给闭包。所以为了说明
词汇环境的全部功能，我举了一个函数对象的例子，即
函数，它们有一个与之相关的环境。

```
(define (counter n)
 (let ((c 0))
  (lambda (cmd)
   (case cmd
     ((inc) (set! c (+ c n)))
     ((dec) (set! c (- c n)))
     ((pr) (writeln c)))))) 
```

这个函数的作用是返回一个接受
命令的函数。它将变量`c`初始化为(0)，并保存
参数`n`，该参数表示我们在
时刻想要修改`c`多少。

命令有`inc`将`c`增加`n`、`dec`将`c`减少
、`pr`打印当前值。

这就是为什么我发现 name function 对象非常适合这些
函数:它们包含字段(这里是`c`和`d`)和
方法(这里是`inc`、`dec`和`pr`)。

下面是一个如何使用它的例子:

```
(define cnt (counter 3))
(cnt 'pr) 
```

我们声明一个新的计数器，第 3 步`(cnt 'pr)`返回(0)。

让我们试着增加它:

```
(cnt 'inc)
(cnt 'pr) 
```

现在它打印(3)。让我们再增加一次，但这次是两次！

```
(cnt 'inc)
(cnt 'inc)
(cnt 'pr) 
```

不出所料，它返回(9)，也就是(3 + 2 * 3)。让我们看看
递减是如何工作的:

```
(cnt 'dec)
(cnt 'pr) 
```

它打印(6)。这意味着这些值被正确保存。

递减两次会使我们回到(0):

```
(cnt 'dec)
(cnt 'dec)
(cnt 'pr) 
```

# [](#what-is-missing)缺什么？

当然，Lisp 解释器不可能拥有所有的
特性。应该做出一些选择。在这一部分中，我将
描述我的 Lisp 实现中缺少的一些东西。
没有实现某个特性有几个原因。也许它
太复杂，在其他情况下它不是真的有用，或者我
没有时间实现它们。因此，在这里我将说几句
关于一些我认为值得谈论的
未实现的特性。

## [](#vectors)向量

让我们从矢量开始。事实上，对于一个最低限度的方案实现来说，它们并不是真正需要的。因为他们
能做的每件事都可以用结对和顺对来完成。比如读取一个
元素，设置一个元素，追加一个元素。在很多情况下，
列表有优势，因为它们更容易使用，也更容易
实现。向量的工作方式通常有点晦涩难懂，而且
通常感觉像是一种脱离 Lisp 并与操作系统的
底层实体通信的方式。我认为 Lisp
实现支持向量的主要原因是因为向量更快。列表
在大多数实现中都是链表(也许可以把
做得不同，但我认为这并不常见)。vectors 应该在幕后使用一个数组。由于这个原因，如果你想随机访问元素，它们会快得多，并且它们会占用更少的内存空间，因为它们不需要指向下一个元素的指针。所以实现它们是可能的，但这不在我的优先考虑范围内。对我来说，实现宏或延续会有趣得多。

## [](#let)让*

另一个我没有实现的特性是 let*。它在很多情况下也很有用，但是很多人不喜欢它。他们说
如果你使用它们，那么它变得更像命令式编程
等等。我真的不知道我是否能同意。也许
强加一个评估顺序的事实是不好的？但是对我来说，它更像是嵌套 let 的捷径，其中内层依赖于外层。所以我认为许多函数式编程语言允许这样的结构，这并不坏。所以，
总之我没有实现它，因为用嵌套的`let`替换它们很容易，而且它们不在那里也不会让人感到担心。

## [](#caar-and-so-on)Caar 等等

有很多这样的功能。真的很多。如此之多，以至于在我的 Kotlin 解释器中，我支持这些表达式的任意长度。是的，
你可以输入类似`caaaaaaar`的东西，它仍然会被
正确解释。但是在这个解释器中，要实现这个特性而不使代码变得不必要的复杂并不容易。所以我决定不做了。只有`car`和`cdr`，仅此而已。如果你想要更多，你只需要拿一个`cdr`的`car`或者一个`cdr`的`cdr`和
等等。大多数情况下应该够了。无论哪种方式，它们都有点令人困惑，不容易阅读，而且你不应该在编写代码时滥用它们。所以一个函数构图从时间到
时间都不会痛。

## [](#setcar-and-setcdr)Set-car！和 Set-cdr！

是的，这些也不在那里。这也许不是
应该做的事情，但是实际上，众所周知，不变性在
函数式编程语言中是一件好事。当你可以拥有同样的东西但是不可变的时候，你为什么需要可变的东西？因此，在我用于测试的代码的
例子中，根本不需要它。令人惊讶的是，你不需要使用这些或`set!`
和其他类似的功能就可以做很多事情。但是在我的实现中，`set!`是
实现的。即使这样也几乎从未使用过，所以修改
`car`或现有`cons`的`cdr`感觉不是正确的
事情。真的需要吗？可以避免吗？让我们换一种方式做这件事……等等。conses 已经以他们出生的方式出生了，让他们在别的地方变异感觉是错误的。这就是为什么
更容易容忍`set!`的原因，因为它修改了整个
值，它用另一个值替换了一个值，人们可以将其视为
永久阴影。

## [](#continuations)延续

我真的想实现延续。我花了很多时间思考它们的含义以及实现它们的方法。
人们说用
<sup id="ac05a6d7a93b970d1c352195724dbc39">[对抗 _callcc](#against_callcc "@misc{against_callcc,<br>
    title = {An argument against call/cc},<br>
    url = {http://okmij.org/ftp/continuations/against-callcc.html},<br>
    urldate = {2019-03-06},<br>
    keywords = {continuations, scheme},<br>
    file = {An argument against call/cc:/home/andrei/Zotero/storage/HKIRARSX/against-callcc.html:text/html}<br>
}")</sup> 没用而且危险，但在我看来这是个很有趣的
概念。这是查看执行流程的另一种方式。执行流是一个非常重要的概念，尤其是对编程语言和编译器感兴趣的人来说。也许延续看起来很复杂，因为执行流的工作方式还没有被很好地理解。Matt 可能称
为所有控制流
<sup id="38e133a1cd7512af65c3c2d0e08cf2b4">[continuations _ by _ example](#continuations_by_example "@misc{continuations_by_example,<br>
    title = {Coroutines, exceptions, time-traveling search, generators and threads: {Continuations} by example},<br>
    author = {Might, Matt},<br>
    url = {http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/},<br>
    urldate = {2019-03-07},<br>
    keywords = {continuations, scheme},<br>
    file = {Coroutines, exceptions, time-traveling search, generators and threads\: Continuations by example:/home/andrei/Zotero/storage/A4Q2DHAS/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines.html:text/html}<br>
}")</sup>中最不需要的。这不仅仅是一个抽象，
允许实现其他控制流结构。这是一个重要的
理论概念，反映了与控制流相关的
问题的有趣观点。

事实上，延续允许实现许多现有的控制流
机制。像例如，`goto`<sup id="fb86ca9c88ee182adb1381f2ae05aa3f">[Friedman _ applications _ 1988](#friedman_applications_1988 "Friedman, Applications of continuations, in edited by (1988)")</sup>，
`if`，循环，异常，协程<sup id="80d7d94a08c21b535d0282b28932cbc6">[Reynolds _ definitial _ 1998](#reynolds_definitional_1998 "Reynolds, Definitional interpreters for higher-order programming languages, in edited by (1998)")</sup>
等等。但是这些结构在第一次出现时并没有用延续定义。后来证明，有了延续，
就有可能实现它们。所以我的想法是这样的。如果我们
足够好地理解延续，也许我们可以提出
其他还没有描述的控制流机制。而这个
的想法似乎很有趣。因为我们没有很多这样的
机制，而且它们都是不同的，不是很有组织性。因此，如果
我们至少学会了如何对它们进行分类，并找出在什么情况下需要哪种
控制流，我们就可以定义其他更适合我们当前问题的
控制流机制。

那么什么是延续呢？如果你读了一些关于它的信息，你会发现理解它们的第一步相当困难。每个人对它们的描述都不一样。人们似乎在谈论
不同的事情。有的把它们看做跳跃，从
组装角度描述<sup id="8c65371f0890cafb32d166636ae9c2f4">[Reynolds _ discoveries _ 1993](#reynolds_discoveries_1993 "Reynolds, The discoveries of continuations, {LISP and Symbolic Computation}, v(3-4), 233--247 (1993).")</sup>。其他人
认为它们是一种在计算中保存一个点的方法，而其他人
认为这是一种暂停程序并在以后继续的方法。
例如乔治·斯普林格称它们为*其余的
计算*。<sup id="66354b446824fe7b5ff348e76d47facc">[springer _ scheme](#springer_scheme "Springer \& Friedman, Scheme and the {Art} of {Programming}, ().")</sup>所以要找到所有
这些概念的共同点并不是那么容易。而且，所示的例子通常
有 3 或 4 个嵌套的 lambda 函数，这本身就不容易
理解。所以现在我会给你一个快速的描述什么是
延续。实际上，我希望在下一个
项目中实现它们，我将为 Lisp 的第三章做一些小片段。然后我会尽可能详尽地描述它们。所以我
这次就不多说了。

延续是执行中的一个要点。如果你有一个虚拟机
正在运行，你暂停它，然后复制它，这不是
什么是延续。延续只关心执行，而不关心数据。所以这就像你回到了过去，但
只有你，整个世界继续它一直以来的样子。换句话说，延续类似于标签的地址。延续的一个很好的例子是异常和 wiki C2 _ call`longjmp`
<sup id="9c8c2c5116eab591c2f5c88c44eee2ad">[。你不会真的回到过去。
已经改变的数据不会恢复到之前的状态。但是你会回到你之前的位置。延续事实上比那更一般，但是这些是延续如何工作的好例子。](#wikic2_call "@misc{wikic2_call,<br>
    title = {Call {With} {Current} {Continuation}},<br>
    url = {http://wiki.c2.com/?CallWithCurrentContinuation},<br>
    urldate = {2019-03-01},<br>
    keywords = {continuations, scheme},<br>
    file = {Call With Current Continuation:/home/andrei/Zotero/storage/IVGDBV88/wiki.c2.com.html:text/html}<br>
}")</sup>

然后我想找到一种方法将它们包含在解释器中。
我想我会怎么做。我的推理是这样的:我
可以保存下一个要执行的`cons`。
代表延续是个好办法吗？答案是否定的。我也许可以完成一个程序块的
执行，但是接下来我该做什么呢？这个程序块没有告诉我下一步该做什么。它能告诉我什么？它必须通知我它从哪里来，当它结束时它想做什么。但是
为什么是块必须有这个信息？因为
延续可以在程序的任何一点进行，而且
不可能知道每个人的一切。所以这是
正在执行的项目，它必须知道下一步要做什么。但是它怎么知道呢？它本身什么都不知道。
调用的是它的调用者，它会在当前块返回后决定怎么做。如你所见，事情变得复杂了。事实上，决定下一步做什么的并不是呼叫被叫者的呼叫者
。被调用者
必须记住下一步是什么，并告诉调用者
，以便它执行需要执行的内容。正如你所看到的，这与到目前为止所有的东西是如何写出来的完全相反。所以，
让我们试着再想一次，如果我在我的实现中添加了
延续，会是什么样子。调用者知道当被调用者返回时必须做什么，所以它告诉被调用者下一步必须做什么
。然后，呼叫方可以忘记它告诉被叫方的所有事情，因为要由被叫方来记忆。当被调用者
返回时，它对调用者说*你好*，并说，你想在我返回时做
这件事。然后调用者执行它。从这个例子
你可以看到，当
被调用者返回时，执行随后发生的事情的那个不一定是最初的调用者。可以是一个
简单的循环，读取下一个动作并执行。在这种
情况下，实际上可以保存延续并将
存储在计算中。而当用户需要的时候，他就可以执行。由于这些原因，我没有在我的解释器中实现它们。如果我想让一切保持原样的话,
会让事情变得太复杂。所以也许有更好的策略来实现
延续。

我这里描述的类似于 Hayo Thielecke 所说的
*延续传球风格*<sup id="b08a5828a0696686c7bba7da048f0bf7">[Thielecke _ continuations](#thielecke_continuations "@misc{thielecke_continuations,<br>
    title = {Continuations, functions and jumps},<br>
    shorttitle = {Logiccolumn8.pdf},<br>
    url = {http://www.cs.bham.ac.uk/~hxt/research/Logiccolumn8.pdf},<br>
    urldate = {2019-03-04},<br>
    author = {Thielecke, Hayo},<br>
    keywords = {continuations},<br>
    file = {Logiccolumn8.pdf:/home/andrei/Zotero/storage/3WF4RVGG/Logiccolumn8.pdf:application/pdf}<br>
}")</sup>。下一个要执行的事情被系统地传递给被调用者。而这个
方式，为了存储一个延续，需要做的就是复制
栈。因为这些下一个点被存储为每个
函数的参数，并且每个函数都有其
调用者传递的下一件要做的事情。

## [](#exceptions)异常情况

说了一些关于延续的话，我现在要说为什么我没有实现异常。异常实际上比延续更容易实现。目的是执行一个处理程序和
,直到处理程序被设置的层次。
它可以通过保存设置异常处理程序的点
用 continuations 来实现，也可以通过
返回一个特殊值来实现。然后调用者检查并看到值
并将其返回给调用者，直到
处理异常的专用函数。如您所见，这个实现还需要对代码进行大量的修改。

## [](#macros)宏

在 Common Lisp 中，最有趣也最复杂的特性之一
是宏。从其他编程语言的角度来看，它们允许做一些真正不寻常的事情。我没有
很多使用宏的经验。我或多或少知道它们是如何工作的:
它们接受参数而不评估它们，用参数调用使
成为某种东西的主体，然后主体必须生成一个
表达式，然后被评估。听起来很容易。但是我不知道是否有足够的例子来测试它们是否正常工作。还有另外一个问题:我正在编写一个 Scheme 解释器，而不是一个普通的
Lisp 解释器，这意味着测试它们甚至会更复杂，因为我对 Scheme 中的宏了解得更少。
而这个问题，与延续相反，我不会马上尝试
解决。我已经看到 Lisp 中的其他章节以小块
处理宏(主要是第 9 章)。

# [](#conclusion)结论

因此，作为这篇文章的结尾，我将说几句话，谈谈这个项目给了我什么，它让我学到了什么，以及完成这个项目后，我可以从这里去哪里。

第一次用 PowerShell。如果不是为了这个项目，很难想象是什么激励我学习这门语言。不是因为我不觉得有趣，也不喜欢学习新的
事物。更多的是因为我发现很难为新的
项目找到想法，尤其是如果它是 PowerShell 这样的 shell 语言，而
在功能方面似乎没有太大的革命性(这或多或少是我还没有学会 fish 的
原因)。我知道 PowerShell 经常被描述为第一种使用管道和对象的语言，但是我发现这不过是一点额外的东西，就像语法上的糖，或者一个有趣的玩具。尽管我从理论上理解
对于某些任务来说它可能是多么具有革命性，但我并没有在 Linux 上过多地使用管道
来错过面向对象的功能，
此外，它在我当前的
项目中并没有起到至关重要的作用。

所以，我写了我的第三个解释器，和我的第二个 Scheme
解释器。我的第一个翻译是 *MUSH* ，是 CCP 和
PL/M 的混搭。我真的很喜欢这个结果。我想我会重新实现它一个
更多的时间与更多的功能。我的第二个解释器是 Scheme，我用的是 Kotlin。所以这是我的第三个。我实际上开始
来看一个模式。我想我开始理解解释器的一些主要结构组件，以及应该如何编写它们。当然，我仍然是一个初学者，为了在这个领域感到舒适，我还需要写一些解释器和编译器。

我已经设法写了一个解释器，在我看来,
可以做一些相当有趣的事情:它有`letrec`，可以做
相互递归。由于某些原因，我的测试对球拍和诡计都不起作用。也许我实现了一些正常方案中不打算实现的东西…

相互递归也可以在
顶层或本地层使用`define`语句来完成。

解释器也有高阶函数，我仍然
认为这些函数相当神秘和危险，至少在试图
在解释器中执行它们的时候是这样。

还支持函数对象。也就是说，我可以创建一个
计数器函数，通过向函数传递不同的消息，我
可以操作计数器:增加它的值，打印它的值等等
。它让这个功能物体莫名其妙地类似于一个活着的
有机体，这有点怪异，不容易描述。

我的解释器可以做的另一个例子是 y 组合子。这也是你可以在我的解释器的源代码目录中的
例子中找到的东西。
这也是每次我看到它工作时，让我
想知道它怎么可能工作的原因。当我看到
打印出正确的答案时，我仍然感到惊讶。

这个项目让我学到了一些有趣的概念。
例如，这是我第一次尝试用
尾调用优化来做一个解释器。现在我看到它有两个部分:数据和
控制流。他们没有必然的联系。

检查词法作用域
和动态作用域之间的差异是很有趣的:当创建一个
函数时，词法环境是如何传递的，但是当调用
函数时，动态环境是如何传递的。理解这些概念的一个好方法是
比较它们。没有比
更好的比较方法了，把两者都包含在同一个项目中！有必要认识到，
动态范围不是一个容易出错的东西，应该
避免。词法范围和动态范围都有意义，而且都是复杂的概念。危险的是带着对方的心态去接近对方。那么我们很容易迷路。但是就其本身而言，
动态范围是非常符合逻辑的、有用的，并且就其本身而言，是完全连贯的。理查德·斯托尔曼说，它允许做一些事情，否则在实际中不可能做的事情。

我最初没有计划做的事情是异常处理部分。通过阅读更多关于异常处理与动态范围相关联的方式，我意识到如果我
实现它也没那么糟糕。但是由于我没有延续和长跳转，我唯一能做的
就是*使程序崩溃*，这就是为什么我的解释器中的
异常处理程序被称为*崩溃程序*。

在实施了所有这些事情之后，我意识到仍然有很多事情需要改进。
这是一段有趣的旅程，每次我完成这样一个项目
都会有更多有趣的改进机会。

当然，显而易见的是，类型系统非常有限。
不仅缺少向量，使用向量的例子
非常容易找到，而且浮点数和
分数也很有用，以及对非常大的
数的支持，这是一些语言所支持的。

还可以包含一些在 Lisp 传统中很重要的特性:延续和宏。我接下来将要阅读的《小片段 Lisp》一书的第三章涉及到了
延续，所以我打算将它们包含在下一个解释器
的实现中，我决定在 Swift 中这样做。

另一件有趣的事情是做一个 Scheme 编译器。将编译代码和解释代码结合起来也是 Lisp 的传统。Lisp 起初是一种完全解释的语言，但是
很早就有编译器了。所以编译代码和解释代码
在 Lisp 的整个历史中是并行的，以它的许多
形式:MacLisp、Common Lisp、Racket、Emacs Lisp 等等。因此，如果不同时使用解释器和编译器，似乎就不可能理解和欣赏 Lisp。

所以，这是这篇关于 PowerScheme 解释器的帖子的结尾，我希望你喜欢阅读它，下一篇帖子再见。

# [](#bibliography)参考书目

【Queinnec _ lisp】Queinnec，Lisp 小片段，。 [↩](#520a1805e2957b91051e499a55918b81)

【given _ re:_ 2009】@ misc given _ re:_ 2009，
title = Re: Coroutines and Go，
URL =[http://lua-users.org/lists/lua-l/2009-11/msg00576.html](http://lua-users.org/lists/lua-l/2009-11/msg00576.html)，
urldate = 2019-03-24，
author = Given，David，
month = nov，
year = 2009，
keywords = compilers，
[↩](#216a89084fe47ba313861b0a64a9dbd7)

【Graham _ roots _ 2002】@ misc Graham _ roots _ 2002，
title = lisp 的根，
author = Graham，Paul，
month = jan，
year = 2002，
[↩](#3beab3c5c207c3c1ab618cbd0a12a0a8)

【Jones _ Learn _ 2017】琼斯&希克斯，用一个月的午餐学习 Windows PowerShell，曼宁(2017)。 [↩](#220428e48f1fa84778351fd1ac9437e5)

【The _ devo PS _ Collective _ Monad _ 2016】devo PS Collective，The Monad Manifesto，Annotated，Leanpub (2016)。 [↩](#456b887553631891bf21f8255f316cf5)

【wiki 2 _ homo iconic】@ misswikic 2 _ homo iconic，
title = Homoiconic Languages，
URL =[http://wiki.c2.com/?HomoiconicLanguages](http://wiki.c2.com/?HomoiconicLanguages)，
urldate = 2019-03-09，
keywords = lisp，
[↩](#5d71417e23001a0ba429f599b4580b67)

【Tanter _ Beyond】Tanter，超越静态和动态范围，*，11。 [↩](#9361e0bd08c4091cedfc72c12e00ee47)*

 *【帕耶特 _windows_2007】帕耶特，Windows PowerShell 在行动，曼宁；培生教育[经销商](https://dev.to2007)。 [↩](#bc24fab90f95f459a9c20cc3d8e7a767)

【反对 _callcc】@错误反对 _ callcc，
title =反对 call/cc 的论点，
URL =[http://okmij.org/ftp/continuations/against-callcc.html](http://okmij.org/ftp/continuations/against-callcc.html)，
urldate = 2019-03-06，
关键词=延续，方案，
[↩](#ac05a6d7a93b970d1c352195724dbc39)

【continuations _ by _ example】@ miscontinuations _ by _ example，
title =协同程序、异常、时间旅行搜索、生成器和线程:按示例继续，
author = may，Matt，
URL =[http://matt . may . net/articles/programming-with-continuations-exceptions-backtracking-search-threads-generators-coroutines/](http://matt.might.net/articles/programming-with-continuations-exceptions-backtracking-search-threads-generators-coroutines/)，
urldate = 2019-03-07，
关键字= continuations，scheme

【弗里德曼 _ 应用 _1988】弗里德曼，延拓的应用，编于(1988) [↩](#fb86ca9c88ee182adb1381f2ae05aa3f)

【雷诺兹 _ 定义 _1998】雷诺兹，高级程序设计语言的定义解释器，编辑于(1998) [↩](#80d7d94a08c21b535d0282b28932cbc6)

【雷诺兹 _ 发现 _1993】雷诺兹，《延拓的发现》， *LISP 与符号计算*， **6(3-4)** ，233-247 (1993)。[链接](http://link.springer.com/10.1007/BF01019459)。[土井](http://dx.doi.org/10.1007/BF01019459)。 [↩](#8c65371f0890cafb32d166636ae9c2f4)

【施普林格 _ 方案】施普林格&弗里德曼，方案与编程的艺术，。 [↩](#66354b446824fe7b5ff348e76d47facc)

【wiki C2 _ call】@ misswikic 2 _ call，
title =呼叫当前继续，
URL =[http://wiki.c2.com/?CallWithCurrentContinuation](http://wiki.c2.com/?CallWithCurrentContinuation)，
urldate = 2019-03-01，
关键字=继续，方案，
[↩](#9c8c2c5116eab591c2f5c88c44eee2ad)

【thielecke _ continuations】@ misthielecke _ continuations，
title = Continuations，functions and jumps，
short title = Logiccolumn8.pdf，
URL =[http://www.cs.bham.ac.uk/~hxt/research/Logiccolumn8.pdf](http://www.cs.bham.ac.uk/%7Ehxt/research/Logiccolumn8.pdf)，
urldate = 2019-03-04，
author = Thielecke，Hayo，
关键词= Continuations，
[↩](#b08a5828a0696686c7bba7da048f0bf7)

【stallman _ emacs:_ 1981】stallman，emacs:可扩展的、可定制的显示编辑器，由(1981) [↩](#b05c615e43a6b1cd31b76c84ca79dd8a) 编辑*