# 控制你的。dockerignore 文件

> 原文：<https://dev.to/youknowfordevs/getting-control-of-your-dockerignore-files-50m4>

我不时会注意到 Docker 容器中有一个不应该存在的文件。幸运的是，它从来不是一个`.env`文件或 SSH 密钥，但即使如此，任何未使用的文件或目录都会占用映像中的空间，使映像构建和传递速度变慢。最佳实践建议使用经常被忽视的`.dockerignore`文件来保守我们的秘密，并确保我们的 Docker 图像尽可能精简。但是随着排除列表的增长，这个文件通常会成为维护的噩梦。

这篇文章展示了如何通过指出哪些文件我们希望*包括*而不是那些我们希望*排除*来控制`.dockerignore`。

# 目标

一段时间以来，我一直试图想出一个简单的方法来排除不必要的文件从我的 Docker 图像。显然，我想保密，我想防止任何未使用的目录在构建时被转移到 Docker 守护进程——它们会减慢构建速度并增加生成图像的大小。

但是我也想找到一种方法来排除与构建过程本身相关的文件，比如`Dockerfile`和`docker-compose.yml`；如果它们被转移到一个图像中，这是不必要的混乱，如果它们根本不被包括在内，那就更好了。如果你想通过 Docker Hub 这样的公共渠道分享一张图片，同时保持图片来源在你的组织内部，这就更重要了；在这种情况下，这些构建文件中可能有私有信息，您肯定不希望它们被共享。

最后一个要求是，当我们在忽略规则上犯了错误时，我们想知道它。通常使用的方式是，如果你错误地将类似‘git’的东西作为模式放入文件，而不是‘git’。git '，除非您发现有大量数据被转移到您的构建中，否则您对此一无所知。

这篇文章的其余部分着眼于我们如何解决这些问题。

# 方法 1:从单个目录构建

我在过去一年左右尝试的大多数方法都围绕着组织项目目录的不同方式。有很多方法可以组织一个项目，但是总的来说，方法是尽量保持源代码、测试、文档、生成的文件以及项目中的任何其他部分相互分离。

作为这种分离的一部分，我们还希望确保任何我们不希望出现在 Docker 映像中的目录被设置为我们希望包含的主目录的*对等点*。这仅仅意味着，我们将把`app`、`docs`和`test`并列作为顶级目录，而不是把`app > docs`或`app > test`作为我们的目录。

通过拥有一个包含构建中需要的所有文件的目录，并将其他所有文件安全地保存在其他目录中，我们至少开始降低错误复制重要或不必要文件的风险。

## 设置上下文

一旦我们的目录组织好了，那么设置 Docker 构建上下文来引用应该包含在 Docker 映像中的单个目录就很简单了。通过将上下文设置为一个子目录，我们已经确保排除了所有其他目录，无论它们是`.git`、`node_modules`、文档和测试，等等。

然而，这种方法的缺点是，由于构建上下文必须包含 Docker 构建映像所需的所有内容，不幸的是，这意味着我们也需要将`Dockerfile`放在我们的源目录中。

## 无视与`.dockerignore`

通过创建一个`.dockerignore`文件，然后向其中添加‘docker file ’,很容易阻止`Dockerfile`被复制到映像中。`.dockerignore`文件是一个“忽略文件”,它告诉构建过程在将上下文转移到 Docker 守护进程时应该忽略哪些文件。对于这种情况，可以像这样简单:

```
# In .dockerignore
Dockerfile 
```

不要担心这会妨碍整个构建过程。在`Dockerfile`的情况下，无论我们是否排除它，Docker 仍然会把它传递给守护进程来指导构建过程。但是通过将它添加到我们的忽略文件中，我们阻止了它在整个过程中继续前进；即，它将不能被复制到映像中。

当然，如果我们将一个`.dockerignore`文件添加到我们的源目录，那么 Docker 守护进程将可以使用它，所以我们现在也需要忽略它:

```
# In .dockerignore
.dockerignore
Dockerfile 
```

## 方法 1 的问题

尽管这是一个很好的简单的解决方案，但是仍然不能说我们不会不小心将一些我们不想要的东西复制到图像中。例如，在我们的笔记本电脑上开发代码时，我们可能会在源目录中有一个充满数据库密码和服务器名称的`.env`文件。如果我们忘记排除`.env`文件，那么它很可能会被复制到我们的映像中。

我也不喜欢把 Docker 相关的文件和源代码放在同一个目录中，因为它是混合层的——我们应用程序的源文件现在和构建我们应用程序的指令放在一起。都有点‘meta’了。

# 途径二:更丰富的`.dockerignore`文件

所以下一步是将构建文件放在主目录之外，将它们移动到项目的根目录。如果我们这样做，那么我们必须将项目的根作为“构建上下文”，这意味着我们现在向 Docker 公开我们所有的文件。为了排除我们前面提到的对等目录，我们将进一步修改 ignore 文件，如下所示:

```
# In .dockerignore
.dockerignore
Dockerfile
dist
docs
test 
```

如果我们想要放入映像的代码在`app`目录中，那么这个`.dockerignore`文件将允许复制那个目录，但是将排除`dist`、`docs`和`test`目录。

## 方法 2 的问题

但是当我们排除测试和文档时，我们也应该排除我们的`.git`目录(以保持较小的尺寸)和其他构建文件，比如`docker-compose.yml`和`.gitlab-ci.yml`(以保持私有)。现在我们的忽略文件看起来像这样:

```
# In .dockerignore
.git
.gitlab-ci.yml
.dockerignore
dist
Dockerfile
docker-compose.yml
docs
test 
```

这种不断增加忽略文件的方法是有效的，你会发现许多博客文章准确地描述了我们在这里所做的事情。但是，继续排除映像中不需要的所有文件和目录很快就会变得非常非常乏味，过一会儿，您会发现自己对任何暴露的或无意中复制进来的“无害”文件视而不见。

但这意味着我们又回到了起点，因为我们无法*真正确定*我们没有复制不应该存在的东西，或者我们创建的图像不能再小了。

幸运的是，事实证明有一种更简单的方法来维护这些排除，而且非常简单。

# 方法#3:定义*包含*，而不是*排除*

众所周知，`.dockerignore`文件包含了要排除的文件模式列表。但是不仅仅是 T2 包含了这些。忽略文件还包含一个*不*排除的文件模式列表。

假设我们有一个满是 Markdown 文件的博客，我们想从我们的图像中排除这些文件，因为它们会被预先转换成 HTML，因此在运行时是不必要的。但是让我们说，我们仍然希望包含我们项目中的`README.md`文件，因为它可能会帮助任何人了解一个正在运行的容器。我们可以通过在一个`.dockerignore`文件中添加以下条目来实现这个目标:

```
# In .dockerignore
# Exclude all Markdown files:
#
*.md

# Now make an exception for one file:
#
!README.md 
```

有了这个文件，当 Docker 启动构建过程时，它将传递给守护进程的唯一 Markdown 文件是`README.md`文件。

## 排除一切

那么，我们为什么不利用这个特性，在每个`.dockerignore`文件的开头加上一个语句*来排除所有的*？如果我们一开始就说*没有什么*会在构建映像时被发送到 Docker 守护进程，那么我们几乎不可能意外地包含任何秘密或不必要的东西。

我们需要在`.dockerignore`文件中忽略一切的模式只是一个星号:

```
# In .dockerignore
# Exclude everything:
#
* 
```

当然，如果我们在构建图像时排除了所有东西，那么不仅仅是我们的秘密没有被复制进去…没有任何东西会被复制进去！这就像根本不参赛就一定不会输掉比赛一样。

所以现在我们需要用我们*做*想要包含的文件的信息来扩展我们的`.dockerignore`文件。

而那些文件应该只是我们`Dockerfile`中提到的那些。

## 仅包括`Dockerfile`中引用的文件

假设我们正在构建一个节点应用程序。让我们假设我们在`Dockerfile`中遵循最佳实践，在一层安装所有的依赖项，在另一层安装我们的源代码。

“安装依赖项”步骤可能如下所示:

```
# In Dockerfile
# Copy dependency definitions and then install:
#
COPY package.json .
ENV NODE_ENV=production
RUN npm install 
```

而“复制源”步骤可以像这样简单:

```
# In Dockerfile
# Copy our app:
#
COPY app/ . 
```

当用这个`Dockerfile`构建 Docker 镜像时，Docker 守护进程必须能够访问`package.json`文件和`app`子目录。因为我们已经排除了 ignore 文件顶部的所有内容，所以构建过程中引用的每个文件或目录都必须明确允许通过。

我们可以轻松地将这些文件添加到我们的。`dockerignore`具有“不排除”模式的文件:

```
# In .dockerignore
# Exclude everything:
#
*

# Now un-exclude package.json and the app folder:
#
!app
!package.json 
```

就这样…我们结束了。Docker 守护进程不会接收`.git`或测试目录，或`.env`，或`.gitlab-ci.yml`，或`Dockerfile`，或`docker-compose.yml`或其他任何东西。

现在我们所要做的就是保持文件`.dockerignore`和`Dockerfile`同步——也就是说，确保它们都指向相同的路径和文件——并且没有其他东西会意外地进入我们的 Docker 映像。

这种方法的一个很好的特点是，如果我们忘记添加一个规则，我们会听到它。如果我们在`Dockerfile`中指出我们想要在`README`或`LICENSE`中复制:

```
# In Dockerfile
# Copy our app and the license:
#
COPY app/ .
COPY LICENSE . 
```

除非我们将`LICENSE`添加到`.dockerignore`文件中:
，否则我们将在构建时得到一个错误

```
# In .dockerignore
# Exclude everything:
#
*

# Now un-exclude package.json and the app folder:
#
!app
!LICENSE
!package.json 
```

事实上，我们需要在我们的`.dockerignore`文件中指定我们想要*包含什么*的模式只是我们的`Dockerfile`中的`ADD`和`COPY`条目，这比试图跟踪需要排除什么要简单得多。

## 方法 3 的问题

虽然这是我的首选解决方案，并且解决了很多问题，但是仍然有一些缺点。尽管如果我们在`.dockerignore`文件中遗漏了一个重要的规则，构建过程会通知我们，但是如果我们的规则过于宽松，我们*不会通知*。所以在我们上面的例子中，如果我们后来决定在构建时不复制`LICENSE`文件，没有任何东西告诉我们可以从`.dockerignore`中移除模式。

此外，我们还需要记住不要在`app`目录中留下任何可能被复制的内容。碰巧的是，我之前给出的一个`.env`文件的例子(方法#1)现在没什么问题了，因为它最好保存在根目录中。

# 结论

这些年来，我已经尝试了一些不同的解决方案，但是我认为这种“包含文件”的方法是最简单的，也是最容易维护的。如果“排除所有内容，然后取消排除您想要的文件”的概念看起来有点古怪，只需颠倒一下，将`.dockerignore`文件视为“包含”文件即可——换句话说，将其视为“只有列出的文件才会包含在构建中”。

我想如果这是 Docker 的默认行为，我会更喜欢，因为这样我们就可以得到安全和最小图像尺寸作为默认行为，开箱即用。但是除非 Docker 很快增加一个`.dockerinclude`特性，否则这里描述的解决方案将会是最好的。