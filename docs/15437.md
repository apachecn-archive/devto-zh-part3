# 真实世界测试:使用业务和技术需求来了解要测试什么

> 原文:[https://dev . to/ccleary 00/real-world-testing-using-business-and-technical-requirements-to-know-to-test-1d6f](https://dev.to/ccleary00/real-world-testing-using-business-and-technical-requirements-to-know-what-to-test-1d6f)

***原载于 [coreycleary.me](https://www.coreycleary.me/real-world-testing-using-business-and-technical-requirements-to-know-what-to-test/)** 。这是我的内容博客的交叉帖子。我每一两周发布一次新内容，如果你想直接在收件箱里收到我的文章，你可以[注册我的时事通讯](https://www.coreycleary.me/about/)！我也定期发送备忘单和其他赠品。*

这是我正在进行的系列文章的下一篇，通过将**方法**应用到**真实场景**来了解在节点应用程序中测试什么。

在第一篇文章中，我们回顾了从节点服务调用数据库时，您应该在测试中涵盖的[场景。](https://dev.to/ccleary00/know-what-to-test-using-these-recipes-node-service-that-calls-a-database)

在第二篇文章中，我们介绍了当您的应用程序调用外部 API 时，为[编写测试的场景。](https://dev.to/ccleary00/real-world-testing-recipes-node-service-that-calls-an-external-api-134m)

这篇文章将与前两篇略有不同，但仍然覆盖相同的领域。

最终，本系列的目标是确定您应该在某些场景中测试的常见事物。因为通常**很难**确切知道**要考什么**。作为一名开发人员，你会遇到足够多的常见场景，因此你有可能找到一组通用的东西来编写测试。这样，当你有很多其他的开发工作要做的时候，你就不必浪费时间绞尽脑汁去想应该写什么样的测试。

但是，当您遇到本系列之外的场景时，该怎么办呢？或者更具体地针对您的应用程序的独特性的场景呢？

### 使用需求来派生您的测试

解决方案在于使用文档化的业务和技术需求来派生您的测试。

这看起来似乎很简单，但是它会让你在编写测试时走得更远。这很好，因为我们希望编写测试变得容易！

至于术语——没有明确的界限来区分什么是**【业务】**需求，什么是**【技术】**需求。出于本文的目的，我们将它们大致定义为:

*   业务:从用户的角度撰写(通常由业务分析师或产品经理撰写)
*   技术:从应用程序的角度编写(通常由开发人员、系统分析师或架构师编写)

很明显，有时开发人员身兼数职，没有 BA 或 PM，但是开发人员仍然可以提出属于上述一个或两个类别的需求。

谁编写了需求并不重要，但是理解它们可能属于那些类别中的一个是很重要的，因为它们是如何编写的将会影响你将从它们中得到的测试用例。

关于这一点:如果业务分析师或产品经理没有给你明确的需求，那该怎么办？或者如果这是你的副业，而你根本没有 BA 或 PM 呢？我认为你总是有需求的，即使它们是“不言而喻的”或“隐含的”,而不是记录在像吉拉这样的项目计划工具中。还有一些方法可以找出那些“明确的”需求是什么，但是这已经超出了本文的范围。

### 该过程

1.  将需求转化为技术/代码需求
2.  为应该发生的事情编写测试——愉快的路径(正常的用例，没有错误，没有空的东西返回，等等)。)
3.  针对不应该发生的情况编写测试-不愉快的路径(返回错误、找不到项目、返回空数组等)。*注意:可能并不总是适用！*

第一步是每个开发人员在实现一个特性时要做的事情。接受一个需求，然后思考如何在高级代码中实现它，这基本上就是编写软件的方式。但是我把它包括进来是为了指出，有时你可能会得到一个你不能立即写测试的需求，而是需要先“分解”。测试仍然是从需求中**派生出来的**,但是你可能需要先做一些准备工作。

例如，假设您有一个类似“用户应该能够登录到应用程序”的需求。显然这是一个非常宽泛的要求。当你在代码中实现这一点时，你很可能不会仅仅写一个“应该能够登录到应用程序”的测试(尽管这将是一个很好的端到端测试，我稍后将会谈到)。

相反，您可能会将它分解为一些技术/代码需求，比如“好吧，如果用户应该能够登录到应用程序，首先我需要一个服务器路由来检查他们的用户名/密码并让他们登录。我还需要在 UI 上输入用户名和密码，并通过表单将它们发送到服务器。这些输入可能需要一些客户端验证，以确保用户不能传入会破坏我们的数据库、检查跨站点脚本等的坏字符。

现在，即使我们没有直接从需求*中编写测试，我们也是基于需求和从需求中派生出来的需求进行测试的。*

对于一些需求，特别是如果它们本质上更具技术性，你将能够基本上直接从需求中编写测试，而不需要太多的“准备工作”。但是过程是一样的。

我建议总是首先编写快乐路径测试，*然后是*相关的不快乐路径测试。理想情况下，快乐的路径是用户最应该遇到的，所以我们希望设计的代码首先满足这一点。然后，当我们实现不愉快的路径时，假设这与我们的需求相关，如果我们需要对代码进行任何更改来支持它，我们可以这样做。

还有一个术语注释——“不愉快的路径”，你有时会听到它的意思是“错误”路径，比如抛出的错误/服务器关闭等。我在这里使用它的方式更宽泛一点，不仅描述错误，还包括在需求的上下文中返回的空数组(可能数据库没有返回结果)和不应该发生的事情。例如，未登录的用户不能保存偏好设置。

这看起来似乎很简单，但这是我用来生成大量**有意义的**测试的过程。这似乎是显而易见的，但是编写测试来说明*意味着*什么才是最重要的。

这件事的好处是它对 UI 和服务器端测试都有效。

### 浏览一个例子

让我们看一个例子。

示例需求将针对我们正在构建的为类似亚马逊的网络商店获取产品的功能:

**“作为用户，我应该能够:“**

*   根据我搜索的内容，在页面上查看多达 50 种产品
*   首先按最新产品排序
*   查看首先显示的打折产品，在其他不打折的产品之前
*   如果我已登录，我应该可以看到我的收藏夹中的项目

我将列出我为第一个和第二个需求编写的测试，你可以用第三个和第四个来练习。

请注意，虽然您可以编写许多不同的测试，但这些是我第一次编写的。你可能会想到更多！

我还会讲述前几个测试的过程，这样你就可以知道我会怎么想了:

> 好的，要求是用户需要能够根据搜索词在页面上查看 50 个产品。这并不太宽泛，但是从技术角度来看，这看起来像什么呢？这如何转化为技术需求？显然，我需要服务器根据搜索词从数据库中提取 50 个项目。这听起来是一个不错的技术要求。

`it('should return 50 products max based on searched item')`

> 现在，如果返回的不是 50 件商品，而是 23 件，会怎么样呢？

`it('should return as many products as search finds')`

> 太好了，如果没有商品被退回怎么办？

`it('should return empty array if no products found')`

> UI 还需要显示这 50 种产品，这可能更像是一个集成或 E2E 测试，但我可能应该这样写:

`it('should display 50 products')`

> 现在我们要去比赛了...

测试的“完整”列表:

```
// Node
// unit/integration
it('should return 50 products max based on searched item')

it('should return as many products as search finds') // for cases where search finds products but less than 50

it('should throw error if service hits error when calling database')

it('should return empty array if no products found')

// E2E/integration
it('should return 200 HTTP status code with the products')

it('should return 500 HTTP status code if service throws error')

// UI
it('should display 50 products')

it('should display error page on UI if API call returns 500')

it('should display message if search resulted in no items found') 
```

```
// UI
// sorting function, doesn't really have an "unhappy" state
it('should sort by date descending') 
```

您可以从相当小的需求列表中看到，我们已经生成了大量不同的测试用例！更重要的是，测试用例应该防止未来的变化破坏代码，并使我们确信应用程序按照用户的期望运行。

正如过程部分所提到的，并不是所有的需求都会有一条“不愉快”的路径。如果你错过了上面的内容，排序函数就是一个很好的例子。在我们的案例中，并没有真正的“坏”类，所以我们只需要“快乐”的路径，正常运行的测试就可以了。

### 这些需求将产生不同类型的测试

正如上面所讨论的，需求可能很宽泛，有时在开始编写测试之前，您必须将它们分解一点。但是你有一个起点。

当你根据这些需求编写测试时，不同的**类型**测试将会出现:单元测试、集成测试、端到端(E2E)测试。

回到前面的用户能够登录到应用程序的例子，我提到了虽然基本需求是广泛的，我们可能不会仅仅基于此编写我们的第一个测试。但是在之后为基本需求*编写测试是有帮助的，你已经为你的更小的、更细分的需求编写了测试。*

较小的需求通常会生成**单元**测试，而较大的需求有利于生成**集成**和/或 **E2E** 测试。对我们更广泛的需求的测试，在这种情况下，用户可以登录，可以被 E2E 测试所覆盖，测试用例直接取自我们最初的需求——“用户应该能够登录到应用程序”。这个测试用例是一个 E2E 测试，因为它可能会触及我们所有的代码——UI、表单、服务器路由、数据库等等。

### 关于 TDD 的评论

最后，即使你看到了上面的“完整”列表，也不要被骗了。为了给出一个过程/方法的例子，显然我想展示一个测试用例的完整列表。

但是当涉及到实际的开发时，你不应该预先写好所有的测试，然后再去写附带的代码。有时人们认为这就是 TDD(测试驱动开发)是如何完成的，但事实并非如此。

无论你是在进行 TDD(先写测试)还是在之后写测试，遵循这篇文章中概述的过程，不要预先写好所有的测试:)

### 外卖食品

下一次，当你不确定到底要写一个什么样的测试时，试试这里讨论的过程:

1.  将需求转化为技术/代码需求
2.  针对应该发生的情况编写测试
3.  如果适用，针对不应该发生的情况编写测试

我想你会发现当你使用需求来导出你的测试用例时，编写测试变得容易多了。

正如我在本文开头提到的，这是正在进行的系列文章的一部分，通过将**方法**应用到**真实场景**，了解在 JS/Node 应用程序中测试什么。

还有更多的测试帖子在路上——如果你不仅想了解**如何**测试，还想了解**测试什么**，[注册时事通讯](https://www.coreycleary.me/about/)以便在下一个帖子发布时得到通知！