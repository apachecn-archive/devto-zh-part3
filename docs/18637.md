# 2019 年 40+ OOP 面试问题

> 原文:[https://dev . to/aershov 24/40-OOP-interview-questions-in-2019-3m J2](https://dev.to/aershov24/40-oop-interview-questions-in-2019-3mj2)

[![40 C# Object-Oriented Programming Interview Questions in 2019](../Images/82f16bde10f2d08d45c38532b240d64a.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--bJ-_TYHa--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://images.pexels.com/photos/1437493/pexels-photo-1437493.jpeg%3Fauto%3Dcompress%26cs%3Dtinysrgb%26dpr%3D2%26w%3D350) 
OOP 是迄今为止 IT 行业中最常用的编程范例。现在所有主要的编程语言都支持面向对象，包括 C#。OOP 反映了事物如何工作的真实世界行为，以及建模和组织大型应用程序的最有效方式。

> 最初发表于 [FullStack。永远不要再错过你的技术面试](https://www.fullstack.cafe)

### [](#q1-what-is-inheritance)Q1:什么是传承？

> 题目:**OOP**T2】难度:⭐

继承允许我们根据另一个类来定义一个类，这使得创建和维护应用程序变得更加容易。这也提供了重用代码功能和加速实现时间的机会。

当创建一个类时，程序员可以指定新的类应该继承现有类的成员，而不是编写全新的数据成员和成员函数。这个现有的类称为基类，新的类称为派生类。

继承的思想实现了 IS-A 关系。例如，哺乳动物是一种动物，狗是一种哺乳动物，因此狗也是一种动物，等等。

🔗**来源:**【tutorialspoint.com】T2

### Q2:什么是面向对象编程？

> 题目:**OOP**T2】难度:⭐

OOP 是一种开发逻辑模块的技术，例如包含属性、方法、字段和事件的类。在程序中创建一个对象来表示一个类。因此，对象封装了所有的特性，例如与类相关联的数据和行为。OOP 允许开发者开发模块化程序，并把它们组装成软件。对象用于访问不同软件模块的数据和行为，例如类、命名空间和可共享的程序集。。NET Framework 只支持 OOP 语言，比如 Visual Basic。NET、Visual C#和 Visual C++。

🔗**来源:**【indiabix.com】T2

### [](#q3-what-is-encapsulation)Q3:什么是封装？

> 题目:**OOP**T2】难度:⭐⭐

**封装**被定义为*将一个或多个项目封装在物理或逻辑包*中的过程。在面向对象的编程方法中，封装阻止了对实现细节的访问。

🔗**来源:**【tutorialspoint.com】T2

### [](#q4-what-is-polymorphism)Q4:什么是多态性？

> 题目:**OOP**T2】难度:⭐⭐

多态性这个词意味着有许多形式。在面向对象的编程范式中，多态性通常表示为*一个接口，多个功能*。

🔗**来源:**【tutorialspoint.com】T2

### [](#q5-what-is-the-difference-between-procedural-and-objectoriented-programming)Q5:过程式编程和面向对象编程有什么区别？

> 题目:**OOP**T2】难度:⭐⭐

过程化编程基于模块化方法，在这种方法中，较大的程序被分解成多个过程。每个过程都是一组依次执行的指令。另一方面，OOP 是基于对象的。一个对象由各种元素组成，比如方法和变量。

过程式编程中不使用访问修饰符，这意味着可以在程序中的任何地方自由访问全部数据。在 OOP 中，可以通过使用访问修饰符来指定特定数据的范围- *public* ， *private* ， *internal* ， *protected* ，以及 *protected* internal。

🔗**来源:**【indiabix.com】T2

### [](#q6-explain-the-concept-of-constructor)Q6:解释构造函数的概念？

> 题目:**OOP**T2】难度:⭐⭐

**构造函数**是一个类的特殊方法，在创建类的实例时自动调用。它是以与类相同的名称创建的，并且每当您访问该类时，它都会初始化所有的类成员。构造函数的主要特征如下:

*   构造函数没有任何返回类型。
*   构造函数可以重载。
*   声明构造函数不是强制性的；它由自动调用。NET 框架。

🔗**来源:**【indiabix.com】T2

### [](#q7-why-is-the-virtual-keyword-used-in-code)Q7:代码中为什么使用虚拟关键字？

> 题目:**OOP**T2】难度:⭐⭐

定义类时使用`virtual`关键字来指定该类的方法和属性可以在派生类中被重写。

🔗**来源:**【indiabix.com】T2

### [](#q8-what-is-the-difference-between-a-class-and-a-structure)Q8:类和结构有什么区别？

> 题目:**OOP**T2】难度:⭐⭐

**类**:

*   类是一种引用类型。
*   当实例化一个类时，CLR 在堆中为它的实例分配内存。
*   类支持继承。
*   一个类的变量可以被赋值为 null。
*   类可以包含构造函数/析构函数。

**结构**:

*   结构是一种值类型。
*   在结构中，内存是在堆栈上分配的。
*   结构不支持继承。
*   结构成员不能有空值。
*   结构不需要构造函数/析构函数，成员可以自动初始化。

🔗**来源:**【indiabix.com】T2

### [](#q9-what-is-the-relationship-between-a-class-and-an-object)Q9:类和对象是什么关系？

> 题目:**OOP**T2】难度:⭐⭐

一个类充当一个蓝图，它定义了许多对象共有的属性、状态和行为。对象是类的一个实例。例如，您有一个名为 *Vehicle* 的类，而 *Car* 是该类的对象。您可以为名为 *Vehicle* 的类创建任意数量的对象，例如 *Van* 、 *Truck* 和 *Auto* 。

*new* 操作符用于创建一个类的对象。当一个类的对象被实例化时，系统为该类中存在的每个数据成员分配内存。

🔗**来源:**【indiabix.com】T2

### [](#q10-when-should-i-use-a-struct-instead-of-a-class)Q10:什么时候应该使用 struct 而不是 class？

> 题目:**OOP**T2】难度:⭐⭐⭐

除非该类型具有以下所有特征，否则不要定义结构:

*   它在逻辑上表示单个值，类似于原始类型(integer、double 等)。
*   它的实例大小小于 16 字节。
*   它是不可改变的。
*   它将不必经常装箱。

🔗**来源:**【stackoverflow.com】T2

### [](#q11-what-is-polymorphism-what-is-it-for-and-how-is-it-used)Q11:什么是多态性，它的作用是什么，如何使用？

> 题目:**OOP**T2】难度:⭐⭐⭐

多态描述了面向对象编程中的一种模式，在这种模式中，类在共享一个公共接口的同时具有不同的功能。

多态性的美妙之处在于，处理不同类的代码不需要知道它使用的是哪个类，因为它们都以相同的方式使用。多态性的一个真实类比是按钮。每个人都知道如何使用一个按钮:你只需对它施加压力。然而，按钮“做什么”取决于它连接到什么以及它使用的上下文，但是结果并不影响它的使用方式。如果你的老板告诉你按一个按钮，你已经有了执行任务所需的所有信息。

🔗**来源:**【stackoverflow.com】T2

### [](#q12-what-do-you-mean-by-data-encapsulation)Q12:数据封装是什么意思？

> 题目:**OOP**T2】难度:⭐⭐⭐

**数据封装**是将数据和代码绑定在一个称为对象的单元中，并对用户隐藏一个类的所有实现细节的概念。它防止对数据的未授权访问，并限制用户仅使用必要的数据。

🔗**来源:**【indiabix.com】T2

### [](#q13-what-are-abstract-classes-what-are-the-distinct-characteristics-of-an-abstract-class)Q13:什么是抽象类？抽象类的显著特征是什么？

> 题目:**OOP**T2】难度:⭐⭐⭐

抽象类是一个不能被实例化的类，并且总是被用作基类。

下面是一个抽象类的特征:

*   不能直接实例化抽象类。这意味着您不能创建抽象类的对象；必须遗传。
*   抽象类中可以有抽象和非抽象成员。
*   您必须在抽象类中声明至少一个抽象方法。
*   抽象类总是公共的。
*   抽象类是使用*抽象*关键字声明的。

抽象类的基本目的是提供多个派生类可以共享的基类的公共定义。

🔗**来源:**【indiabix.com】T2

### [](#q14-what-are-similarities-between-a-class-and-a-structure)Q14:一个类和一个结构有什么相似之处？

> 题目:**OOP**T2】难度:⭐⭐⭐

下面是类和结构之间的一些相似之处:

*   访问说明符，比如 *public* 、 *private* 和 *protected* ，同样用在结构和类中，以限制对它们的数据和方法的访问。
*   默认情况下，类成员和结构成员(包括嵌套类和结构)的访问级别是私有的。不能从包含类型的外部访问私有嵌套类型。
*   两者都可以有构造函数、方法、属性、字段、常数、枚举、事件和事件处理程序。
*   结构和类都可以实现接口以在代码中使用多重继承。
*   结构和类都可以有带参数的构造函数。
*   结构和类都可以有委托和事件。

🔗**来源:**【indiabix.com】T2

### [](#q15-how-can-you-prevent-a-class-from-overriding-in-c)Q15:在 C#中如何防止类重写？

> 题目:**OOP**T2】难度:⭐⭐⭐

你可以通过使用`sealed`关键字来防止一个类在 C#中被重写。

🔗**来源:**【indiabix.com】T2

### [](#q16-how-is-method-overriding-different-from-method-overloading)Q16:方法重写和方法重载有什么不同？

> 题目:**OOP**T2】难度:⭐⭐⭐

*   **覆盖**涉及到在不同的类中创建两个或更多具有相同名称和相同签名的方法(其中一个应该是父类，另一个应该是子类)。
*   **重载**是一个在同一个类内不同地方使用同名不同签名的方法的概念。

🔗**来源:**【indiabix.com】T2

### [](#q17-can-you-specify-the-accessibility-modifier-for-methods-inside-the-interface)Q17:可以为接口内部的方法指定可访问性修饰符吗？

> 题目:**OOP**T2】难度:⭐⭐⭐

默认情况下，接口中的所有方法都是`public`。您不能为它们指定任何其他访问修饰符。

🔗**来源:**【indiabix.com】T2

### [](#q18-is-it-possible-for-a-class-to-inherit-the-constructor-of-its-base-class)Q18:类有可能继承其基类的构造函数吗？

> 题目:**OOP**T2】难度:⭐⭐⭐

不，类不能继承其基类的构造函数。

🔗**来源:**【indiabix.com】T2

### [](#q19-what-is-the-difference-between-cohesion-and-coupling)Q19:内聚和耦合的区别？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

*   **内聚**是指类(或模块)能做什么。

    *   低内聚力意味着这个类做了大量不同的动作——它很宽泛，没有关注它应该做什么。
    *   *高内聚*意味着类专注于它应该做的事情，即只关注与类的意图相关的方法。
*   至于**耦合**，指的是两个类/模块之间的相关或依赖程度。对于低耦合的类，在一个类中改变一些主要的东西不应该影响另一个。高耦合性会使更改和维护代码变得困难；因为类是紧密结合在一起的，所以做出改变可能需要整个系统的改造。

好的软件设计有**高内聚**和**低耦合**。

🔗**来源:**【stackoverflow.com】T2

### Q20:使用 getters 和 setters 只获取和设置——而不是简单地使用这些变量的公共字段有什么好处？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

**实际上有很多很好的理由*考虑使用访问器****而不是直接公开一个类的字段——不仅仅是为了封装和使未来的改变更容易。*

 *下面是我所知道的一些原因:

*   封装与获取或设置属性相关的行为——这允许以后更容易地添加附加功能(如验证)。
*   隐藏属性的内部表示，同时使用替代表示公开属性。
*   将您的公共接口与变化隔离开来——允许公共接口在实现变化时保持不变，而不影响现有的消费者。
*   控制属性的生存期和内存管理(处置)语义——这在非托管内存环境(如 C++或 Objective-C)中尤为重要。
*   为属性在运行时的变化提供一个调试拦截点——在某些语言中，如果没有这个拦截点，调试属性何时何地变化为特定值会非常困难。
*   改进与针对属性 getter/setter 操作的库的互操作性——我想到了模仿、序列化和 WPF。
*   允许继承者通过重写 getter/setter 方法来更改属性行为和公开方式的语义。
*   允许 getter/setter 作为 lambda 表达式而不是值传递。
*   Getters 和 setters 可以允许不同的访问级别——例如 get 可以是公共的，但是 set 可以是受保护的。

🔗**来源:**【stackoverflow.com】T2

### [](#q21-what-exactly-is-the-difference-between-an-interface-and-abstract-class)Q21:接口和抽象类到底有什么区别？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

*   一个接口就是一个**契约**:编写接口的人说，“*嘿，我接受看起来那样的东西*”，使用接口的人说“*好的，我编写的类看起来那样*”。**一个接口就是一个空壳**。只有方法的签名，这意味着方法没有主体。界面什么都做不了。这只是一种模式。实现一个接口消耗很少的 CPU，因为它不是一个类，只是一堆名字，因此没有任何昂贵的查找工作要做。它非常重要，例如在嵌入式设备中。
*   抽象类与接口不同，它是类。它们的使用成本更高，因为当你从它们那里继承时，需要进行查找。抽象类看起来很像接口，但是它们有更多的东西:你可以为它们定义一个行为。更像是一个人说，*“这些类看起来应该是这样的，它们有共同点，所以填空吧！”*。

🔗**来源:**【stackoverflow.com】T2

### Q22:OOP 中的耦合是什么？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

OOP 模块是相互依赖的。耦合是指两个软件模块之间的依赖程度。如果您在一个模块中进行了更改，则两个模块高度相互依赖，并且每次您必须在相关模块中进行更改时都要支持该更改。松散耦合总是首选。控制反转和依赖注入是一些在模块中获得松散耦合的技术。

🔗**来源:**【dotnetpattern.com】T2

### Q23:OOP 中的内聚是什么？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

在 OOP 中，我们以模块的形式开发代码。每个模块都有特定的职责。内聚性显示了模块职责紧密相关的程度。更高的内聚力始终是首选。更高的凝聚力的好处是:

*   改进模块的维护
*   提高可重用性

🔗**来源:**【dotnetpattern.com】T2

### [](#q24-explain-the-concept-of-destructor)Q24:解释析构函数的概念？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

析构函数是一个类的特殊方法，当一个对象最终被销毁时会自动调用。析构函数的名称也与类的名称相同，但后跟前缀波浪号(~)。

析构函数用于释放动态分配的内存和资源。但是，您可以实现一个自定义方法，该方法允许您通过调用析构函数来控制对象的析构。

析构函数的主要特性如下:

*   析构函数没有任何返回类型
*   与构造函数相似，析构函数也总是公共的
*   析构函数不能重载。

🔗**来源:**【indiabix.com】T2

### [](#q25-differentiate-between-an-abstract-class-and-an-interface)Q25:区分抽象类和接口。

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

**抽象类**:

1.  一个类只能扩展一个抽象类
2.  抽象类的成员可以是私有的，也可以是受保护的。
3.  抽象类应该有子类
4.  任何类都可以扩展抽象类。
5.  抽象类中的方法可以是抽象的，也可以是具体的。
6.  抽象类可以有一个构造函数。
7.  扩展抽象类的类可能实现也可能不实现它的任何方法。
8.  抽象类可以实现方法。

**界面**

1.  一个类可以实现几个接口
2.  一个接口只能有公共成员。
3.  接口必须有类的实现
4.  只有一个接口可以扩展另一个接口。
5.  接口中的所有方法都应该是抽象的
6.  接口没有构造函数。
7.  接口的所有方法都需要由实现该接口的类来实现。
8.  接口不能包含其任何方法的主体。

🔗**来源:**【indiabix.com】T2

### [](#q26-what-is-a-static-constructor)Q26:什么是静态构造函数？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

C#引入了静态构造函数来初始化类的静态数据。CLR 在创建第一个实例之前调用静态构造函数。

静态构造函数具有以下特性:

*   定义它不需要访问说明符。
*   不能在静态构造函数中传递参数。
*   一个类只能有一个静态构造函数。
*   它只能访问该类的静态成员。
*   它只在程序开始执行时调用一次。

🔗**来源:**【indiabix.com】T2

### [](#q27-explain-different-types-of-inheritance)Q27:解释不同类型的继承。

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

OOP 中的继承有四种类型:

*   **单一继承** -包含一个基类和一个派生类
*   **层次继承** -包含一个基类和同一个基类的多个派生类
*   **多级继承** -包含一个从派生类中派生的类
*   **多重继承** -包含几个基类和一个派生类

全部。NET 语言支持单一、层次和多级继承。它们不支持多重继承，因为在这些语言中，派生类不能有多个基类。但是，您可以通过接口实现多重继承 in.NET。

🔗**来源:**【indiabix.com】T2

### [](#q28-does-net-support-multiple-inheritance)Q28:确实如此。NET 支持多重继承？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

。NET 不直接支持多重继承，因为在。NET 中，一个类不能从多个类继承。。NET 通过接口支持多重继承。

🔗**来源:**【indiabix.com】T2

### [](#q29-can-you-declare-an-overridden-method-to-be-static-if-the-original-method-is-not-static)Q29:如果原方法不是静态的，可以将被覆盖的方法声明为静态的吗？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐

不可以。两个虚方法必须有相同的签名。

🔗**来源:**【indiabix.com】T2

### Q30:C #为什么不允许静态方法实现一个接口？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

我的(简化的)技术原因是静态方法不在 vtable 中，调用地点是在编译时选择的。这与您不能拥有重写或虚拟静态成员的原因是一样的。要了解更多细节，你需要一个计算机专业的毕业生或者一个编译专家——而我两者都不是。

你把一个接口传递给某人，他们需要知道如何调用一个方法。接口只是一个虚拟方法表(vtable)。你的静态类没有这个。调用者不知道如何调用一个方法。(在我看这个答案之前，我认为 C#只是在卖弄学问。现在我意识到这是一个技术上的限制，是由接口本身造成的。其他人会对你说这是一个多么糟糕的设计。这不是一个糟糕的设计——这是一个技术限制。

🔗**来源:**【stackoverflow.com】T2

### [](#q31-what-is-the-difference-between-a-mixin-and-inheritance)Q31:一个 mixin 和继承有什么区别？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

一个 **mix-in** 是一个基类，你可以继承它来提供额外的功能。名称“mix-in”表明它旨在与其他代码混合使用。因此，推论是您不会实例化 mix-in 类本身。mix-in 经常与其他基类一起使用。因此* * mixins 是继承的一个子集，或特例。

与单一继承相比，使用混合继承的优势在于，您可以一次性为该功能编写代码，然后在多个不同的类中使用相同的功能。缺点是您可能需要在其他地方寻找该功能，而不是在使用它的地方，因此最好将它放在附近以减轻这一缺点。

🔗**来源:**【stackoverflow.com】T2

### [](#q32-in-terms-that-an-oop-programmer-would-understand-without-any-functional-programming-background-what-is-a-monad)Q32:用一个 OOP 程序员会理解的术语来说(没有任何函数式编程背景)，什么是单子？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

单子是类型的*“放大器”*遵守某些规则*和*提供某些操作*。*

首先，什么是“类型放大器”？我指的是某种系统，它让你把一种类型变成一种更特殊的类型。比如在 C#中考虑`Nullable<T>`。这是一种类型的放大器。它允许你接受一个类型，比如说`int`，并为该类型添加一个新的功能，也就是说，现在它可以为 null，而以前它不能。

作为第二个例子，考虑`IEnumerable<T>`。它是各种类型的放大器。它允许您获取一个类型，比如说，`string`，并向该类型添加一个新的功能，也就是说，您现在可以用任意数量的单个字符串来生成一个字符串序列。

🔗**来源:**【stackoverflow.com】T2

### [](#q33-what-is-lsp-liskov-substitution-principle-and-what-are-some-examples-of-its-use-good-and-bad)Q33:什么是 LSP(利斯科夫替代原理)，有哪些使用的例子(好的坏的)？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

利斯科夫替换原理(lsp，LSP)是面向对象编程中的一个概念，它陈述:

> 使用指向基类**的指针或引用的函数必须能够**在不知道的情况下使用派生类的对象。换句话说，可替换性是面向对象编程中的一个原则，即在计算机程序中，如果 S 是 T 的子类型，那么 T 类型的对象可以被 S 类型的对象替换。

考虑一个不好的例子:

``csharp
public class Bird{
public void fly(){}
}
public class Duck extends Bird{}
public class Ostrich extends Bird{}`` 

 ``鸭子会飞，因为它是一只鸟。鸵鸟是一种鸟，但它不能飞，鸵鸟类是鸟类的一个亚型，但它不能使用飞的方法，这意味着我们正在打破 LSP 原则。

正确的例子是:

``csharp
public class Bird{
}
public class FlyingBirds extends Bird{
public void fly(){}
}
public class Duck extends FlyingBirds{}
public class Ostrich extends Bird{}`` 

 ``🔗**来源:**【stackoverflow.com】T2

### [](#q34-could-you-elaborate-polymorphism-vs-overriding-vs-overloading)Q34:你能详细阐述一下多态 vs 重写 vs 重载吗？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

*   多态性是一个类实例的能力，就好像它是其继承树中另一个类的实例，通常是其祖先类之一。例如，在。NET 所有类都继承自 Object。因此，您可以创建一个 Object 类型的变量，并为其分配任何类的实例。

*   一个**覆盖**是一种函数，它出现在一个从另一个类继承而来的类中。覆盖函数“替换”从基类继承的函数，但这样做的方式是，即使当它的类的实例通过多态性伪装成不同的类型时，它也会被调用。参考前面的例子，您可以定义自己的类并覆盖 toString()函数。因为此函数是从 Object 继承的，所以如果将此类的实例复制到 Object 类型的变量中，它仍然可用。通常，如果你在你的类上调用 toString()，而它假装是一个对象，那么 toString 的实际触发版本就是在对象本身上定义的版本。但是，因为该函数是一个覆盖函数，所以即使当类实例的真实类型隐藏在多态后面时，也会使用来自类的 toString()的定义。

*   **重载**是定义多个同名但参数不同的方法的动作。它与重写或多态都无关。

🔗**来源:**【stackoverflow.com】T2

### [](#q35-what-does-it-mean-to-program-to-an-interface)Q35:“编程到一个接口”是什么意思？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

面向接口的编程与我们在 Java 或. NET 中看到的抽象接口毫无关系，它甚至不是 OOP 的概念。它意味着只与一个对象或系统的公共接口进行交互。不要担心，甚至不要预测它内部是如何工作的。不要管它是怎么实现的。在面向对象的代码中，这就是为什么我们有公共的和私有的方法/属性。

对于数据库，这意味着使用视图和存储过程，而不是直接表访问。

除了消除类之间不必要的耦合，使用接口是使代码易于测试的一个关键因素。通过创建一个定义类操作的接口，您允许想要使用该功能的类能够使用它，而不直接依赖于您的实现类。如果以后您决定更改并使用不同的实现，您只需要更改实现被实例化的那部分代码。其余的代码不需要修改，因为它依赖于接口，而不是实现类。

这对于创建单元测试非常有用。在被测试的类中，你让它依赖于接口，并通过构造函数或属性设置器将接口的一个实例注入到类(或一个允许它根据需要构建接口实例的工厂)中。该类在其方法中使用提供的(或创建的)接口。当您开始编写测试时，您可以模拟或伪造接口，并提供一个接口来响应单元测试中配置的数据。您可以这样做，因为您的测试类只处理接口，而不是您的具体实现。任何实现该接口的类，包括你的 mock 或 fake 类，都可以。

🔗**来源:**【stackoverflow.com】T2

### [](#q36-can-you-provide-a-simple-explanation-of-methods-vs-functions-in-oop-context)Q36:你能简单解释一下 OOP 环境下的方法和函数吗？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

**函数**是一段通过名字调用的代码。可以向它传递要操作的数据(即参数)，也可以选择返回数据(返回值)。传递给函数的所有数据都是显式传递的。

**方法**是一段代码，由与对象相关联的名称调用。在大多数方面，它与函数相同，除了两个关键区别:

1.  方法被隐式传递给调用它的对象。
2.  方法能够对包含在类中的数据进行操作(记住，对象是类的实例——类是定义，对象是定义的实例

🔗**来源:**【stackoverflow.com】T2

### [](#q37-why-prefer-composition-over-inheritance-what-tradeoffs-are-there-for-each-approach-when-should-you-choose-inheritance-over-composition)Q37:为什么更喜欢作曲而不是传承？每种方法的利弊是什么？什么时候应该选择继承而不是作曲？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

把遏制看成是有关系的。一辆汽车有一个引擎，一个人有一个名字，等等。把继承看作是一种关系。汽车是交通工具，人是哺乳动物，等等。

比起继承，更喜欢组合，因为它更有延展性/更容易修改，但是不要使用总是组合的方法。使用组合，很容易通过依赖注入/设置器动态改变行为。继承更加严格，因为大多数语言不允许从一个以上的类型派生。因此，一旦你从 a 型进化而来，这只鹅或多或少就熟了。

我对以上的酸测试是:

*   TypeB 是否希望公开 TypeA 的完整接口(至少所有公共方法),以便可以在需要 TypeA 的地方使用 TypeB？表示**继承**。

例如，塞斯纳双翼飞机将暴露飞机的整个界面，如果不是更多的话。所以这很适合从飞机中推导出来。

*   TypeB 是否只想要 TypeA 公开的部分/部分行为？表示需要**构图。**

例如，一只鸟可能只需要飞机的飞行行为。在这种情况下，将它作为一个接口/类/两者提取出来并使其成为两个类的成员是有意义的。

🔗**来源:**【stackoverflow.com】T2

### [](#q38-what-is-the-difference-between-association-aggregation-and-composition)Q38:联想、聚合、组合有什么区别？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

*   **关联**是所有对象都有自己的生命周期，没有所有者的关系。

我们举个老师和学生的例子。多个学生可以与单个教师关联，单个学生可以与多个教师关联，但是对象之间没有所有权，并且都有自己的生命周期。两者都可以独立创建和删除。

*   **聚合**是一种特殊形式的关联，其中所有对象都有自己的生命周期，但存在所有权，子对象不能属于另一个父对象。

我们举个部门和老师的例子。单个教师不能属于多个部门，但是如果我们删除部门，教师对象将*而不是*被销毁。我们可以把它想成一种“有-有”的关系。

*   **组合**也是聚合的特殊形式，我们可以称之为“死亡”关系。这是一种强类型的聚集。子对象没有生命周期，如果父对象被删除，所有子对象也将被删除。

让我们再举一个房子和房间之间关系的例子。房子可以包含多个房间——没有独立生活的房间，任何房间都不能属于两个不同的房子。如果我们删除房子，房间将自动被删除。

让我们再举一个问题和选项之间关系的例子。单个问题可以有多个选项，并且选项不能属于多个问题。如果我们删除问题，选项将自动删除。

🔗**来源:**【stackoverflow.com】T2

### [](#q39-can-you-declare-a-private-class-in-a-namespace)Q39:可以在命名空间中声明私有类吗？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

默认情况下，名称空间中的类是内部的。但是，你可以显式地将它们声明为仅*公共*，而不是*私有*、*受保护*或*受保护内部*。嵌套类可以声明为*私有*、*受保护*或*受保护内部*。

🔗**来源:**【indiabix.com】T2

### [](#q40-you-have-defined-a-destructor-in-a-class-that-you-have-developed-by-using-the-c-programming-language-but-the-destructor-never-executed-why-did-the-destructor-not-execute)Q40:你在用 C#编程语言开发的类中定义了一个析构函数，但这个析构函数从未执行过。为什么析构函数没有执行？

> 题目:**OOP**T2】难度:⭐⭐⭐⭐⭐

运行时环境自动调用类的析构函数来释放被对象的变量和方法占用的资源。然而，在 C#中，程序员不能控制调用析构函数的时间，因为垃圾收集器只负责释放对象使用的资源。垃圾收集器自动从。然后调用 *Finalize()* 方法。

尽管强制垃圾收集器执行垃圾收集并检索所有不可访问的内存并不可取，但程序员可以使用垃圾收集器类的 *Collect()* 方法来强制执行垃圾收集器。

🔗**来源:**【indiabix.com】T2

> 谢谢🙌阅读，祝你面试好运！
> *如果你喜欢这篇文章，请分享给你的开发者伙伴！*
> *查看更多全栈面试问题&答案上👉[www . full stack . cafe](https://www.fullstack.cafe)T9】*````*