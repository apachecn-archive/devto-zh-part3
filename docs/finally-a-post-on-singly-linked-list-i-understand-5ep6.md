# 最后，一个关于单链表的帖子我明白了

> 原文：<https://dev.to/saral/finally-a-post-on-singly-linked-list-i-understand-5ep6>

理解单链表花了我一段时间，但是当我写这篇文章时，我觉得我会对链表有更好的理解。老实说，两周前我觉得我已经有点破解了链表的奥秘，但后来我懒得写这个帖子，现在(我正在潦草地写)，我对链表的概念不太适应。然而，我想亲自测试一下，我正在花时间(或者说是鞭策自己)写这篇文章。

首先，我是一个初学编程的人，所以这篇文章可能会包含许多看起来非常可笑的编程方法。如果是这种情况，请随时发表评论，并请给我反馈，告诉我如何才能更好地解决这个问题(请稍微友好一点)。说了这么多，让我深入到单链表。

我开始用 C 理解链表，选择 C 作为编程语言的原因是——当我学习链表时，我也想更好地理解指针的概念。

什么是单链表？

> 用最简单的话说，单链表是一种数据结构。单个列表中的数据存储在单独的节点中，这些节点通过指针连接。形象地说，它可以想象成一条链条。其中每个节点包含一个数据类型和一个指向下一个节点的指针(next)。

什么是节点？

> 节点是定义单个数据结构的通用方式。节点有两个元素，一个数据类型和一个指针。在 C 语言中，这可以通过结构来定义

```
typedef struct node {
        int data;
        struct node  *next;
}node; 
```

在上面的结构中，一个节点用两个元素定义。第一个是数据类型，在我们的例子中是一个整数。第二个是下一个指针。在这种情况下，它是指向该结构的自引用指针。当我在脑海中形象地想象这个指针时，我认为它是指向我的结构节点的下一个指针。一旦我们定义了节点的结构，我们就可以开始创建一个链表。链表最重要的部分是它的头部，这是一个需要记住的重要提示——任何时候我们都不应该放开指向头部的指针。随着我们继续前进，这种说法会更加清楚。
接下来，我写了一个函数来创建一个链表的头。

```
node *create_head(node *head){
    head = (node*)(malloc(sizeof(node)));
    printf("Insert a Number: ");
    scanf("%i", &(head->data));
    head->next = NULL;
    return head;
} 
```

正如在这个函数中可以看到的，我已经初始化了我的 head 指针指向 null，它带有一个参数。arg 是指向头部的指针。Head 是通过动态内存分配在堆中分配内存空间的(抛出 C 语言中的花哨词汇，我仍然没有理解这个概念)。此外，这个内存分配中最突出的是`malloc`之前的(node*)。我们在这里做的叫做类型转换。这是我对类型转换的理解在这种情况下，我们为 temp 分配内存空间，这个内存空间属于 node 类型(我们之前定义的结构)。因此，这个内存分配将包含节点结构的两个元素，一个数据类型和一个指针。

接下来，调用`printf`函数，它显示一个用户输入区域，输入的值存储在 temp.data 中，在本例中，您可以看到它被写成了`head->data`。

现在，分配 head a 数据的有趣部分来了。这是使用`scanf`和`&(head ->data)`完成的。此外，head 的指针指向 NULL，因为没有要附加的节点。最后，我们返回 head，根据我们的 create 函数，它为我们提供了一个指向 head 节点的指针。
现在，我们的脑袋里有了数据和指向它的指针。我们也有指向`NULL`的头部指针。现在我们所拥有的，形象地说是一个叫做 head 的节点，它存储一个数据并指向`NULL`。它不太像一个链表。

因此，我们着手插入数据并使之成为一个链表。为此，我创建了一个名为 insert 的独立函数。

```
node *insert(node *head){
    node* temp = NULL;
    node* p = NULL;
    int n;
    printf("Length of the linked list: ");
    scanf("%i", &n);
    for (int i = 0; i < n; i++){
        temp = (node*)(malloc(sizeof(node)));
        printf("Number: ");
        scanf("%i", &(temp->data));
        p = head;
        while( p-> next != NULL){
            p = p->next;
        }
        temp -> next = head;
        head = temp;
    }
    return head;
} 
```

函数 insert 接受一个参数并返回一个指向 head 的指针。在这里，我使用了一个双指针变量`temp`和`p`，它们的用法在我们阅读时会很清楚。插入功能提示用户输入。该输入决定了长度列表的长度，或者要插入到现有头中的项目数。根据用户输入，循环运行`n`的次数。每次循环运行时，temp 被分配一个存储位置，用户输入值被存储在`temp->data`中。

记住，我说过跟踪你的头指针是非常重要的，因此我创建了一个遍历指针或头的副本，并把它赋给了头。现在，这意味着我可以随心所欲地移动指针`P`,而不用担心我的头指针总是指向链表的第一个元素。

接下来，我运行一个 while 条件，该条件声明如果`P`的下一个指针没有指向`NULL`，那么移动指针指向链表中的下一个节点。在这种情况下，运行插入函数有一个先决条件。在调用插入函数之前，我们应该已经调用了`create_head`函数(至少在这种情况下)。因此，假设我们已经运行了 create_head 函数，图片看起来会是什么样子。我们已经有一个头节点，它有一个数据和一个指向`NULL`的指针，因此，当我们的遍历指针`P`通过第一个 while 循环时，条件为假。因为头或`P`已经指向`NULL`。因此循环退出并将临时指针指向头部。形象地说，想想看，现在我们的温度和头部是相连的。但是，现在我们的第一个元素已经改变了，temp 是列表的第一个元素。因此，我们指定 head 等于 temp，从而将 temp 更改为连接到第二个元素的新 head，而第二个元素(我们以前的 head)仍然指向`NULL`。这一切听起来有点混乱，但从图像上看更有意义。(我觉得)

当循环根据用户给定的`n`继续运行时，头元素继续变化。这意味着我们不断地在列表的开头添加一个元素。然后，我们将该元素连接到现有的元素，并将我们的头更新到新添加的元素。

这就是我们如何在链表中插入一个柠檬。

现在，我们已经插入了链表，我们需要执行一个搜索来找到链表中的元素。链表中的搜索是线性搜索，因为这是单链表的缺点之一。我仍然在阅读操作速度，因此，我不会写太多关于速度的内容。对于搜索，我们可以编写另一个函数，比如

```
bool search(int n, node *head){
    node *p = head;
    while (p != NULL){
        if ( p->data == n){
            printf("Found you\n");
            return true;
        }
        else{
            p = p->next;
        }
    }
    printf("Could not find you\n");
    return false;
} 
```

search 函数接受两个参数并返回一个布尔值。int n 指定要搜索的数字，而第二个参数指定指向开始元素的指针。同样，我们在这个例子中使用了一个遍历指针，因为我们不想把原来的指针移动到头部。这里的 while 循环保持检查一个条件，即“`n`等于链表中的数据。”一旦找到我们要找的数字，它就返回 true，否则返回 false。

最后，我们继续销毁或删除链表。记住，在构建链表时，我们已经动态地分配了空间。释放内存是很重要的，因此我们写了一个函数来删除链表。为了测试我对链表和指针的理解，我尝试从链表中删除一个特定的节点，同时也删除了整个链表。首先，删除一个节点:

```
void destroy_node(node *head, int n){
    node *p = head;
    node *temp = NULL;
    int count_del = 1;
    while (count_del != n){
        p = p-> next;
        count_del++;
    }
    temp = p;
    p = p->next;
    head -> next = p;
    free(temp);
} 
```

这里，destroy_node 接受两个参数。`int n`指定链表中要删除的位置，而`node *head`指定指向节点开始元素的指针。在这里，我已经初始化了计数，从 1 开始(只是我的偏好)，这是可以做到的。我现在检查 while 条件，如果 count_del 不等于 n，那么遍历指针继续移动到链表中的下一个节点。最后，一旦条件满足，我将 P 的值赋给 temp，因为我打算删除 temp。我现在移动`P`的指针指向下一个节点，然后让我的更新头指针指向`P`。最后，我删除了我的 temp，我的链表也更新了。

最后，我想删除我的整个喜欢列表，以防止任何内存泄漏。在用 Valgrind(一个检查内存泄漏的工具)检查时，我一直看到内存泄漏，因此，删除链表对我来说很重要。

```
void destroy(node *head){
        node *p = head;
        node *temp = NULL;
        while (p != NULL){
           temp = p-> next;
           free(p);
           p = temp;
        }
    free(temp)
} 
```

函数 destroy 接受了一个指向第一个节点的参数。我分配了一个遍历指针指向 head，还得到另一个指针 temp 指向`NULL`。然后，只要我的节点`P`不等于`NULL`，我就不断更新我的 temp，以指向`P`所指向的元素的下一个元素，并删除 P。然后更新 P，使其等于 temp。在这个过程中，我从一开始就删除了我的链表。

我本想练习递归来删除链表。但是，也许有一天我会用递归再做一次。现在，我很高兴，因为我觉得我对指针、内存分配和单链表有了一些了解。我期待着评论和反馈。

同样以一个查询“###结束这篇长文，我觉得我对单链表有所了解，所以，我去检查了用其他语言实现的链表，我感到很失落。这正常吗？”(愚蠢的问题，但不得不拿出来)

最后一点:我感谢我阅读和看到的所有帖子、文章和视频，是它们让这篇帖子成为可能。

GitHub [将](https://github.com/Saralkarki/Singlylinkedlist)链接到我的代码