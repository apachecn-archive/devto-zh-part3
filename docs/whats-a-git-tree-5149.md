# 什么是 Git 树？

> 原文：<https://dev.to/nichartley/whats-a-git-tree-5149>

我最近做了一个叫做 [Git Gud](https://nic-hartley.github.io/git-gud/) 的工具，并且给[写了一篇博文](https://dev.to/nichartley/git-gud-at-git-5d9k)。你们看起来真的很喜欢这样，所以为什么不多挤一点呢？

不过，更严重的是，git 的内部工作方式让我着迷了一段时间。其实没那么复杂，但是有两大块。我将首先介绍 git 操作的抽象，下周我将回顾它是如何存储在磁盘上的。相信我，如果你先了解存储了什么，就更容易理解它是如何存储的。

注意这个*不是*一个 git 教程。我假设您对 git 有所了解——您不需要知道什么是提交，但是您需要知道什么是版本控制，并且

> **注**:指针在这里出现，作为类比。如果你不知道它们是什么，网上有大量的*难以置信的*资源来解释它们，但那远远超出了本文的范围。可能还有我的能力。

我要把 git 分成三部分:

1.  仓库
2.  承诺
3.  分支

# 储存库

存储库，简称“repo”，是 git 的“容器”。您可能知道，Git 不能在整个文件系统上运行。它仅限于一个目录，以及该目录中递归的所有目录。在存储库的根目录中是`.git`文件夹，它存储了 git 的所有内部文件。

你实际上可以在一个存储库中有一个存储库——如果你曾经被告知`git clone --recursive`某事，那就是它所涉及的。不过，本文只是介绍了 git 的基本概念，所以我不会在这里讨论它们。

还有一些比较角落的案例，比如`.gitignore`。如果你还没有 git 回购协议，我*强烈*推荐你去看看`.gitignore` s。它们可能是由您的 IDE 自动生成的，也可能是从您的模板中就地生成的，但是您应该看一看，了解一下语法，看看您是否能使它们变得更好。通常*有些*东西可以安全地从你的构建中省略掉。

# 提交

提交是存储库状态的快照。它存储提交时每个文件的内容——这就是为什么`.git`文件夹有时会变得如此之大。每次提交基本上都是整个存储库的一个 tarball！Git 内部不使用`tar`格式，它使用一种更节省空间的格式，并且不会重复克隆相同的数据，但这是下周的题外话。

如果您经常使用 git，您可能会注意到它们通常不是这样显示的。它们通常显示为差异。当你做合并之类的事情时(我保证，我们马上就会讲到)，你合并的是不同的集合，而不是两个完整的文件。因此...这是怎么回事？

别担心。我们会处理的。

## 元数据

目录的快照伴随着一些元数据。在我看来，最重要的是:

*   **提交消息**。这告诉人们您的提交，并且对于使您的代码历史易于理解是至关重要的。写下好的承诺信息，你会不可避免地感谢过去的自己。
*   **作者**:写代码的人。几乎肯定是你，尽管一些项目确实接受补丁并改变作者以反映代码的实际来源。
*   **Parents** :这个提交之后的提交(或者，偶尔，提交*s*)。这一概念将在**分支机构**部分进行更多探讨。

这些元数据(以及 git 存储的其他内容)与“tarball”捆绑在一起，成为一个“提交对象”。

## 提交姓名

提交并没有确切的名称。他们有的是杂烩。今天，这是由 SHA-1 生成的，尽管预计 git 将开始迁移到 SHA-256...不久的某个时候。不管是什么算法，它都应用于提交对象，结果就是提交的“名称”。

这个名字，加上 SHA-1，看起来像这样:`e9f8ebe40fadf3a644f92c4a5e4af70f92d29347`。这通常被压缩为前 7 或 8 个字符，所以用`e9f8ebe`代替，尽管您可以使用任意数量的字符，只要它大于 7 并且足以唯一地标识提交的散列。

## 藏物

你可能知道也可能不知道`git stash`。这真的对 T2 很有帮助，我非常喜欢。它允许您保存回购的当前状态，而无需对历史记录进行任何更改，并且可以轻松地重新应用更改。stash 基本上是一个提交对象，但不是由分支指向的(我们马上会谈到这一点)。当你打开你藏起来的东西时，它基本上就像一根树枝一样融合在一起(再次，在一秒钟内)。

# 树枝

树枝很有趣。从某种意义上说，它们实际上并不存在。他们只是指针(告诉你他们会突然出现！)来提交对象。当你添加一个新的提交到一个分支时，提交的*父*被设置为该分支当前所指向的，并且该分支被设置为指向你刚才所做的提交。

那么，这个“分支”就是父母、祖父母等。分支所指向的提交的。正如你可能猜到的，这有点难以定义。分支从哪里开始？当它从另一个分裂出来的时候。你怎么知道你看到的树枝是分开的，而不是另一根？

好问题。非常好的问题。这是一个很好的问题，事实上，我也不知道答案——这似乎是一个惯例和让事情自己解决的混合。无论如何，如果你能对此有所启发，请评论。

## 标签和`HEAD`

标签和`HEAD`与分支是一样的:指向提交的指针。区别在于标签从不移动，即使在提交时——它们是固定的指针，指向树中的单个提交对象。

`HEAD`另一方面，动作很多。当您提交时，它将指向新的提交对象。当您`git checkout`另一个分支时，它会移动到该分支指向的相同位置(...大部分)。您甚至可以`git checkout`单个提交或标记，您的`HEAD`将指向这些提交。

顺便提一下，提交分支指向的提交通常被称为这些分支的头(小写)。我个人更喜欢“小费”这个术语，因为它不太可能与`HEAD`混淆，但称他们为“分支负责人”要常见得多。

## 合并

我保证过我最终会去合并。如果提交只是一堆文件，它们是如何工作的？

嗯，它与 git repo 的一个关键不变量有关，在此之前我一直在掩饰这个不变量:根提交。

在回购中，如果你追溯到足够远的父链，每次提交都指向相同的原始提交。正因为如此，如果你从回购中两个不同的提交开始，并追溯到足够远的地方，你将*最终*找到一个共同的祖先。它很可能是根提交本身，但是会有两个提交都来自的*和*提交。

一旦有了提交，您就可以查看其中文件系统的状态，将其与两个子提交中的文件系统进行比较，并获得差异。如果只有一个提交触及了给定区域，那么您可以“安全地”合并这些更改。如果两次提交都触及了一个区域，但是做了相同的更改——比方说，它们之间有一次提交是为了应用安全补丁——那么您只需应用那些更改。如果他们对同一个位做了不同的更改，那么您可以将其标记为合并冲突，并要求人工处理它。

这显然只是一个概述，还有多种合并算法，各有优缺点。它们的操作基本上是相同的，但是用于发现差异、决定什么算作合并冲突的实际算法等等。是不同的。

完成所有这些工作后，进行新的提交，将两个分支的更改集成到新的快照中。一般来说，你将从一个分支*的*合并到另一个分支*上，并且你将*合并到*上的分支是尖端前进的分支。新提交有两个父提交:当您开始合并时分支指向的两个提交。*

### 压扁合并

实际上有一种不同类型的合并，你可能听说过，叫做挤压合并。这就像一个普通的合并，但不是保留“from”分支作为父分支，它*只有*有变更，所有的都“挤在一起”到一个提交中。这通常在需要一个非常紧凑、非常清晰的提交历史时使用，但是它会丢失历史，而历史对于跟踪何时引入回归非常有用。

## Rebase

那么什么是 rebase 呢？

这实际上与合并很不相似，尽管它们有相同的合并两组变更的最终结果。虽然合并会保留分支的原样，并使用新文件添加新的提交，但 rebase 会保持相同数量的提交，并移动它们。

当你重置基础时，你需要再次从中选择一个分支来重置*和一个分支来重置*到*。再次，他们的共同基地被发现，再次，差异被计算。*

不过，这一次，从“from”分支顶端开始，到公共库之前的提交结束，为每个提交计算差异。然后，这些差异中的每一个都被应用到“到”分支的顶端，每一个都有自己的提交。当重定基础完成时，删除“从”分支的所有旧提交(以及“从”分支本身)，只留下“到”分支上的新提交。

总而言之，并不复杂，也没有看起来那么可怕。

## 删除分支

您可能想知道——如果没有标记来表示分支何时结束，那么删除分支是如何工作的呢？

我让你回到分支这一节的开头，在那里我谈到如何确定一个分支的根是什么。

# 结论

所以，简而言之:

1.  Repos 是包含一些 git 元数据的文件夹。
2.  提交基本上是整个回购协议的一部分，外加一些额外的元数据。
3.  分支实际上只是指针，你不应该想太多。

希望你喜欢！如果你有问题，尽管问。这是一个一般性的概述，可能没有触及你可能会好奇的一切。