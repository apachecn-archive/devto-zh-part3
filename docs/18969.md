# 你好...正则表达式！？

> 原文:[https://dev.to/areknawo/hello-regexp-2846](https://dev.to/areknawo/hello-regexp--2846)

在这篇文章中，我将试着解释一下**正则表达式**的基础知识。请记住，这类教程是为那些想更好地学习正则表达式和/或刚刚开始学习的人以及那些根本不知道什么是正则表达式的人准备的。🙃所以，让我们开始吧！

# [](#so-what-are-these-regexps)那么，这些正则表达式是什么呢？

**正则表达式**(或简称为 **regex** / **regexp** )是描述**搜索模式**的特殊文本构造。有了它们，您可以更容易地在长文本中搜索指定的值。它们通常用于验证数据，如 IP 和电子邮件地址等。一般来说，在处理这类事情时，它们非常有用。那么，缺点是什么呢？嗯，对于初学者来说，它们的语法可能有点混乱，但是相信我——很容易理解！

正则表达式的语法在不同的编程语言之间没有太大的区别(主要是在附加功能上)，所以我将展示的构造应该可以移植到您选择的语言(在大多数情况下)。无论如何，出于本教程的目的，我将使用 JavaScript 实现。我把所有的结构分成组，这样他们就能以一种有组织、有序的方式学习。

# [](#characters)字符

要匹配任何给定的字符或数字，你只需键入它。不过，有个问题。在某些情况下，您可能希望只匹配一个用作正则表达式构造的字符，也就是保留字符。然后，你必须**逃离你的角色**。如果你现在已经写了一段时间的代码，你会知道它的意思只是在某个字符**前面加一个反斜杠(\ )** 符号**，仅此而已。在 JS 中你要转义的字符有: **+，*，？, ^ , $ , \ , .，[，]，{，}，(，)，|，/** (用冒号分隔)。给你举个例子:** 

```
// In JS your regexps are placed between two slashes

/Here goes your regex\. It is easy like one \+ one/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

通过转义某些字母或序列，您可以访问正则表达式的超能力！让我们来看看 JS 中的这些内容:

*   **\ w**-"**w***ord*-匹配任意单词字符(字母、数字、下划线)；
*   **\ d**-"**d***igit*-匹配任意数字；
*   **\s** - " *白色***s***pace*-匹配任何空格(空格、制表符、换行符)；
*   **\ t**-"**t***ab*"-匹配一个 tab 字符(没错，就是由 **Tab** 按钮创建的那个)；
*   **\n** - " **n** *ew 线*-匹配**换行**字符，无非是移动到新行指示符；

这些是最常用的。但是还有更多！几乎一直在使用的前三个词，以**大写字母**的形式有它们的**否定对应词**:

*   **\W** - " **非****W***ord*-匹配除单词 one 以外的任何字符，例如**冒号(，)**；
*   **\ D**-"**not D***igit*-匹配任何不是数字的字符，例如**字母**；
*   **\S** - " **非** *白* **s** *步调*-匹配任何非空白字符；

希望你注意到了大写字母。😁在 JS 中，还有 4 个转义字符(至少对我来说)不像其他字符那样经常使用。给你一瞥*为什么？*和*如何？*，他们来了:

*   **\v** - " **v** *竖制表符*-匹配**竖制表符**字符；
*   **\f** - " **f** *表单进给*-匹配**表单进给**字符；
*   **\r** - " *回车* **r** *回车*-匹配**回车**字符；
*   **\ 0**-"*NULL*-匹配 **NULL** (字符代码 0)字符；

我想现在你知道为什么这些不流行了。这些只是用的不多。我认为理论已经足够了——让我们来看一个例子:

```
/* Let's create something that will match "December 2018" string...
   and be creative :) */
/\we\Dem\Ser\s\d\S\d8/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

嗯，也许这不是有史以来最好的正则表达式，,但至少我们使用了几乎所有学到的构造。😉

那么让我们继续讨论**转义序列**。这些家伙有点难对付和复杂。在他们的帮助下，你可以多种多样的 **unicode 字符**。

*   **\000** - " *八进制转义*-使用提供的**三位八进制数**匹配字符； **000** 是**最低的**可能数，而 **377** 是**最高的**，匹配字符代码 255；
*   **\xFF** - " *十六进制转义*-使用提供的 **2 位十六进制数**匹配字符；
*   **\ ufff**-"*unicode 转义*-使用提供的 **4 位十六进制数**匹配字符；
*   **\u{FFFF}** - " *扩展 unicode 转义*-使用提供的**十六进制数匹配字符，没有位数限制**，因此用**完全支持**所有 unicode**；**需要* **u** *标志——稍后再详细说明*；**

如您所见，使用转义序列我们可以匹配 unicode 字符！考虑下面的例子，我们匹配了 4 次相同的 unicode 字符- [](https://unicode-table.com/pl/00A9)(版权符号)

```
/* Match © 4 times in different ways.
   Leave last u character alone for now. */

/\251\xA9\u00A9\u{00A9}/u 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

就是这样！现在您已经知道了几乎所有可以在 JS 正则表达式中使用的转义构造。现在让我们进入另一个类别！

# [](#anchors)锚点

顾名思义，**锚点**让我们在文本中匹配锚点，它们是文本的开始和结束，是词与词之间的界限。这些都很简单。😀

*   **-*开头*-匹配所供字符串或单行的**开头**(带 **m** 标志)；**
***   **$**-“*结尾*”-匹配所供字符串或单行的**结尾**(带 **m** 标志)；*   **\b** - " *字* **b** *边界*-匹配字边界，即最后一个或第一个**字符和空白**之间的**位置**；*   **\B** - " **非** *字* **b** *边界*-匹配任何**位置**即**非**一**字边界；****

 **不过，还有一点需要注意。锚点匹配的是**位置**而不是**字符**这基本上意味着锚点不会在 regexp 执行的结果中包含更多的字符。榜样来了！

```
/* Match ordinary "Regular expressions" string.
   Notice that even with a word boundary matched,
   we still have to match a whitespace.
   Remember, \b matches only a position between them! */

/^Regular\b\sexpressions\b$/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#quantifiers)量词

现在，这就是乐趣的开始！使用**量词**，您可以量化想要匹配多少个指定字符。量词真的很有用，也很好学。

*   **+** - " *加*-让你匹配前面构造的 **1 个或多个**；
*   **** - " *星* " -让你匹配前面构造的 **0 或更多**；
*   **{ 1 }**-“*量词*-let ' s you**量化你要匹配多少个**的前置构造，你也可以提供**两个数字除以冒号**来表示要匹配的构造的**下限和上限**，比如 **{1，3 }**；
*   **？** - " *可选*-let ' s you**表示**前置构造为**可选**(不需要匹配)；
*   **？**——*懒*——姑且你**注明**前置**量词**为**懒**(尽量少配**字**)；
*   **|** - " *交替*-让你**提供替代构造**来匹配，类似布尔**或运算符**；

量词允许我们创建更好、更有表达力的正则表达式。😅

```
/* Let's match "December 2018" this time a little bit different...
   Take a look at two \w constructs, that's because we've used lazy modifier.
   This makes \w+? match only one letter. */

/\w+?\w+\s\d+/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#groups-amp-sets)组&组

到目前为止，您已经在学习正则表达式的语法方面走了很长的路。现在是时候学习如何用**组**和**集**来排列正则表达式的结构了。

**Groups** 允许你将你的 regexp 结构分组(真是一个惊喜)。😂有两种类型的组:**捕获**和**非捕获**。**非捕获组**用于**仅仅分组**你的构造，以备后用(例如)量词。**捕获组**给你额外的能力**在运行正则表达式后，获得分组正则表达式构造的结果**。你也可以**引用**它们的**号**。同样，当**对**组进行编号时，**从第一组的 1** 开始，每个新组从**左括号顺序**中获得其**号**。

*   **(ABC)**-“*捕获组*-组的内容直接放在括号之间；
*   **(？:ABC)** - " *非捕获组*-非捕获组的内容跟在 **:** 符号和右括号之后。
*   **\1** -【被抓取组参照】-允许您参照被抓取组及其编号；

```
// Let's match "regex regexp" string

/(regex)\s\1p/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

**集，**则允许你**创建角色集**来匹配。**被否定的集合**匹配任何不在其中的字符。在一个场景中，你不需要像之前一样对相同的字符进行转义，因为显而易见的原因，只需要对 **-** 和**进行转义。在一个集合中，您还可以通过用破折号 ( **-** )连接开始和结束的**，为**提供一系列字母或数字**。****

 ***   **【ABC】**-"*set*-匹配任意一个提供的字符，等于构造像**A | B | C**；
*   **【^abc】**-“*求反集*”-匹配除提供的字符之外的任何字符(a，b，c)
*   **【A-D】**-*范围*-匹配**A 到 D 的任意字母**；
*   **-*-取反范围*-匹配**除 1 到 3** 以外的任何数字；**

 **```
// Match any three letters with range

/[A-Z]{3}/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#lookarounds)四处张望

简单来说- **回看**是允许你检查**给定值** **是否在另一个****之前或之后的构造，而不将其包含在结果**中。有两种或者更确切地说是四种类型的环视:

*   **(？=ABC)** - " *正向前瞻*-如果**之前的值**是**之后的值**与中的**表达式匹配，则匹配；**
*   **(？！ABC)** - " *负前视*-如果**之前的值**是**，而**之后没有由**表达式匹配的值，则匹配；**
*   **(？< =ABC)** - " *正向后视*-匹配如果**跟随值**在之前**被**内的**表达式匹配；**
*   **(？<！ABC)** - " *否定后视*-如果**后面的值**是**且**前面没有由**表达式匹配的值，则匹配；**

请记住，至于 JavaScript， **lookbehinds 仅在最新的 ES2018 中受支持，并且仅在最新的谷歌 Chrome 浏览器** *(在撰写本文时)*中可用。现在，让我们给他们一个机会，好吗？😉

```
/* Let's match "reg" in "regexp" using lookahead
   and "exp" using lookbehind. 
   Remember that lookarounds doesn't include the parts inside them
   in the result */

/reg(?=exp)/
/(?<=reg)exp/ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#lets-end-this-flags)让我们结束这一切吧——旗帜

标志在正则表达式中非常重要。这些**改变了正则表达式的解释方式**。如果你注意的话，这些在前面的例子中出现过。现在，在 JS 中，我们通常可以直接在结束斜杠后添加标志(有不同字母的形式)。让我们探索 JS 中所有可用的标志。

*   **I**-"**I***gnore case*-使整个表情**不区分大小写**；
*   **g** - " **g** *叶形* " - **保存上一次匹配**的索引，这样就可以**找到下一个**一个**而不是一遍又一遍的同一个**；
*   **m**-"**m**T4】ulti line-使锚点 **^** 和 **$** 匹配**行的开始和结束**而不是文本整体；
*   **u**-"**u***nicode*-允许使用 **\u{FFFF}** ( **扩展 unicode 支持**)，其中**的位数**比 4 多(在较新的 JS 实现中可用)；
*   **y**-"*stick***y**-使表达式**仅从最后一个索引**，**停用** **g** 标志(在较新的 JS 实现中可用)；

所以，这里有一个例子。

```
/* The u flag allows the use of extended unicodes.
   Notice where the flag is located. */

/\u{FFFFF}/u 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#the-end)结束

所以不管你信不信，这就是 JavaScript 正则表达式的全部语法。如果你觉得有点过了，那就不要慌！记住所有这些结构并不难——你必须相信我。😎此外，请记住，有了这些知识，您可以轻松地用许多其他语言编写正则表达式！希望你今天学到了一些新东西，或者至少这篇文章提供了一点记忆刷新，或者读起来很好。

如果你像我一样是一名 JavaScripter 程序员，并且想编写复杂的正则表达式(对某些人来说，这些表达式有时看起来非常复杂),那么对你来说是一个额外的奖励！我已经编写了一个库，它为您提供了一个很好的、可链接的 API 来构造 regexp。它还在编辑器中提供了自动完成功能，比如 VS Code 和 TypeScript 的帮助，所以如果你想——查看一下 [ReX.js](https://github.com/areknawo/rex) !

如果你喜欢这篇文章，可以考虑看看我的个人博客了解更多内容。😀******