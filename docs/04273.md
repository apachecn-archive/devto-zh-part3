# 不要(一直)使用 Bash 来编写脚本

> 原文:[https://dev . to/nikoheikkila/don-t-use-bash-for-scripting-all-the-time-2kci](https://dev.to/nikoheikkila/don-t-use-bash-for-scripting-all-the-time-2kci)

编写脚本是我们有时无法避免也不应该害怕的编码子集。编写脚本的标准工具是用于 UNIX 环境的 Bash 和用于 Windows 环境的 PowerShell。在这篇文章中，我解释了什么时候适合使用 Bash 来编写脚本，什么时候不适合。

## [](#the-good-side-of-bash)痛击好的一面

Bash 可以被认为是一种*无处不在的*语言，这意味着它几乎安装在您登陆的任何系统上。很难找到一个基于 Linux 的操作系统没有预装 Bourne Again Shell ( `bash`)或它的老兄弟 Bourne Shell ( `sh`)。

使用代码需要使用 shell 来执行一系列简单的重复任务。每次当你想做某事时，手动输入这些将是一个负担。使用容器是解决这个问题的一种方法，但是对于不支持容器的环境，您可能会使用 Bash。

Bash 在小而高效的脚本中大放异彩，这些脚本主要是为一件事而设计的:重复原本要从上到下手工输入的指令。对于一个标准的项目，这通常包括安装外部包、运行测试以及执行项目的一般维护任务。

为本地开发环境部署代码库通常包括安装与您选择的包管理器的依赖关系、设置必要的环境变量以及启动开发服务器。这些可以放入 shell 脚本中，以便于访问。同样，为测试准备代码库，运行它们，最后清理是 Bash 脚本的一个很好的用例。

然而，如果上述任务需要更复杂的步骤，Bash 很快就会变得很麻烦。

## [](#the-ugly-side-of-bash)痛击丑恶的一面

我大声宣布这一点。Bash 的语法很难看，而且有一个陡峭的学习曲线。多亏了现代工具，没有多少开发人员开始用 Bash 设置 UNIX 环境的编程之旅。因此，我们不应该假设每个参与软件项目的新开发人员都知道如何处理复杂的 Bash 脚本。

考虑下面的例子，在没有给变量指定默认值的情况下，给变量指定一个默认值:

```
name="${1:-World}"
echo "Hello, $name!" 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

最后一行看起来很简单。我们只是打印一个带有变量的消息，但是在第一行到底发生了什么呢？语法上的怪癖，比如将语句放在大括号中，以及神秘的符号`1:-`,使得这很难理解。没有好的空白，阅读起来也很痛苦。无论如何，这一行告诉 Bash，当用户没有给脚本的第一个参数任何值时，将字符串值`World`赋给局部变量`$name`。

让我们用 Python 做同样的事情。

```
name = args.name or "World"
print(f"Hello, {name}") 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

假设我们已经使用 Python 的 [`argparse`](https://docs.python.org/3/library/argparse.html) 模块解析了参数。Python 提供了一个逻辑关键字`or`,用于检查左边的值是否被解释为 *falsy* ,是否应该进行默认赋值。这对初学者来说更友好。

Javascript:
也可以遵循类似的方法

```
const name = args.name || "World"
console.log(`Hello, ${name}`) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

与 Python 的唯一区别是用标准的逻辑符号`||`代替了`or`。当然，您必须通过解析脚本参数做更多的工作，但是结果将更具**可读性**。说到维护软件，我最喜欢的一句话是，每个人都应该学会:

> 没有可读性，就没有可维护性。没有可维护性，就没有价值。可读性就是一切。

有些人可能会争辩说，脚本不需要可读，因为它们只包含所谓的*一次性代码*。这是一个有问题的说法，因为我目睹了由于缺乏更好的工具，关键任务系统被用脚本粘在一起。你曾经在一个项目中做过维护工作吗？这个项目是建立在由一个开发人员的工作组维护的超过 100 行的脚本之上的。对脚本维护采取漠不关心的态度将企业置于严重的风险之中。

## [](#making-it-rain-with-bash)大雨倾盆

编写好的 Bash 脚本需要多年的实践。如果你选择走这条路，它并不是一条没有结果的路，而是需要一套特殊的工具和技能来创造价值。为了避免 Bash 失败，有两条重要的建议需要采纳。

第一个建议是使用[非官方的 Bash 严格模式](http://redsymbol.net/articles/unofficial-bash-strict-mode/)来避免不必要的调试。它由两行代码组成，使您的脚本按照以下方式运行:

*   脚本在遇到错误时会立即退出(`-e`标志)
*   一旦遇到未定义的变量(`-u`标志)，脚本立即退出
*   当管道语句中的一个或多个调用失败时，脚本立即退出(`pipefail`选项)
*   内部字段分隔符(`IFS`)被设置为接受换行符和制表符，这使得臭名昭著的 Bash 数组处理更容易、更符合逻辑

使用严格模式有一些注意事项，所以我建议阅读整篇链接文章，并在阅读过程中启用或禁用这些设置。

第二个建议是为林挺安装 [*ShellCheck*](https://www.shellcheck.net/) ，并在编写脚本时对其进行分析。这是一个非常棒的工具，它可以在运行脚本之前为您找到不正确的数组迭代或变量替换。 *ShellCheck* 绝对是我用过的最好的静态分析器之一，它预装在 [Travis CI runners](https://github.com/koalaman/shellcheck/wiki/TravisCI) 中，这意味着你可以在每次推送提交时检查 Bash 脚本的缺陷。相信我，你应该的。

说到调试代码，使用 Bash 是可能的，尽管我从来没有找到本机调试器(`-x` flag)或抛出 print 语句。如果维护您的脚本需要定期调试会话，您应该启用严格模式或重构逻辑。

## [](#scripting-without-bash)无需 Bash 的脚本

让我们假设您已经编写了一个相当复杂的 Bash 脚本，它跨越了几十行，或者在最坏的情况下，跨越了几百行。出于这样或那样的原因，现在需要对它进行重构。这是一个放弃狂欢的绝佳位置！

[![Drop the Bash](../Images/cdbd27694fcdf502d0425276863e98ac.png)T2】](https://i.giphy.com/media/77XwMyXIgUuVW/giphy.gif)

首先，记下你的代码库的主要语言是什么。如果是 PHP、Python 或 Javascript，你就走运了。我对 Go 或 Rust 不太熟悉，但我见过并使用过一些用它们编写的很棒的命令行工具，所以我要说你在这方面也很幸运。

接下来，你可能会在你的脚本上面有一个类似于`#!/bin/bash`的 *shebang* 行。把这个改成例如`#!/usr/bin/env node`用你想要的代码解释器替换`node`。

您可能已经知道，这一行通过命令`./script`使您的脚本被赋予适当的权限而成为可执行的；或者如果你把它放在一个包含在`$PATH`环境变量中的文件夹中，就只放`script`。从这里开始，逐行将你的脚本转换成一种新的语言，在需要的地方导入必要的模块。最后，你的脚本可能会变得更长，但它肯定会更健壮和可维护。

重构时可能会遇到的一个障碍是运行 shell 命令的能力。在 Bash 中，除了编写命令之外，您不需要做任何事情(除非您尝试解析和验证它的输出，在这种情况下，我祝您好运)。对于其他语言，你必须通过使用内置或外部模块来*调用*。值得注意的是节点的 [`execa`](https://github.com/sindresorhus/execa) 和 Python 的 [`delegator.py`](https://github.com/kennethreitz/delegator.py) 。在所有流行语言的脚本中，应该有类似的模块来处理子进程。这些模块中有许多允许异步运行命令，并以灵活的方式处理输出，这是您可能很难用 Bash 实现的。

如果内置的语言特性还不够，还有为编写命令行工具而创建的方便的框架。以节点的 [`oclif`](https://oclif.io/) 和 Python 的 [`click`](https://github.com/pallets/click) 为例。如果您的业务逻辑严重依赖命令行，请不要犹豫，采用命令行而不是 Bash。

## [](#how-i-did-it)我是怎么做到的

作为一个例子，我展示了我为这个 Gatsby 站点创建快速草稿而编写的一个[脚本。该脚本是用 Javascript 编写的，具有以下特性，用 Bash 实现这些特性很困难，甚至有些疯狂:](https://github.com/nikoheikkila/nikoheikkila.fi/blob/master/new.js)

*   交互式提示和通过验证器函数传递给定数据的能力
*   将句子转换成 SEO 友好的 slugs(例如`Blog Post Title`到`blog-post-title`)
*   不使用奇怪的 ANSI 代码给终端输出着色
*   异步编程
*   将结构化数据转换为 YAML 前沿问题

我并不是说用 Bash 做这些事情是不可能的，但是那会是一堆奇怪的`awk`模式，我最终会调试几个小时。

一个具体的好处是，我能够使用几个第三方模块的逻辑来实现其中的大部分。使用 Bash，我必须从某个地方找到合适的逻辑，将它们复制粘贴到专用文件中，并在我的代码中使用。虽然这种方法可能有效，但它会令人沮丧，并且容易出错。

对于这个话题，我喜欢引用辛德雷·索胡斯(Sindre Sorhus)的话，他强烈主张使用 T2 的小而集中的模块(T3)而不是重新发明轮子:

> 几年前。在 Node.js 和 npm 之前。我有一个很大的代码片段数据库，当我需要的时候，我会把它复制粘贴到项目中。它们是小工具，有时会派上用场。npm 现在是我的代码片段数据库。当你可以复制粘贴的时候，为什么要复制粘贴呢？修复代码片段中的错误意味着更新一个模块，而不是手动修复使用代码片段的所有实例。
> 
> 我希望编程更简单。使得构建持久的系统变得更加容易。在我看来，前进的道路绝对不是推倒重来，每个人都一遍又一遍地犯同样愚蠢的错误。

实际上，如果你想知道用 Javascript 创建高效命令行工具的技巧，可以去查看一下 GitHub 上的 Sorhus 的一些库。

也许有一天 Bash 会有一个好的(嵌套的)依赖系统和更友好的语法。至于语法部分，已经在我日常使用的 [*友好交互 Shell* (鱼)](https://fishshell.com/)中进行了改进。Fish 开发者宣称它的语法是“简单、干净和一致的”,我同意这一点。然而，用*外来的* shell 语言编写脚本可能弊大于利，除非你的整个应用程序都是用同一种语言编写的。

在那之前，我最喜欢用我用来编写业务逻辑的语言编写脚本。

## [](#conclusion)结论

这篇文章的主旨不是抨击 bash，而是不要将它用于手头的每一项任务。相反，您应该在实现之前适当地设计您的脚本需求，并注意当复杂性变得太大而无法在 Bash 的限制内合理处理时。

为了快速执行重复的任务，对小脚本使用 Bash 是一项很有价值的技能——对于其他任何事情，使用您喜欢的语言。