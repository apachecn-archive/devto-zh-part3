# 可扩展的实时应用

> 原文：<https://dev.to/sergiodxa/scalable-real-time-applications-1i6o>

*译自[https://dev . to/sergiodxa/aplicaciones-real-time-de-alta-escala-43h 0](https://dev.to/sergiodxa/aplicaciones-real-time-de-alta-escala-43h0)T3】*

构建实时应用很难，真的很难，但它可以通过提供即时的内容更新来改善用户体验。

有多种方法可以实现它们，要么使用 WebSocket，要么使用服务器发送的事件，要么使用长轮询。在这篇文章中，我将谈论如何使用 WebSockets 来构建一个高需求的应用程序，而不杀死我们的服务器。

> *注意*:接下来的一切都是基于我在像 [Platzi Live](https://platzi.com/live) 这样的项目中使用 WebSockets (WS)的经验。

## 技术堆栈

重要的是要理解这种应用实际上可以用任何技术实现，不仅仅是 Node.js 或 Go，还有 Ruby、PHP、Python 等。有使用 WS 的方法，但最终它只是一个协议，像 HTTP。

也就是说 Node.js 的异步特性和它的简单性使它成为创建 WS 服务器的一个很好的选择，结合像 [socket.io](https://socket.io) 这样的库，在很短的时间内拥有一个工作的服务器是可能的。很可能最终需要迁移到另一种技术，如 Go 或 Rust，以支持我们服务器的每个实例的更多用户，但这通常发生在需求非常高的时候。

无论如何，重要的是使用一种我们知道并且感觉舒适的编程技术，如果你使用 Ruby，你可以使用 ActionCable 毫无问题地创建它，并最终看看它是否值得移植，也许是因为相似性而长生不老。

我们的 WS 的另一个重要部分是队列或发布/订阅系统，它允许我们在不丢失消息的情况下水平扩展它，这样实例将从这些服务接收消息，并将它们发送给连接的用户。我们可以使用 Redis 作为一个简单的发布/订阅或一个专门的系统，如 RabbitMQ 或 Apache Kafka，甚至是允许我们订阅 RethinkDB 等变化的用户数据库。

## 避免来自 WebSocket 的突变

一旦我们的 WS 服务器开始工作，就开始使用这个通道发送所有的东西，这样，如果我们需要查询一些数据，我们就使用 WS，如果我们需要创建、更新或删除资源，我们就使用 WS 发送所需的信息。即使这在小范围内有效，当我们开始有越来越多的连接用户进行这种**突变**时，我们将开始饱和我们的 WS 通道，要求为更少的人启动更多的实例。

避免这种情况的最好方法是拥有一个 HTTP API，并使用它来查询和改变数据，作为一个无状态协议，与 WS 相比，它更容易扩展以支持更多的请求。

在突变发生后，HTTP API 应该向我们的队列系统发送通知，然后我们的 WS 将处理队列，并将通知发送给所有订阅了**的**用户，所述通知可以是更新的资源，也可以只是 id，以便客户端可以从 HTTP API 查询数据。

## 信息增量

一个常见的错误是使用我们的 WS 通道发送太多的信息，这导致了与在 WS 上进行查询和突变相同的问题，我们将使我们的 WS 通道充满额外的信息。我的建议是发送信息增量。那是什么意思？只发送更改的内容和标识资源的方式，而不是发送整个资源。

如果我们有一个注释系统，在我们的客户端状态中可能会有一个类似的对象:

```
{  "id":  123,  "author":  456,  "message":  "Hello, world!",  "likes":  [6546,  123213,  4678234,  12,  567,  98]  //  list  of  users  ID  } 
```

Enter fullscreen mode Exit fullscreen mode

假设一个新用户`678`喜欢这个评论，我们可以用新的赞数组发送整个评论，或者我们可以用增量发送一个小消息。

```
{  "action":  "like",  "comment":  123,  "user":  678  } 
```

Enter fullscreen mode Exit fullscreen mode

这样，我们的客户端应用程序将更新应用程序状态，将 like 添加到状态中已经存在的评论中，并更新 UI。这将把通过 WS 发送的信息减少到只有必要的信息。

重要的是要考虑到这可能会有问题，如果客户端的状态中没有注释`123`,那么增量不能被应用，如果我们稍后得到它，用户界面可能会停止。

类似地，用户可能会在断开连接期间丢失信息，这可以通过经常进行查询或发送最后一个增量的 ID 来减轻。如果用户过时，HTTP API 可以发送较新的增量，直到客户端是最新的。

另一种选择是，如果用户接收到对注释`123`的更新，并且还没有处于状态，那么可以通过 HTTP 获取它，并在应用增量后保存它。这完全取决于我们希望系统中的数据一致性水平

## 数据流

让我们来说明前面提到的数据流。

*   客户端向 HTTP API 查询数据
*   HTTP API 将数据回复给客户端
*   客户端订阅 WS API
*   客户端向 HTTP API 发送一个突变来创建一个新的资源
*   HTTP API 更新数据库以插入新资源
*   HTTP API 将新资源的通知排入队列
*   WS API 处理队列以获取通知
*   WS API 将通知发送给订阅的客户端
*   客户端在收到通知后更新其状态

这样，我们的 WS API 将尽可能地简单，以减少工作量，让我们用更少的资源处理更多的用户。

## 处理断线

互联网连接并不完美，可能会失败，实际上失败一直都在发生，丢失数据包是很常见的，许多协议都会处理这种情况。如果我们进入移动世界，情况会更糟，无论是用户离开互联网路由器并在改变数据计划时失去连接，还是在车辆上失去信号。

用户很可能会失去连接，当这种情况发生时，它将与 WS API 断开连接。这样，从客户端检测到断开连接并尝试重新连接是非常重要的。通常这将在递增的间隔中完成，这样第一个是即时的，第二个需要几秒钟，因此它会增长，并可能在重试之前等待几分钟。

## 信息恢复

断开连接后，用户将丢失信息片段，无论是新的还是更新的资源，这取决于我们想要的一致性级别，我们可以用不同的方式处理它。

如果一致性不是一个优先事项([最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency))，假设我们有一个大规模的聊天，其中丢失一些消息不是问题，我们可以如上所述，当我们收到一个增量来更新不在我们状态中的资源时，我们可以查询丢失的数据。如果我们想确保不丢失增量，我们甚至可以在更新后获取每个资源，即使它已经在我们的状态中，这将让我们确保我们总是尽可能地最新。

如果需要一致性([强一致性](https://en.wikipedia.org/wiki/Strong_consistency))，我们可以让 make 客户端在从断开连接中恢复后向 HTTP API 发送最后一个增量的时间戳，以指示他停留的时间，然后 API 可以向客户端发送丢失的增量，让它处理它并更新其状态和 UI。

如果我们希望具有很强的一致性，我们需要将每个通知及其日期存储在数据库中，以便能够稍后将其发送给用户，我们可以使用基于文档的数据库(如 MongoDB)来实现这一点，它将允许我们为增量创建一个集合并将它们存储在一起，而不用担心数据的模式。

## 水平缩放

到目前为止，我们已经讨论了如何优化单个实例的使用，尽管如果我们计划拥有许多用户，这种理想是不现实的。虽然我们可以尝试垂直扩展，向托管我们的 WS API 的服务器添加越来越多的资源，但这最终会更加昂贵，并且不会带来太多好处，那时我们将需要水平扩展。

那是什么意思？我们将添加更多运行 WS API 的服务器，而不是改进我们的服务器，为了使它工作，我们需要在我们的服务器之间分配工作负载，在 HTTP API 中，这相对容易，在 WS 中，因为我们有一个状态要保持(连接的客户端),我们将需要使用配置了粘性会话的负载平衡器，这意味着在第一次请求(握手)之后，客户端和 WS 之间的每个连接都将使用同一个服务器。

如果用户断开连接，我们可以将它重新连接到任何服务器。如果服务器停机，无论是因为我们手动操作还是由于错误而崩溃，连接到该服务器的每个客户端都将失去连接，并将尝试重新连接，我们将需要分配负载。

这使得我们的负载平衡器必须知道连接到每台服务器的客户端数量，以确保新用户的分布，而不会使任何用户超过其处理能力的服务器负担过重，这可能需要我们拒绝用户的连接尝试，直到新服务器启动或用户断开连接，请注意这应该是最后的资源。

一旦配置完成，如果当前服务器达到了用户的极限，我们的负载平衡甚至可以自动启动新服务器，这在高峰时间很常见，或者如果我们的应用程序突然流行，这样做将让新服务器接收所有新用户，直到它到达其他服务器，这时又有一个服务器可以自动启动。

当流量再次下降时，它可能会开始关闭服务器，甚至是低使用率的服务器，并迫使用户重新连接到服务器的其余部分。这样，我们可以通过关闭额外的服务器和只支付我们需要的费用来节省一些钱。

## 最后的话

最后，我最大的建议是尽可能避免使用 WebSockets，长轮询和 SSE 是很好的选择，更容易扩展，更便宜，在大多数情况下可以和 WS 一样工作。