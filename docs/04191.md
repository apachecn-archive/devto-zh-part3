# C++模板和 Java 泛型:泛型编程的两种不同方法

> 原文:[https://dev . to/lennycheng/c-templates-and-Java-generics-two-different-approach-to-generic-programming-139 I](https://dev.to/lennycheng/c-templates-and-java-generics-two-different-approaches-to-generic-programming-139i)

# [T1】简介](#intro)

泛型编程是抽象出具体类型的能力，最早出现在 20 世纪 70 年代。它简化了代码维护，减少了冗余代码，并实现了优化。而不是一遍又一遍的写同一个算法，但是每次用不同的数据类型，程序员只需要写出来一次。例如，定义`size_t sum(T)`，而不是三个定义`size_t sum(int)`、`size_t sum(long)`和`size_t sum(double)`。

C++允许通过模板进行泛型编程，模板包含在 1998 年的标准中，但几年前就出现在带注释的 C++参考手册中。Java 允许通过泛型进行泛型编程，这是在 2004 年 Java 5 中引入的。

# [](#two-different-design-paradigms)两种不同的设计范式

它们表面上看起来很相似，但却有着截然不同的设计范例。C++模板使用代码生成，而 Java 泛型使用类型擦除。

类型擦除删除对象的类型，并在编译后的字节码中添加强制转换。它实际上并没有给语言增加任何新的东西。例如，如 [Java 泛型和集合](https://www.amazon.com/Java-Generics-Collections-Development-Process/dp/0596527756/)中所述，
的字节码

```
List words = new ArrayList();
words.add(“Hello”);
String s = (String) words.get(0); 
```

和

```
List<String> words = new ArrayList<>();
words.add(“Hello”);
String s = words.get(0) 
```

一模一样。这很奇怪，如果语法如此不同，为什么 Java 委员会决定他们应该输出相同的字节码？毕竟，插入强制转换并移除类型似乎会阻止潜在的优化。

另一种方法是泛型引入不同的字节码。然而，使用泛型并用 Java 5 编译的代码将不再与之前没有使用泛型编译的代码兼容。已经在使用 Java 的企业会犹豫是否要迁移到新版本。类型擦除是业务需求和语言增强之间的折衷。

类型擦除还确保了一个泛型类型只能有一个实现。比如`List<String>`、`List<Integer>`、`List<MyClass>`都有同样的`List`实现。

相比之下，C++模板从一开始就包含在标准中，使用代码生成，`vector<string>`、`vector<int>`和`vector<MyClass>`都有自己的实现。尽管这可能会增加每个翻译单元和最终可执行文件的大小，但特定于实现的类型为程序员提供了更大的灵活性，包括:

1.  模板函数和类的专门化支持优化。一个例子是`vector<bool>`，它是 vector 的一个节省空间的版本

2.  创建相同类型的成员变量。在 Java 中，类型擦除使得几乎不可能实例化一个类型的变量，例如`T[] t = new T[10];`另外，静态成员变量不能引用一个泛型类型

3.  静态多态，比如 STL 容器和使用 typedefs 进行泛型操作，比如使用迭代器

4.  许多复杂的东西，如策略特征和元编程，可以在编译时计算素数！

代码生成与类型擦除的影响会影响语言的性能和可读性。虽然模板为程序员提供了更大的灵活性，但是它们更难使用，因为复杂的规则会导致不方便的错误。此外，没有什么比阅读跨越数百个字符的神秘错误消息更枯燥的了。

简而言之，C++和 Java 有不同的模型来支持泛型编程。C++使用模板和代码生成，而 Java 使用泛型和类型擦除。