# 程序员的职责

> 原文：<https://dev.to/rehanvdm/programmer-responsibilities-h6j>

你将要做的工作将会在完成后很长一段时间内反映你的个性、信仰、纪律、想法和复杂程度。遵循符合公司政策的标准和实践是至关重要的，因为您编写的代码定义了公司本身。这是我写的指南，以确保一致的代码库和原则。

*这篇文章最初发表在我的[个人博客](https://www.rehanvdm.com/index.html)上。在这个帖子中表达的观点是我自己的。当我处于领导地位时，这是我强烈遵循并鼓励其他程序员这样做的事情。*

## 文档

如果没有记录，它就不存在！没有例外。

*   GIT 存储库的 Readme 文件上的文档，如果它是一个 API 的例子。然后记录请求、响应、认证、节流，并提供功能的简短描述。

*   然后还记录了系统的整体模块、实例；它是如何工作的，它使用什么数据库表，需要做什么支持来维护或设置模块，如何解决问题，等等。

*   始终保持文档更新。这将有助于你的队友，如果他们也在这个项目上工作，并打击技术债务。

## 安全

安全从我们开发人员开始。没有人会强迫你从一开始就增加安全性，这必须是一种选择。当然，它可能会在代码审查中被发现，但是没有人会成为你的合作伙伴来帮助你做出正确的决定。事实上，如果第一次安全编码在你的思维中还不是绝对的，现在就开始采用它。即使这意味着你会错过最后期限，也不要急于进行安全测试，要彻底测试。要记住的事情:

*   API 必须有安全凭证，要么在头中(基本的 Auth 就可以了)，要么在请求中有自定义的验证方法。HTTTPS 是必须的。

*   API 密钥的存储，存储在哪里，谁可以访问它们，如果 API 密钥被破坏，我可以多快替换它。

*   密码必须在数据库中散列，而不是加密或保持纯文本格式。

*   个人身份信息必须加密，如电话号码、姓名、电子邮件地址、身份证号码等。

*   **认证**就是验证你是谁的过程。示例:当您使用正在进行身份验证的用户名和密码登录 PC 时。对每个请求进行用户身份验证。对于 PHP，使用$_SESSION 对象(使用文件系统)，对于独立的 node.js API，使用 DB 或 Redis 之类的缓存作为存储级别。用户登录后，在记录中存储一个新生成的会话 id，然后让用户在所有后续请求中将它附加到请求的正文中。

*   **授权**是验证你有权访问某些东西的过程。这应该发生在认证之后。它验证您是否有权访问资源(例如，硬盘上的目录、管理网页)。

*   数据验证。不要相信任何用户输入总是做服务器端验证。如果你有一个 API，如果这个 API 只供内部使用，不要在每一步都验证用户输入，这可能被认为是没问题的。如果 API 向第三方公开，总是要添加验证。

*   数据安全。示例:删除记录时，确保它属于该客户，否则聪明的用户可以只输入一个随机 id 来删除一些不属于他的数据。然后确保所有的 S3 文件都是保密的，然后在需要的时候公开。首先是最低特权模式，然后放松权限。删除关联的数据库记录时也删除 S3 记录

*   数据有效性。不要将电话号码字段创建为 varchar，然后在前端允许任何类型的文本和数字。干净的数据对于数据库和应用程序正常工作至关重要。在前端，需要进行检查，以确保所有电话号码都是国际格式，前缀为+，没有空格，只有数字。这将提供所有应用程序(当前、未来、第三方)都可以“信任”的数据一致性。垃圾进垃圾出。

## 可靠性

建立最大的可靠性，考虑所有可能的结果，而不仅仅是成功的结果。晚上睡觉时，你应该有充分的信心，不会在凌晨 2 点被系统生成的大量错误邮件吵醒。如果你的代码失败了，它应该自己恢复，或者如果这根本不可能，那么就快速失败，以便采取另一个行动来补救这种情况。

*   自我恢复。自我恢复(重试逻辑)的一个例子是向队列(数据库存储)发送请求。如果你依赖第三方，例如发送短信/电子邮件/推送，当你调用的第三方 API 关闭时，要准备好解决方案。这意味着在发送之前记录(保存在数据库中)所有数据，然后尝试发送，如果发送失败，则在失败原因记录上增加一个计数器，然后增加请求失败的时间。然后有一个周期性的检查器，可能一分钟一次，它做一些逻辑来重试发送请求。在这里，指数后退策略非常有效。

    这样，如果下游出现故障，您系统将会恢复，因为它现在已经建立了一个队列。使用同步队列时要小心，因为这意味着客户端 A 必须等待客户端 B 的请求完成。要解决同步问题，可以执行一个查询来分割每个客户端的请求，然后同步发送每个请求。如果第三方提供者支持异步队列，最好总是使用异步队列。

*   快速失败。快速失败的一个例子是前端 web 界面(门户)。如果发生错误，通常是运行时错误，例如:用户没有正确的权限，因此他试图从不存在的会话中访问对象。快速失败，否则用户将在部分数据加载的屏幕上看到错误消息，这些数据可能是敏感的，因为他没有正确的权限查看它们。

## 错误处理

*   错误处理决定了您的可靠性程序将如何工作。所有的错误都需要被捕捉并采取行动，做最坏的打算。这个动作可以只是简单的记录或者通知负责人来修复错误。以下是一些需要记住的事情:

*   记录一切。当错误发生时，拍下错误的快照，例如至少节省时间和一些识别信息，以便您可以去查找它。

*   写日志的时候一定要保持一个模式，这样你就可以搜索关键词来缩小搜索范围。不要随便写字符串。示例模式:[严重级别]-[日期和时间]-[一条线性错误消息]-[包含更多信息的 JSON 对象]

*   所有的用户交互都应该被记录(使用 cloudwatch 和 API gateway lambdas 很容易做到这一点)。同样在前端，不需要记录每个页面加载/请求。一个好的策略是将最后 5 个页面加载/请求保存到会话，然后当出现错误时，发送所有“高级”堆栈跟踪和错误日志，也包括会话。这是非常有用的，因为您可以使用用户步骤来重现错误。

*   可靠性。实施自我恢复(跨国、传奇模式)或故障快速系统，无论选择哪一种，都要记录它们所做的一切。

## 技术债务

代码写完之后，需要维护。不仅是你的代码，还有它所依赖的框架，这意味着如果你的代码依赖于框架 A，而框架 A 有了更新，那么你也有责任保持框架是最新的。否则，如果你继续拖延，你会发现你自己(或者你的团队成员/下一个开发人员)处在一个框架已经有 10 年历史，而框架的开发已经在第 5 年停止的位置。从一个死的或者非常过时的框架转换到一个新的框架是一个主要的任务，举例来说，如果你和你的团队每年只花一周时间，然后将所有的框架升级到最新的版本，这一切都可以避免。

当没有记录任何东西，并且只有一个人负责系统的代码/特性时，技术债务也会增加。这是团队的责任，以确保这种情况不会发生，他们必须在最后期限和管理，以打击技术债务推回。

## 代码

*   哑+简单(吻)

    *   编写复杂的代码在个人层面上可能是有益的，但在团队开发中并不鼓励这样做，除非整个团队都处于同一水平。如果他们不这样做，对其他队友来说，你将很难保持和继续你的工作。所以要时刻记住下一个开发者。
    *   如果代码更容易阅读和理解，就多写一些，而不是写一行正则表达式，花两年时间才能理解。
    *   不惜一切代价避免 getters 和 setters，它隐藏了复杂性。使用方法和函数，您可以实现相同的功能。
    *   请记住，找到最佳解决方案不是一个解决方案，它必须在未来可扩展。暂时不要实现它，只要留有余地，如果它需要扩展，不需要完全重新设计系统就可以实现。
*   可读+干净

    *   命名变量和函数应该是不言自明的
    *   正面命名，例如不命名变量:isDisabled，而不是 name is isEnabled。我们的大脑处理积极的语言比消极的语言要好得多，例如:对于 isDisabled，你必须这样想:如果某个东西被禁用，那么它意味着它没有被启用，所以如果 isDisabled 为真，这段代码就不会工作。如果将它命名为 isEnabled，就可以更容易地建立关联。
    *   将长函数分解成子函数。
    *   只为重用的代码编写函数。如果你复制并粘贴了某个东西，你很可能已经为它写了一个函数。
    *   例如，如果您在一个具有类似功能的方法中编写代码，并且该代码只是在该方法中使用，那么就不需要将其分成更小的函数，因为它只会在一个地方使用。除非该方法增长到例如 300+行，那么它可以被分解成更小的函数。不是为了小函数的可重用性，而是为了增加使用它的大函数的可读性。
    *   避免嵌套代码，宁可提前退出函数。
*   一致性

    *   一致性是大型项目易于管理的原因。整个团队需要努力坚持项目的一致性。它必须看起来好像是一个开发人员自己编写了所有的代码，你不应该仅仅看一眼一段代码就说是开发人员 A 写的。
    *   争取一致性，即使是错的。例如，如果您注意到 DB 中的所有表都是蛇形的(由下划线分隔的小写字母)，那么您也应该保持相同的命名，因为当前的开发人员已经假定每个人都遵循相同的策略。
*   面向对象的程序设计(Object Oriented Programming)

    *   只在需要的时候。亲，不要试图把一个简单的问题分解成 1000 个类和接口(类爆炸)，这大大增加了复杂性，可维护性和可读性。
    *   也考虑其他方法，函数式编程。OOP 并不总是唯一的选择。

我不打算详细解释 SOLID hear，请谷歌一下，找到一篇好文章。下面是必不可少的概念采取一种方式(我的视角)

*   坚实的原则

    *   单一责任原则——一个类应该只有一个功能/任务。例如，一个人类应该只做人的功能，你不应该有任何描述这个人的宠物和汽车，只有像年龄和眼睛颜色的人相关的功能。然后，您可以为宠物和车辆创建其他类。
    *   **O** 笔关闭原则——对象应该打开以进行扩展，关闭以进行修改。这意味着每次需求改变时，你不应该回头改变类的核心。而是通过增加来扩展它。例如，使用 person 类作为亚洲人和非洲人的基类。这样，如果你改变了基本人类，你也将改变非洲和亚洲的类，因为它们扩展了基本人类。
    *   伊斯科夫替代原则——这通常是在使用面向对象程序时，特别是接口时。如果一个类继承自一个接口或基类，那么它可以被转换成那个基类或接口，因此不管这个人是亚洲人还是非洲人，我们在任何时候都可以肯定，他们都具有人的基本功能。这与依赖注入有关，这两点+工厂设计模式经常一起使用。
    *   接口分离原则——如果代码的客户/用户只想要某个特定的功能，那么不要给出更多。例如，如果他们只对一个人的实时特征感兴趣，向他们提供整个家庭的历史是不必要的。这是通过只将需要的接口应用于一个类，然后创建只具有某些接口而不是所有接口的对象来实现的。这一点没有其他的重要。
    *   **D** 依赖注入原理——这与第 3 点基本相同。如果你做了其他所有正确的事情，那么你现在就可以针对接口而不是类进行编码了。这意味着如果你有一个日志接口，和 2 个继承它的类，一个文件记录器和 api 记录器。两者都应该有日志函数，因此您可以将文件记录器或 api 记录器传递给需要日志接口的主错误日志记录函数。所以你的函数参数接受接口，而不是具体的类。
*   设计模式

    *   不要强行应用它们。很多时候，你可以通过使用普通的面向对象程序设计或者函数式编程来避免这种情况。
    *   保持简单如果你决定实现它，设计模式会引入复杂性，如果理解不正确的话。
    *   尝试使用最常用的基本模式，如果您不知道以下内容，请仔细阅读:
        *   Singleton(非常适合您的主数据库类)
        *   工厂模式(适用于结构相似但内部结构会因每个实现而变化的代码)
*   抽象

    *   再次强调，不要过度抽象。即使您可以面向对象或应用 SOLID，您也不必这样做，因为这会引入更多的复杂性并降低可读性。
*   评论

    *   评论不要太冗长，只写能让你的观点被理解的内容。
    *   写评论时，只写要点。随着代码的变化，很多时候注释会被忽略，那么代码和注释就会不一致。所以只写那些“经得起时间考验”的重要评论。
    *   单行注释解释了单行代码的作用。
    *   多行注释用于解释一个功能或多行代码的过程/概念是如何工作的。

## MVP

最小的 **V** 可行的 **P** 产品。只做需求中的事情，不要从未来的功能开始。否则你会做不必要的工作，浪费时间去创造一些很难被使用的东西。随着系统的使用，您可能会得到反馈，这将决定对该系统下一版本的变更请求。因此，总是做基本的需求，随着使用的增加，可以添加功能，使系统更加健壮。

> 在合理利用时间的意义上，要“懒”。

## 代码评审

开发团队是一个集体，一个共享的所有权。团队中没有我，如果你的团队成员写了糟糕的代码，整个团队都会受到指责。责任落在团队而不是个人身上。因此，为了实现这种统一，必须使用代码评审。在合并新代码之前，至少 2 名开发人员还必须阅读、理解并确保正确使用和遵循所有原则。

增强实现。不要批评它。记住开发者也是人，考虑他们的现状。以您希望收到的方式给出评论。

## 你神智清醒

记住你的个人生活。初级开发人员充满渴望和动力，这很好，但他们通常在早期运行 sprint，这在一个月左右是没问题的，之后你需要切换到马拉松模式来进行长期运行。以下是一些需要记住的事情。

*   坚持每天的例行公事，可以提高工作效率。
*   不要忘记锻炼。
*   保持健康的饮食和睡眠习惯
*   不要忽视人际关系
*   失意的时候，起来喝杯水，休息一下就好。对自己(变成鸭子)或另一个开发者说话总是有帮助的。你不是一个人，其他开发者可能会遇到同样的问题。
*   永远不要用“只是”这个词，如果你要用的话，把你的截止日期乘以 2。
*   有些人是创造者，有些人是修补者。决定你是什么，如果你没有达到你想达到的目标，你还有时间去努力实现它。
*   学习如何说不和谈判。谦虚一点
*   承认你的错误，我们都会犯