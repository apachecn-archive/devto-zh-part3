# 带有苦艾酒的 GraphQl:如何将数据映射到不同的结构

> 原文:[https://dev . to/revent/graph QL-with-absineither-how-to-map-data-to-different-structures-5897](https://dev.to/revent/graphql-with-absinthe-how-to-map-data-to-different-structures-5897)

在开始使用 graphql 搭配苦艾酒并发现一些[问题](https://dev.to/revent/graphql-with-absinthe-59kb)后，一切都变得美好而顺利。几天后，我遇到了一个情况，我们的数据源有一个不同于 graphql 中定义的数据结构。虽然实现起来非常简单，但我没有找到很多关于如何实现的资源。

##### [](#assertions)断言

*   你熟悉[仙丹](https://elixir-lang.org)。[哪里学的？](https://dev.to/matt24ray/best-resources-for-learning-elixir-467f)
*   你对 graphql 和苦艾酒都很熟悉。

##### [](#works-on-my-machine)在我的机器上工作

*   仙丹:1.7.3
*   凤凰城:1.4.0
*   苦艾酒:1.4.13

## [](#bussiness-rules)商业规则

现有的`user`实体有字段`name`，奇怪的是它不包含字符串，而是包含两个键(`first`和`last`)的映射(在 DB 中保存为 json)。但是 graphql 必须有`first_name`、`second_name`以及它们的组合值`full_name`才能和`id`并列。

## [](#initial-setup)初始设置

为了开始实现所需的业务需求，通常需要一些引导代码。这也不例外。

我们必须实现四个模块:

*   `MyApp.Schema` - > graphql 结构、查询和突变。
*   `MyApp.UsersRepository` - >表示现有的储存库。
*   `MyApp.UsersRepository.User` - >代表现有的外图式。
*   `MyApp.UsersResolver` - >图 ql 解析回调 s。

本例中的`MyApp.UsersRepository`和`MyApp.UsersRepository.User`都在 graphql 边界之外。这部分代码应该存在于不同的上下文中，并且不应该受到任何影响，因为现在它有一个新的消费者(graphql)需要不同的数据结构。

注意，`MyApp.Schema`定义了一个对象`user`，它具有业务规则中描述的字段，但是`MyApp.UsersRepository`期望名称值嵌套在`name`键下(表示现有的存储库结构)。

```
defmodule MyApp.Schema do
  @moduledoc """
    GraphQL schema description (available objects, queries and mutations)
  """

  use Absinthe.Schema

  alias MyApp.UsersResolver

  @doc """
    User object with few scalar fields
  """
  object :user do
    field :id, :integer
    field :first_name, :string
    field :last_name, :string
    field :full_name, :string
  end
end

defmodule MyApp.UsersRepository do
  @moduledoc """
    Actual repository, used as change boundary.
    This code will not change at all during this blog post.
  """

  defmodule User do
    @moduledoc """
      In a real-life scenario, this most likely would be an ecto schema.

      For sake of example, simple struct will also do.
    """
    defstruct id: nil, name: %{"first" => nil, "last" => nil}
  end

  @doc """
    Gets a list of users from the data source.
    In real life scenario most likely from DB via ecto.

    In this case list with one hardcoded user.
  """
  def get_all() do
    [%User{id: 1, name: %{"first" => "John", "last" => "Doe"}}]
  end

  @doc """
    Creates a user in a data store.
    In real life scenario most likely to DB via ecto.

    In this case, checks if data has required structure and if so, add id (like autogenerated id value).
  """
  def create(%User{name: %{"first" => _, "last" => _}} = user), do: {:ok, %{user | id: 10}}
  def create(_), do: {:error, "Wrong structure"}
end

defmodule MyApp.UsersResolver do
  @moduledoc """
    Handles data processing for graphql.

    Sort of like repository, but defined as graphql resolve callbacks.
  """
  alias MyApp.UsersRepository
  alias MyApp.UsersRepository.User
end 
```

## [](#receiving-data)接收数据

我们需要能够进行如下查询:

```
query {
  users {
    firstName,
    lastName,
    fullName
  }
} 
```

所以我们需要添加带有`users`字段的`query`块。
在`MyApp.UsersResolver`中，我们为用户查询创建了一个被定义为解析器的函数。与通常情况下数据映射`1:1`的唯一区别是，我们使用`&Enum.map/2`用`&to_graphql/1`迭代来自`&MyApp.UsersRepository.get_all/0`的结果，并且可以创建我们需要的任何结构。

> 注意，默认情况下，graphql 需要 atom 键。如果需要的话，它[可以被改变](https://elixirforum.com/t/serialisation-atoms/4879/4)。

```
defmodule MyApp.Schema do
  ...

  @doc """
    Makes query `users` available for API consumers. 
    The query is expected to return a list of `user` objects.
    `&UsersResolver.fetch_users/3` is responsible to make that happen
  """
  query do
    field :users, list_of(:user), resolve: &UsersResolver.fetch_users/3
  end
end

defmodule MyApp.UsersResolver do
  ...

  @doc """
    Fetches all users from the repository.
  """
  def fetch_users(_, _, _) do
    users = UsersRepository.get_all() |> Enum.map(&to_graphql/1)
    {:ok, users}
  end

  @doc """
    Map data from user instance to one required by graphql api.
  """
  defp to_graphql(%User{id: id, name: %{"first" => first, "last" => last}}) do
    %{id: id, first_name: first, last_name: last, full_name: "#{first}  #{last}"}
  end
end 
```

现在执行所需的查询，我们得到预期的输出:

```
{  "data":  {  "users":  [  {  "lastName":  "Doe",  "fullName":  "John Doe",  "firstName":  "John"  }  ]  }  } 
```

## [](#mutation-mapping)突变映射

这是一个我们需要能够执行的变异:

```
mutation {
  createUser(firstName: "Doe", lastName: "John") {
    id
    fullName
  }
} 
```

在这里，苦艾酒变得更加复杂了。不多，但还是。
首先，现在我们板条箱突变。然后在`create_user` resolver 中，我们采用第二个参数，因为它是通过 graphql 传递的参数所在的位置。
我们用`to_graphql`做了一个类似的贴图，但方向相反。

```
defmodule MyApp.Schema do
  ...

  @doc """
    Mutation to create a new user
    Two fields are required, and mutation is expected to return created user instance.
  """
  mutation do
    field :create_user, :user do
      arg :first_name, non_null(:string)
      arg :last_name, non_null(:string)

      resolve &UsersResolver.create_user/3
    end
  end
end

defmodule MyApp.UsersResolver do
  ...

  @doc """
    Creates a new user to repository.
  """
  def create_user(_, args, _) do
    args |> from_graphql |> UsersRepository.create()
  end

  @doc """
    Converts graphql structure to one required by the repository.
  """
  defp from_graphql(%{first_name: first, last_name: last}) do
    %User{name: %{"first" => first, "last" => last}}
  end
end 
```

而我们期望得到的回应是:

```
{  "data":  {  "createUser":  {  "id":  10,  "fullName":  "Doe John"  }  }  } 
```

但这并不是我们实际得到的。`fullName`为空。原因是`&MyApp.UsersResolver. create_user/3`解析器回调返回`User`结构(从`MyApp.UsersRepository.create/1`接收)。解析器应该总是返回 graphql 有效结构。为了解决这个问题，我们需要用之前使用的`&to_graphql/1`将`User`结构值映射回 graphql，如下所示:

```
defmodule MyApp.UsersResolver do
  ...

  def create_user(_, args, _) do
    args 
    |> from_graphql 
    |> UsersRepository.create()
    |> case do
      {:ok, user} -> {:ok, to_graphql(user)}
      error -> error
    end
  end
end 
```

现在所需的突变实际上返回了先前所预期的结果。

## [](#in-conclusion)总之

*   graphql 不会干扰数据解析。解析回调是简单的灵丹妙药，你可以随心所欲地操纵数据。默认情况下，地图应该有原子键，但是它[可以被改变](https://elixirforum.com/t/serialisation-atoms/4879/4)。
*   在`MyApp.Schema`和`MyApp.UsersRepository`之间创建`MyApp.UsersResolver`是将模型分割成单独用例的一个好方法。每个模型只处理[一个特定的任务](https://codeburst.io/understanding-solid-principles-single-responsibility-b7c7ec0bf80)。
*   返回对象的变异解析器应该考虑到，变异回调必须返回 graphql 有效结构中的对象(如果需要的话，变异返回数据)。
*   突变回调是唯一做两项工作的地方，保存数据和准备响应。如果我们应用一些 CQS 的东西，那么突变最多会返回新生成的 id，所以在这种情况下不需要响应映射。

我仍然是 graphql 的新手，但我真的很喜欢我所看到的。

附言:如果你对这个话题有任何反馈、建议、问题或想法，请告诉我:)

#### [](#pps-whole-code-without-comments)P.P.S 整个代码不带注释

```
defmodule MyApp.Schema do
  use Absinthe.Schema

  alias MyApp.UsersResolver

  object :user do
    field :id, :integer
    field :first_name, :string
    field :last_name, :string
    field :full_name, :string
  end

  query do
    field :users, list_of(:user), resolve: &UsersResolver.fetch_users/3
  end

  mutation do
    field :create_user, :user do
      arg :first_name, non_null(:string)
      arg :last_name, non_null(:string)

      resolve &UsersResolver.create_user/3
    end
  end
end

defmodule MyApp.UsersRepository do
  defmodule User do
    defstruct id: nil, name: %{"first" => nil, "last" => nil}
  end

  def get_all() do
    [%User{id: 1, name: %{"first" => "John", "last" => "Doe"}}]
  end

  def create(%User{name: %{"first" => _, "last" => _}} = user), do: {:ok, %{user | id: 10}}
  def create(_), do: {:error, "Wrong structure"}
end

defmodule MyApp.UsersResolver do
  alias MyApp.UsersRepository
  alias MyApp.UsersRepository.User

  def fetch_users(_, _, _) do
    users = UsersRepository.get_all() |> Enum.map(&to_graphql/1)
    {:ok, users}
  end

  def create_user(_, args, _) do
    args
    |> from_graphql
    |> UsersRepository.create()
    |> case do
      {:ok, user} -> {:ok, to_graphql(user)}
      error -> error
    end
  end

  defp to_graphql(%User{id: id, name: %{"first" => first, "last" => last}}) do
    %{id: id, first_name: first, last_name: last, full_name: "#{first}  #{last}"}
  end

  defp from_graphql(%{first_name: first, last_name: last}) do
    %User{name: %{"first" => first, "last" => last}}
  end
end 
```