# redis:Sentinel–bind 0 . 0 . 0 . 0，本地主机问题和 announce-ip 选项

> 原文:[https://dev . to/setevoy/redis-sentinel-bind-0-0-0-0-the-localhost-issue-and-the-announce-IP-option-m4e](https://dev.to/setevoy/redis-sentinel-bind-0-0-0-0-the-localhost-issue-and-the-announce-ip-option-m4e)

[![](../Images/f6d45197b0b18a1a39702233dbf5afe7.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--rqSEDlVy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://rtfm.co.ua/wp-content/uploads/2018/05/redislogo.png) 最初，在 Sentinel 的配置中，我使用了`bind 0.0.0.0`使它们可以从外部主机访问。

由于这个原因，当我开始在一个真实的环境中推出这个设置时，面临着哨兵不能确定主控主机和其他哨兵主机的问题。

在本帖中——这样一个问题的例子及其解决方案。

事实上——有更多的问题(在周五晚上),但我无法重现(在周一早上)。

当我从 Ansible 角色中执行 Redis 复制时出现了问题，因此这里的一些示例将出现在 Ansible 的模板中。

### [](#the-current-setup)当前设置

Redis 节点和 Sentinel 实例运行在 AWS EC2 服务器上。

在下面的例子中将使用下一个名称:

1.  *控制台*主机:也是一个主节点——这里是 Redis 主节点运行和第一个 Sentinel 实例
2.  *App1* 和 *App2* :另外两个ес2，带有 Redis 副本和两个 Sentinel 实例

#### [](#redis-replication-configs)重定向复制配置

Redis 主配置，只是主要部分。文件`redis-cluster-master.conf.j2` :

```
bind 0.0.0.0
port 6389... 
```

从节点，公共配置，文件`redis-cluster-slave.conf.j2` :

```
slaveof dev.backend-console-internal.example.com 6379
bind 0.0.0.0
port 6389... 
```

部署，检查:

```
root@bttrm-dev-console:/etc/redis-cluster# redis-cli -p 6389 info replication
Replication
role:master
connected_slaves:2
slave0:ip=10.0.2.91,port=6389,state=online,offset=1219,lag=1
slave1:ip=10.0.2.71,port=6389,state=online,offset=1219,lag=1
... 
```

目前为止还不错。

#### [](#redis-sentinels-configs)重复哨兵配置

现在一个哨兵配置-`redis-cluster-sentinel.conf.j2`:

```
sentinel monitor {{ redis_cluster_name }} dev.backend-console-internal.example.com 6389 2
bind 0.0.0.0
port 26389
sentinel down-after-milliseconds {{ redis_cluster_name }} 6001
sentinel failover-timeout {{ redis_cluster_name }} 60000
sentinel parallel-syncs {{ redis_cluster_name }} 1
daemonize yes
logfile {{ redis_cluster_logs_home }}/redis-sentinel.log
pidfile {{ redis_cluster_runtime_home }}/redis-sentinel.pid 
```

部署，检查:

```
root@bttrm-dev-console:/etc/redis-cluster# redis-cli -p 26389 info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=redis-dev-cluster,status=ok,address=127.0.0.1:6389,slaves=2,sentinels=3 
```

看起来还不错？

但是没有。

### [](#an-ips-issue)一个 IPs 问题

在 *App-1* :
上查看哨兵的日志

```
root@bttrm-dev-app-1:/etc/redis-cluster# tail -f /var/log/redis-cluster/redis-sentinel.log

3163:X 08 Apr 14:24:18.586 * +sentinel-address-switch master redis-dev-cluster 10.0.2.104 6389 ip 10.0.2.104 port 26389 for 32aca990c4e875eab7ba8cd0a7c4e984d584e18c

3163:X 08 Apr 14:24:19.034 * +sentinel-address-switch master redis-dev-cluster 10.0.2.104 6389 ip 127.0.0.1 port 26389 for 32aca990c4e875eab7ba8cd0a7c4e984d584e18c

3163:X 08 Apr 14:24:20.653 * +sentinel-address-switch master redis-dev-cluster 10.0.2.104 6389 ip 10.0.2.104 port 26389 for 32aca990c4e875eab7ba8cd0a7c4e984d584e18c 
```

并且它的配置已经被 Sentinel 更新:

```
root@bttrm-dev-app-1:/etc/redis-cluster# cat redis-sentinel.conf
sentinel myid a8fdd554a587467aadd811989c78d601433a2f37
bind 0.0.0.0
port 26389
sentinel monitor redis-dev-cluster 10.0.2.104 6389 2
...
# Generated by CONFIG REWRITE
dir "/"
maxclients 4064
sentinel config-epoch redis-dev-cluster 0
sentinel leader-epoch redis-dev-cluster 0
sentinel known-slave redis-dev-cluster 10.0.2.71 6389
sentinel known-slave redis-dev-cluster 10.0.2.91 6389
sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d
sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 32aca990c4e875eab7ba8cd0a7c4e984d584e18c
sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 a8fdd554a587467aadd811989c78d601433a2f37
sentinel current-epoch 0 
```

这里同时有两个问题:

1.  *sentinel-address-switch 主机 redis-dev-cluster 10.0.2.104 6389 ip 127.0.0.1*–在日志中，我们看到主机的 IP 在 10 . 0 . 2 . 104(主机的 EC2 地址)和 127 . 0 . 0 . 1 之间不断变化
2.  在 Sentinel 配置中添加了三条记录`known-sentinel`,尽管必须只有两条，与主配置相同

稍后将回到主界面，现在让我们再看一下哨兵的配置。

在`sentinel myid a8fdd554a587467aadd811989c78d601433a2f37`行中，我们可以看到这个特定 Sentinel 实例的 ID。

再次检查配置:

```
sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d

sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 32aca990c4e875eab7ba8cd0a7c4e984d584e18c

sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 a8fdd554a587467aadd811989c78d601433a2f37 
```

这里:

*   `10.0.2.91 26389 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d`–哨兵是否在 *App-2* 上
*   `127.0.0.1 26389 32aca990c4e875eab7ba8cd0a7c4e984d584e18c`–是师父(！)在*控制台*上，其 IP–**127 . 0 . 0 . 1**，虽然我们是从 *App-1* 主机上检查的
*   `127.0.0.1 26389 a8fdd554a587467aadd811989c78d601433a2f37`–是 *App-1* 上的哨兵，即当前实例

类似的图片在 *App-2* 主机:

```
root@bttrm-dev-app-2:/etc/redis-cluster# cat redis-sentinel.conf
sentinel myid 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d
bind 0.0.0.0
port 26389
sentinel monitor redis-dev-cluster 10.0.2.104 6389 2
...
Generated by CONFIG REWRITE
dir "/"
maxclients 4064
sentinel config-epoch redis-dev-cluster 0
sentinel leader-epoch redis-dev-cluster 0
sentinel known-slave redis-dev-cluster 10.0.2.71 6389
sentinel known-slave redis-dev-cluster 10.0.2.91 6389
sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d
sentinel known-sentinel redis-dev-cluster 127.0.0.1 26389 32aca990c4e875eab7ba8cd0a7c4e984d584e18c
sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 a8fdd554a587467aadd811989c78d601433a2f37
sentinel current-epoch 0 
```

作为比较，主设备的哨兵配置:

```
root@bttrm-dev-console:/etc/redis-cluster# cat redis-sentinel.conf
sentinel myid 32aca990c4e875eab7ba8cd0a7c4e984d584e18c
bind 0.0.0.0
port 26389
sentinel monitor redis-dev-cluster 127.0.0.1 6389 2
...
Generated by CONFIG REWRITE
dir "/"
maxclients 4064
sentinel config-epoch redis-dev-cluster 0
sentinel leader-epoch redis-dev-cluster 0
sentinel known-slave redis-dev-cluster 10.0.2.91 6389
sentinel known-slave redis-dev-cluster 10.0.2.71 6389
sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d
sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 a8fdd554a587467aadd811989c78d601433a2f37
sentinel current-epoch 0 
```

此外，在主设备和从设备上执行`info sentinel`时，会有不同的哨兵编号:

```
root@bttrm-dev-console:/etc/redis-cluster# redis-cli -p 26389 info sentinel | tail -1

master0:name=redis-dev-cluster,status=ok,address=127.0.0.1:6389,slaves=2,sentinels=3 
```

还有那些奴隶:

```
root@bttrm-dev-app-1:/etc/redis-cluster# redis-cli -p 26389 info sentinel | tail -1

master0:name=redis-dev-cluster,status=ok,address=10.0.2.104:6389,slaves=2,sentinels=4 
```

即:

1.  起初 Sentinel 实例将自己添加到了`known-sentinel`中，尽管它不应该这样做
2.  第二件事——主机被添加为 *127.0.0.1* ,而不是它的真实 IP

这在新的主选举中导致了一个真正的问题。

阻止雷伊斯大师:

```
root@bttrm-dev-console:/etc/redis-cluster# systemctl stop redis-cluster.service 
```

检查主控主机上的 Sentinel 日志:

```
30848:X 08 Apr 14:36:36.155 # +sdown master redis-dev-cluster 127.0.0.1 6389
30848:X 08 Apr 14:36:36.436 # +new-epoch 1 
```

这里根本没有`odown` ( *目标下降*)(见 [SDOWN 和 ODOWN 故障状态](https://redis.io/topics/sentinel#sdown-and-odown-failure-state))

在两个奴隶上，没有选举过程完成。

*App-1* 日志:

```
3163:X 08 Apr 14:36:36.087 # +sdown master redis-dev-cluster 10.0.2.104 6389
3163:X 08 Apr 14:36:36.155 # +odown master redis-dev-cluster 10.0.2.104 6389 #quorum 2/2
3163:X 08 Apr 14:36:36.155 # +new-epoch 1
3163:X 08 Apr 14:36:36.155 # +try-failover master redis-dev-cluster 10.0.2.104 6389
3163:X 08 Apr 14:36:36.157 # +vote-for-leader a8fdd554a587467aadd811989c78d601433a2f37 1
3163:X 08 Apr 14:36:36.158 # a8fdd554a587467aadd811989c78d601433a2f37 voted for a8fdd554a587467aadd811989c78d601433a2f37 1
3163:X 08 Apr 14:36:36.163 # 8a705b2e0050b0bd8935e1c3efd1a28fde5d581d voted for a8fdd554a587467aadd811989c78d601433a2f37 1
3163:X 08 Apr 14:36:36.220 # +elected-leader master redis-dev-cluster 10.0.2.104 6389
3163:X 08 Apr 14:36:36.220 # +failover-state-select-slave master redis-dev-cluster 10.0.2.104 6389
3163:X 08 Apr 14:36:36.311 # -failover-abort-no-good-slave master redis-dev-cluster 10.0.2.104 6389
3163:X 08 Apr 14:36:36.377 # Next failover delay: I will not start a failover before Mon Apr  8 14:38:36 2019 
```

App-2 :

```
3165:X 08 Apr 14:36:36.160 # +new-epoch 1
3165:X 08 Apr 14:36:36.162 # +vote-for-leader a8fdd554a587467aadd811989c78d601433a2f37 1
3165:X 08 Apr 14:36:36.168 # +sdown master redis-dev-cluster 10.0.2.104 6389
3165:X 08 Apr 14:36:36.235 # +odown master redis-dev-cluster 10.0.2.104 6389 #quorum 3/2
3165:X 08 Apr 14:36:36.235 # Next failover delay: I will not start a failover before Mon Apr  8 14:38:36 2019 
```

垃圾。

### [](#the-solution)解

解决方案是在每个 Sentinel 的实例配置中添加`sentinel announce-ip`。

查看 [Sentinel、Docker、NAT 和可能的问题](https://redis.io/topics/sentinel#sentinel-docker-nat-and-possible-issues)虽然我不明白为什么这出现在实例之间没有 NAT 的 EC2 的私有网络中。

停止 Sentinels，将它们的配置恢复到原始视图，并添加带有公共 IP 的`sentinel announce-ip`(这里的“公共”是一个实例的私有 IP，因为它们都在 VPC 的私有网络中)。

比如说。在母版上，它看起来像:

```
bind 0.0.0.0
port 26389
sentinel monitor redis-dev-cluster dev.backend-console-internal.example.com 6389 2
sentinel down-after-milliseconds redis-dev-cluster 6001
sentinel failover-timeout redis-dev-cluster 60000
daemonize yes
logfile "/var/log/redis-cluster/redis-sentinel.log"
pidfile "/var/run/redis-cluster/redis-sentinel.pid"
sentinel announce-ip 10.0.2.104 
```

检查主控主机上 Sentinel 的状态:

```
root@bttrm-dev-console:/etc/redis-cluster# redis-cli -p 26389 info sentinel
Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=redis-dev-cluster,status=ok,address=127.0.0.1:6389,slaves=1,sentinels=3 
```

和配置。

主人:

```
root@bttrm-dev-console:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 6072b737a93cf7812388be21360b5cb058343f4d

sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 57869e8b8914861cc5a80895d3fede9259ce11f6 
```

好吧…

*App-1* :

```
root@bttrm-dev-app-1:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 6072b737a93cf7812388be21360b5cb058343f4d

sentinel known-sentinel redis-dev-cluster 10.0.2.104 26389 1218b46be16fb759d52de6919de787c5492b4991 
```

好吧…

App-2 :

```
root@bttrm-dev-app-2:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 57869e8b8914861cc5a80895d3fede9259ce11f6

sentinel known-sentinel redis-dev-cluster 10.0.2.104 26389 1218b46be16fb759d52de6919de787c5492b4991 
```

好吧。

最后，将它添加到一个 Ansible 模板中。

为了不为每个主机创建专用模板，可以使用`lookup()`，参见 [Ansible:获取目标主机的 IP](https://rtfm.co.ua/en/ansible-get-a-target-hosts-ip/) 。

更新`redis-cluster-sentinel.conf.j2` :

```
sentinel monitor {{ redis_cluster_name }} dev.backend-console-internal.example.com 6389 2
bind 0.0.0.0
port 26389
sentinel announce-ip {{ hostvars[inventory_hostname]['ansible_default_ipv4']['address'] }}
sentinel down-after-milliseconds {{ redis_cluster_name }} 6001
sentinel failover-timeout {{ redis_cluster_name }} 60000
sentinel parallel-syncs {{ redis_cluster_name }} 1
daemonize yes
logfile {{ redis_cluster_logs_home }}/redis-sentinel.log
pidfile {{ redis_cluster_runtime_home }}/redis-sentinel.pid 
```

*顺便说一下:您可以使用相同的方法，但是只需使用`bind`参数。*

展开，检查。

主人:

```
root@bttrm-dev-console:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 8148dc7b30a692af02aee44ff051bee129710618

sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 156a28ee1c3db77876c0e7326694313c24a56dc2 
```

*App-1* :

```
root@bttrm-dev-app-1:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.91 26389 156a28ee1c3db77876c0e7326694313c24a56dc2

sentinel known-sentinel redis-dev-cluster 10.0.2.104 26389 b1fafcde1685861736930c7a88819b2aeac49eea 
```

App-2 :

```
root@bttrm-dev-app-2:/etc/redis-cluster# cat redis-sentinel.conf | grep known-sentinel

sentinel known-sentinel redis-dev-cluster 10.0.2.71 26389 8148dc7b30a692af02aee44ff051bee129710618

sentinel known-sentinel redis-dev-cluster 10.0.2.104 26389 b1fafcde1685861736930c7a88819b2aeac49eea 
```

*“管用！”* (c)

但是这条路——不断地`sentinel-address-switch master`也消失了。

现在，让我们停止 Redis Maser，检查故障转移是否可行。

这时候哨兵的 id 出现了:

1.  *控制台/主机*:B1 fafcde 1685861736930 c7a 88819 B2 aeac 49 EEA
2.  *app 1*:8148 DC 7b 30 a 692 af 02 AE 44 ff 051 bee 129710618
3.  *app 2*:156 a 28 ee 1 C3 db 77876 c0e 7326694313 c 24 a 56 DC 2

主人日志:

```
1744:X 08 Apr 16:17:15.495 # +sdown master redis-dev-cluster 127.0.0.1 6389

1744:X 08 Apr 16:17:15.745 # +new-epoch 1

1744:X 08 Apr 16:17:16.809 # +config-update-from sentinel 156a28ee1c3db77876c0e7326694313c24a56dc2 10.0.2.91 26389 @ redis-dev-cluster 127.0.0.1 6389

1744:X 08 Apr 16:17:16.809 # +switch-master redis-dev-cluster 127.0.0.1 6389 10.0.2.71 6389

1744:X 08 Apr 16:17:16.809 * +slave slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.71 6389

1744:X 08 Apr 16:17:16.809 * +slave slave 127.0.0.1:6389 127.0.0.1 6389 @ redis-dev-cluster 10.0.2.71 6389

1744:X 08 Apr 16:17:22.823 # +sdown slave 127.0.0.1:6389 127.0.0.1 6389 @ redis-dev-cluster 10.0.2.71 6389 
```

*App-1* :

```
4954:X 08 Apr 16:17:15.411 # +sdown master redis-dev-cluster 10.0.2.104 6389

4954:X 08 Apr 16:17:15.548 # +new-epoch 1

4954:X 08 Apr 16:17:15.550 # +vote-for-leader 156a28ee1c3db77876c0e7326694313c24a56dc2 1

4954:X 08 Apr 16:17:16.539 # +odown master redis-dev-cluster 10.0.2.104 6389 #quorum 2/2

4954:X 08 Apr 16:17:16.540 # Next failover delay: I will not start a failover before Mon Apr  8 16:19:16 2019

4954:X 08 Apr 16:17:16.809 # +config-update-from sentinel 156a28ee1c3db77876c0e7326694313c24a56dc2 10.0.2.91 26389 @ redis-dev-cluster 10.0.2.104 6389

4954:X 08 Apr 16:17:16.809 # +switch-master redis-dev-cluster 10.0.2.104 6389 10.0.2.71 6389

4954:X 08 Apr 16:17:16.810 * +slave slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.71 6389

4954:X 08 Apr 16:17:16.810 * +slave slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389

4954:X 08 Apr 16:17:22.859 # +sdown slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389 
```

以及 *App-2* :

```
4880:X 08 Apr 16:17:15.442 # +sdown master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.542 # +odown master redis-dev-cluster 10.0.2.104 6389 #quorum 2/2

4880:X 08 Apr 16:17:15.543 # +new-epoch 1

4880:X 08 Apr 16:17:15.543 # +try-failover master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.545 # +vote-for-leader 156a28ee1c3db77876c0e7326694313c24a56dc2 1

4880:X 08 Apr 16:17:15.551 # 8148dc7b30a692af02aee44ff051bee129710618 voted for 156a28ee1c3db77876c0e7326694313c24a56dc2 1

4880:X 08 Apr 16:17:15.604 # +elected-leader master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.604 # +failover-state-select-slave master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.671 # +selected-slave slave 10.0.2.71:6389 10.0.2.71 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.671 * +failover-state-send-slaveof-noone slave 10.0.2.71:6389 10.0.2.71 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:15.742 * +failover-state-wait-promotion slave 10.0.2.71:6389 10.0.2.71 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:16.711 # +promoted-slave slave 10.0.2.71:6389 10.0.2.71 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:16.712 # +failover-state-reconf-slaves master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:16.808 * +slave-reconf-sent slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:17.682 # -odown master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:17.759 * +slave-reconf-inprog slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:17.759 * +slave-reconf-done slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:17.849 # +failover-end master redis-dev-cluster 10.0.2.104 6389

4880:X 08 Apr 16:17:17.849 # +switch-master redis-dev-cluster 10.0.2.104 6389 10.0.2.71 6389

4880:X 08 Apr 16:17:17.850 * +slave slave 10.0.2.91:6389 10.0.2.91 6389 @ redis-dev-cluster 10.0.2.71 6389

4880:X 08 Apr 16:17:17.850 * +slave slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389

4880:X 08 Apr 16:17:23.853 # +sdown slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389 
```

检查当前主机的 IP:

```
root@bttrm-dev-console:/etc/redis-cluster# redis-cli -h 10.0.2.104 -p 26389 sentinel get-master-addr-by-name redis-dev-cluster
1) "10.0.2.71"
2) "6389" 
```

*10 . 0 . 2 . 71*——是 *App-1* 主机。

在此检查复制状态:

```
root@bttrm-dev-app-1:/etc/redis-cluster# redis-cli -p 6389 info replication
Replication
role:master
connected_slaves:1
slave0:ip=10.0.2.91,port=6389,state=online,offset=70814,lag=1 
```

*角色:主人*–角色切换工作正常，一切正常。

*slave 0:IP = 10 . 0 . 2 . 91*–主主机上只有一个作为 Redis 节点的从机被停止。

开始吧:

```
root@bttrm-dev-console:/etc/redis-cluster# systemctl start redis-cluster.service 
```

哨兵日志:

```
4954:X 08 Apr 16:23:43.337 # -sdown slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389

4954:X 08 Apr 16:23:53.351 * +convert-to-slave slave 10.0.2.104:6389 10.0.2.104 6389 @ redis-dev-cluster 10.0.2.71 6389 
```

Nod 启动了，Sentinel 把它改成了奴隶模式。

当 Redis Sentinel 以这种方式重新配置 Redis 节点时，也看到了另一个问题，当它成为自身的奴隶时:

```
14542:S 04 Apr 13:25:35.187 * SLAVE OF 127.0.0.1:6389 enabled (user request from ‘id=15 addr=10.0.2.104:40087 fd=5 name=sentinel-dc0483ad-cmd age=60 idle=0 flags=x db=0 sub=0 psub=0 multi=3 qbuf=0 qbuf-free=32768 obl=36 oll=0 omem=0 event
s=r cmd=exec’)
14542:S 04 Apr 13:25:35.187 # CONFIG REWRITE executed with success.
14542:S 04 Apr 13:25:36.059 * Connecting to MASTER 127.0.0.1:6389
14542:S 04 Apr 13:25:36.060 * MASTER <-> SLAVE sync started
14542:S 04 Apr 13:25:36.060 * Non blocking connect for SYNC fired the event.
14542:S 04 Apr 13:25:36.060 * Master replied to PING, replication can continue…
14542:S 04 Apr 13:25:36.060 * Partial resynchronization not possible (no cached master)
14542:S 04 Apr 13:25:36.060 * Master does not support PSYNC or is in error state (reply: -ERR Can’t SYNC while not connected with my master) 
```

不幸的是，无法重现。

### [](#similar-posts)类似的帖子

*   <small>2019 年 1 月 4 日</small>[【Redis:复制，第 3 部分──redis py 与 Python 的 redis 哨兵一起工作](https://dev.to/setevoy/redis-replication-part-3-redis-py-and-work-with-redis-sentinel-from-python-mb9)<small></small>
<small>*   <small>04/03/2019</small> [Redis:无法打开日志文件:只读文件系统](https://dev.to/setevoy/redis-can-t-open-the-log-file-read-only-file-system-2lam-temp-slug-7278275) <small>(0)</small>*   <small>03/29/2019</small> [Redis:复制，第 2 部分-主从复制，Redis Sentinel](https://dev.to/setevoy/redis-replication-part-2-master-slave-replication-and-redis-sentinel-1hoe) <small>(0)</small></small>

<small></small>