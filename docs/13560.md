# 我希望我拥有的测试介绍

> 原文:[https://dev . to/Maxwell _ dev/the-testing-introduction-I-wish-I-had-2dn](https://dev.to/maxwell_dev/the-testing-introduction-i-wish-i-had-2dn)

鉴于我早就应该了解的话题并不缺乏，我很惊讶花了这么长时间才又写了一篇“我希望我有过的介绍”这一次，我要报道一个重要的、经常被忽视的话题，现实地说，这个话题比任何其他事情都更能打动我，除了那个黑暗的纽约之夜，我没有弹弓也没有皮凉鞋就走进了一个黑暗的小巷。

当然，我指的是**测试。**

正如任何有经验的程序员或 Maury show 的嘉宾会告诉你的，运行良好的测试从长远来看会帮助你避免严重的痛苦。然而它们很容易被忽略——在我编程的最初几年，很容易(可以理解)假设我的程序一旦完成就会一直工作良好。但是后来我了解到，在专业编程岗位上很少会出现这种情况。

这就是测试的由来。这篇文章是对测试要点的高度概括，包括:

*   不同类型的测试
*   为什么测试很重要
*   测试经验法则

这篇文章是写给几年前的我(从某些方面来说，今天仍然是)这种程序员的——知道代码测试，但不知道细节或为什么它是必要的。希望你在读完这篇文章后会有不同的想法，或者至少知道足够多的东西来让周围的人相信你已经改变了。

虽然我更喜欢第一种选择，但作家不能挑三拣四。所以让我们开始吧！

## [](#the-different-types-of-tests)不同类型的测试

让我们从不同类型的测试的概述开始，在可能的地方加入具体的例子。

### [](#unit-tests)单元测试

单元测试是对程序中尽可能小的部分的最简单的测试。它们通常用于函数或对象，确保它们返回带有特定输入的期望值。

假设你有一个将两个数相加的函数。测试将确定如果你给它 2 和 2，函数将返回 4。它不会在不同的环境中测试它，比如作为计算器组件的一部分。单元测试将功能独立出来，并确保它们适用于任何环境。

单元测试可以确保你的应用保持强大的基础。它帮助我避免了许多徒劳的调试，因为我知道应用程序的核心是好的，所以这可能是我如何使用这些核心功能的。

这是我在 Ember 为一个个性测验写的一个单元测试例子。它测试了一项管理特定测验功能的服务，如回答问题和跟踪答案。

```
test('it knows when you\'re finished', function(assert) {
  let quiz = this.owner.lookup('service:quiz'),
      quiz_length = quiz.get('length');

  assert.equal(quiz.get('completed'), false, 'the completed property starts as false');
  assert.equal(quiz.get('winner'), '', 'it starts with no winning result');

  for (let i = 1; i < quiz_length; i++) {
    quiz.selectAnswer(i, 'espeon');
  }

  assert.equal(quiz.get('completed'), true, 'the completed property becomes true');
  assert.equal(quiz.get('winner'), 'espeon', 'it learns the winning result');
  clearAllCookies();
}); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我所做的不过是确保 *X 属性返回它应该返回的 Y 值。*在这种情况下，它用于服务的`completed`和`winner`属性。

另一个例子是我写的一个简单的 Ruby 程序，用来给自己发送动漫壁纸。这个单元测试使用查找图像 URL 的对象并检查结果。

```
describe WallpaperUrlQuery do
  let(:query) { WallpaperUrlQuery.new() }

  it 'should return an image url' do
    image = query.random_image

    expect(image).to be_a(String)
    expect(image).to include(WallpaperUrlQuery::BASE_URL)
    expect(image).to include('.jpg').or include('.png')
  end

  # ...
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我不关心它找到了什么特定的图像或者它去了哪里，我只是确保结果是一个字符串，来自正确的网站，并且有一个图像扩展名。现在，我可以相信我的查询会为我提供我想要的任何上下文的图像。

### [](#integration-tests)集成测试

集成测试使事情变得更加复杂，它检查独立单元的集成情况(明白吗？)在一起。

这并不总是意味着集成测试只针对将简单功能组合在一起的组件。根据我的经验，大多数集成测试用户界面以及功能和属性。我认为这些仍然算作“集成”,因为它确保了功能和 UI 如预期的那样集成。

一个简单的例子是测试 Ember 中的下拉菜单，我正在测试:

*   活动类和`aria-hidden`属性相互同步
*   单击菜单的按钮会触发这两个属性

```
test('the menu appears when clicked', async function(assert) {
  await render(hbs`{{dropdown-container}}`);
  const menu = assert.dom('.dropdown-menu__menu');

  menu.doesNotHaveClass('dropdown-menu__menu--active');
  menu.hasAttribute('aria-hidden', 'true');

  await click('.dropdown-menu__button');

  menu.hasClass('dropdown-menu__menu--active');
  menu.hasAttribute('aria-hidden', 'false');
}); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这里的其他集成测试可能是确保在菜单外部单击时菜单关闭，或者呈现传入的附加链接。这些都属于“保持部件集成在一起”的范畴。

### [](#acceptance-tests)验收测试

验收测试从代码片段应该做什么转移到用户应该做什么。这些测试基于常见的用户任务，如登录、提交表单、浏览内容以及跟踪脚本侵犯隐私。这通常使得验收测试成为任何应用程序的最高级别的测试，并且通常是最重要的。如果用户不能像预期的那样使用应用程序，其他的都无关紧要。

参加我的烬测验中的验收测试。回答一个问题涉及到用户流的几个部分:

*   他们能点击一个答案吗？
*   是否有正确数量的问题？
*   能回到之前的问题吗？
*   如果你离开测验页面，你会从你离开的地方继续吗？
*   问题是否会根据用户的星座来调整其意义和价值？
*   有人能解释一下圣徒不进超级碗背后的不公吗？

下面我试着回答(大部分)这些事情。没有什么是特定于任何功能或组件的。都是高层次的用户流量。

```
test('answering a quiz question', async function(assert) {
  await visit('/quiz/1');

  await click('[data-test=AnswerItem]:first-of-type')
  assert.equal(currentURL(), '/quiz/2', 'You go to the next question');
  assert.dom('[data-test=QuestionItem-Active]').exists({ count: 2 }, 'Two questions are available');

  await click('[data-test=QuestionList] [data-test=QuestionItem-Active]:first-of-type a');

  assert.equal(currentURL(), '/quiz/1', 'You go back to the previous question');
  assert.dom('[data-test=QuestionItem-Active]').exists({ count: 2 }, 'The quiz remembers you answered two');

  await click('[data-test=QuestionList] [data-test=QuestionItem-Active]:nth-of-type(2) a');

  assert.equal(currentURL(), '/quiz/2', 'You can go back to your current question');
  assert.dom('[data-test=QuestionItem-Active]').exists({ count: 2 }, 'The quiz still remembers you answered two');

  await visit('/quiz');
  assert.dom('[data-test=GoToQuiz]').hasText('Resume Quiz', 'The starting prompt asks you to resume the quiz');
  clearAllCookies();
}); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

至于最后两点，我不需要接受测试就知道答案是:

*   不，占星术对人类的价值不亚于看手相对马的价值
*   上帝生气了，末日即将来临，一旦汤姆·布拉迪赢得他的第七枚超级碗戒指，我们将会欣喜若狂。克苏鲁万岁！

回到正题，验收测试需要完整地呈现页面并与之交互，这比简单地导入一个组件并做出一些断言更难设置。这通常是通过一个无头的网络浏览器完成的，基本上是没有用户界面的浏览器，允许自动化。它还需要一个库来模拟用户交互和 API 请求，这对许多应用程序来说会变得复杂。

但是这种额外的工作通常是值得的，考虑到他们在确保用户总是能够按照预期完成重要任务方面的作用。缺少验收测试可能会导致灾难，比如 Twitter 更新意外阻止用户发布推文，导致服务无用。

有趣的事实: [Ember 已经把这一切都设置好了！](https://guides.emberjs.com/v2.17.0/testing/acceptance/)万一这影响了你的决定，改天试试吧。

### [](#visual-regression-testing)视觉回归测试

视觉回归(VR)测试是针对应用程序中意想不到的(或预期的)视觉变化。基本流程如下:

*   在运行 VR 测试之前，测试已经有了应用程序大部分或所有部分的屏幕截图，例如登录页面。
*   随着虚拟现实测试的运行，他们会抓取新的截图，显示所有页面在你修改后的样子。
*   然后，测试会比较每个页面的所有“之前和之后”截图，并记录每个变化。如果一些输入字段移动了几个像素，或者整个页面丢失了，测试将进行并排比较，突出显示差异。

你可能想知道:有些改变可能是故意的。如果我试图删除该页面或添加额外的字段，那么 VR 测试当然会突出显示它们。那么它们有什么好处呢？

不要怀疑测试，无信仰者！最后一个阶段是对所有的变化进行人工观察，并标记出偶然的变化。如果你的虚拟现实测试只标记你想要的变化，那么你批准他们！如果它发现了您没有预料到的问题，您就标记它们，尝试修复它们，再次运行测试，然后重复。

根据我的经验，虚拟现实测试是最难设置的。我和我现在的经理搜索了可靠的开源虚拟现实测试工具，结果一无所获。大多数要么做得不够，要么维护不当。我最接近可靠的 VR 测试是一个叫做 [Percy](https://percy.io/) 的工具，它最近增加了一个免费选项，所以我建议从那里开始。

### [](#accessibility-testing)无障碍测试

没有提到可访问性测试是我的疏忽。是的，可访问性测试是可能的！它不能测试一切，但它可以帮助您避免常见的错误，如不适当的标记或低颜色对比度。

我知道有几个工具可以尝试:静态网站的 [Pa11y](http://pa11y.org/) ，网络应用的 [aXe](https://www.deque.com/axe/) 或 [Lighthouse](https://developers.google.com/web/tools/lighthouse/) 。我们公司发现了一个基于 aXe 构建的可访问性测试助手， [ember-a11y-testing](https://github.com/trentmwillis/ember-a11y-testing) ，它为所有页面添加了基本的可访问性测试，并捕获了许多错误。

您将需要什么特定的易访问性测试器将因项目而异。找到一个就像找到一个暗杀标记:艰难，但最终是值得的，希望之后没有太多的血液飞溅。

### [](#code-quality-tests)代码质量测试

代码质量测试脱颖而出，因为它们不需要您编写任何实际的测试。相反，他们通读代码库并标记错误，例如:

*   代码复制
*   过于复杂的代码
*   偏离样式约定的代码
*   安全风险

代码质量测试还可以对代码如何随着时间的推移而变化进行高层次的分析。如果一个特定文件夹的文件质量随着时间的推移发生了很大的变化，它会指出这一点，以便您可以进行更大的重构。或者，如果开发人员逐渐在整个代码中添加秘密的恶意软件，将自己注入用户的计算机，测试可以标记当地警察和特警队(通常是一个高级功能)。

这些测试，就像 VR 测试一样，可能会对预期的更改抛出标记。因此，就像虚拟现实测试一样，一旦标志被批准，测试就会通过。

## [](#why-testing-matters)为什么测试很重要

在介绍了不同类型的测试之后，我承认我看到它们的第一反应是，“所有这些真的那么重要吗？”

如果我能像他们想的那样见到过去的自己，我会扇他们一巴掌，在他们耳边低语几个中奖彩票号码，然后再扇他们一巴掌，因为他们不会向警方报案。

此外，如果我有时间，我可能会告诉他们以下关心考试的理由。

### [](#ensure-basic-functionality)保证基本功能

显而易见的好处是，如果你的测试很好地覆盖了所有基本功能，你可以随时启动你的应用程序，知道它仍然工作。用户看到他们所依赖的东西突然崩溃是第二大令人愤怒的发现(第一个是发现所有图片都被尼古拉斯·凯奇取代)。

这对生意也有好处。在发现错误之前，与支付或上传新内容相关的功能损坏可能会导致你的应用不可用或无利可图。谁知道在那之前你会失去多少用户(或金钱)。如果你为真正重要的事情编写软件，比如医院管理病历，情况会变得更糟。人可能会死，不像《任天堂 Switch》中《荒野之息》中的马，你不能通过向一个戴着疯狂面具的被困在植物中的女神求助来召唤它们回来。

**所以不要做马女神面前给卢比的开发商。编写测试来确保需要工作的部分仍然工作。**

### [](#prevent-mistakes-from-coming-back)防止错误卷土重来

让错误溜走是一回事。让同一个应用再次溜走更糟糕，因为用户认为一个有能力的应用不会重复他们的错误。

测试可以用一个简单的经验法则来帮助避免这种情况:**对于你发现的每一个 bug，试着写一个测试来捕捉它。**

最近，当加载栏组件中的一个翻译错误导致用户无法上传文件时，这种情况开始对我产生影响。这是巨大的，我们很幸运及时发现了它，但我看到没有测试来确保这些加载状态正常工作。因此，一旦修复了这个 bug，我就编写了一个单元测试来确保加载栏文本和进度的输出返回了预期的结果。为了安全起见，我测试了三个级别:空、中途和满。

现在，这种情况不太可能再次发生，潜意识里困扰我们梦想的盲点也少了一个。胜利！

### [](#save-time)节省时间

我的第一份开发工作对跨浏览器测试有很高的标准。我发誓这是真的，我会在同一个本地服务器上安装四台笔记本电脑。笔记本电脑包括 Chrome、Firefox、Safari 和一台运行客户端经常运行的 Internet Explorer 的旧笔记本电脑。

每当我们在任何地方做了一个改变，我必须点击模式库的每一页和每个组件的功能。我已经尽可能快了，但每次都要花至少 30 分钟才能做好。每当那天我得到反馈时(或者如果我错过了什么)，我就不得不重复这一过程，将“测试和反馈”会议推了至少两天。

我不认为我需要解释为什么你不想这么做。测试把这种折磨变成了“只需按下按钮等待，不要激起跳下悬崖的欲望。”那是不言自明的。

## [](#testing-rules-of-thumb)测试经验法则

在讨论了测试的“是什么”和“为什么”之后，让我们以“如何”来结束我不会深入讨论使用什么特定的测试框架，因为有太多的测试框架需要覆盖，如果你在搜索自己的时候记住它们，你会学得更好。

但是当你写测试的时候，有几个规则要遵守。

### [](#test-early-and-often)考试早且常

避免“我已经完成了一个没有测试的应用程序”的情况。这使得增加测试的想法成为一个令人生畏的庞然大物，你放弃了，然后恨自己放弃了，因为它玷污了你的遗产(像网上约会)。

每当你添加或更新一个新的功能时，试着添加测试。当您添加一个组件时，为它包含一个新的测试。扩展一个功能意味着扩展你测试它的方式。这使得跟踪需要测试的内容变得更加容易，并使其易于接近。

### 确保测试按预期通过(和失败)

编写一个通过的测试并不总是好的。曾经有过这样的情况，我通过了一个测试，但是当我故意把它改成失败时，它仍然通过了，我意识到它被终结了。测试只有在不能提醒你问题的时候才是好的。可靠的测试使得缺陷更容易出现在产品中。

防止这种情况可能很简单，一旦你写了测试，做一个小的改变，让它像预期的那样失败。如果你正在测试一个函数是否输出`6`，看看当你测试一个不同的数字时它是否失败。

更彻底的方法是将这些小的“失败测试”变成额外的测试。大多数测试库让你测试哪些结果*不应该是*，哪些结果*应该是*。虽然我倾向于写更多的*应该是*测试，但是通常会有大量的*不应该是*测试混合在一起。

一个例子来自我的时事通讯应用。查询对象应该在每次查询时返回随机图像，以确保我每次都得到不同的图像(不包括巧合的匹配或上帝的手伸到我这里来捣乱)。所以我测试了两个不同的查询不相等。

```
it 'should give different images from the same object' do
  image1 = query.random_image
  image2 = query.random_image

  expect(image1).not_to eq(image2)
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

虽然我在这里的大多数测试都是寻找匹配的文件类型和字符串，但这一次是通过确保两件事情不匹配来通过的。换句话说，我在测试一种失败。

### [](#dont-rewrite-the-programs-logic)不要重写程序的逻辑

几周前，我为 URL 中的一些基本字符串替换编写了一个正则表达式。后来，我添加了一个额外的测试，以确保这种情况不会再次发生(回调，以防止旧的错误！)在我的治疗师建议我不要在这里写的那个 PR 中，我犯了许多错误，其中之一是我在确保结果匹配的同时将相同的正则表达式复制到测试中。

这是错误的，有两个原因你可能已经知道了，作为一个聪明的开发人员，在读完我的文章之后:

*   正则表达式中的任何错误都不会被捕获，因为错误会简单地带入测试，并认为它是正确的。
*   重复代码！在应用程序中更改它意味着我有忘记更改测试的风险。

正确的方法是删除正则表达式，只测试最终结果。如果我有一个网址，应用程序应该返回这个版本的网址。只有应用程序控制它如何得出结果，而不是测试。测试只是确保它正确地完成工作，如何完成并不重要。

### [](#know-about-data-stubbing)了解数据存根

最后，一个更像脚注的提示:大多数应用程序以某种方式连接到 API，一些组件特别依赖于 API 数据。他们可能通过 API 请求获取数据，或者发送 POST 请求来更新信息。

我对这些的第一个处理是像正常测试一样编写它们。但它只在以下情况下有效:

*   任何在本地运行的自定义 API，在 Github pull 请求的持续集成测试中失败
*   API 数据更难预测，可能会改变，这很容易导致测试失败
*   测试与 API 交互的组件可能会改变实际数据，这是很糟糕的，因为我现在还没有列出税收优惠

解决方案:数据存根！这意味着创建一个假的 API 端点，它在测试中返回静态数据，这些数据可以进行可预测的匹配和测试。API post 请求也可以返回测试断言，所以不用改变数据，它们只是简单地确认可以发出请求。

所以在寻找测试框架时，看看它们是否包含或者兼容一个好的数据存根方法。谢天谢地，大多数人都知道。

## 让测试工作起来，不管它有多难

我将用最后一点，也许是最重要的一点来结束这篇文章。很简单:**不管让测试运行起来是多么令人沮丧和疯狂，做任何需要的工作。测试总是值得的。正如[务实的程序员](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)所说，在测试运行之前，它不是代码。**

最近，我开始使用 React 和 Pokemon API 构建 Pokedex，并希望进行基本测试。我最终选择了 Jest 和 Enzyme，但是让它们工作起来太可怕了。花了一个多小时，我遇到了 Babel 兼容性问题，由于看似随机的原因，我不得不记下错误消息。

到最后，我几乎因为纯粹的愤怒而掀翻桌子，而不是通常的狂躁喜悦和/或对无政府状态的原始渴望。但是我最终让它们运行起来，只是像预期的那样失败了，并且准备好设置单元、集成和验收测试。

完全值得。

在我职业生涯的早期，我经常忽略测试。更有经验的同事告诉我，这是其他新程序员的通病。因此，我恳求年轻时的自己，以及同情我的作者 handle 的其他初学程序员读读这篇文章:**不要忽略添加测试，直到以后。它们和任何语言基础或流行框架一样重要。你的同事、用户、股东、跟踪者和过去的自己会因此而更加感激。**