# 黑白棋(奥赛罗)游戏程序，在 7 行 c 代码中你可以选择第一个或第二个。

> 原文:[https://dev . to/iigura/reverse Othello-game-program-which-you-can-choose-the-first-or-second-in-seven-line-code-of-c-3799](https://dev.to/iigura/reversiothello-game-program-which-you-can-choose-the-first-or-the-second-in-7-lines-code-of-c-3799)

本文介绍了一个用 C 语言编写的 79 个字符× 7 行的小型黑白棋游戏程序。这个节目的原始版本在 18 年前就已经发布在日本著名的匿名论坛 2ch 上了。它的尺寸非常小，但甚至配备了“人工智能”程序。在最初的版本中，玩家总是第一个，但这次我增加了一个功能，玩家可以在 79 个字符 x 7 行的代码大小限制下选择第一个或第二个。

# [](#the-original-code)原代码

```
#include <stdio.h>
int p,t,a,d,c,v,i,m[90]={0},s,r[]={-10,-9,-8,-1,1,8,9,10};void k(){if(m[p]==0)
for(i=0;i<8;i++){for(c=0,v=p+r[i];m[v]==3-t;v+=r[i])c++;if(c&&m[v]==t){a+=c;v=
p;if(d)do m[v]=t,v+=r[i];while(m[v]!=t);}}}char*h="・○●\n";int main(){for(i=
1,m[41]=m[49]=2;i<10;m[i++*9]=3)m[40]=m[50]=t=s=1;for(;;a=d=0){for(p=9;p<82;++
p)k(),printf("%.2s",&h[m[p]*2]);if(a)for(d=a=s=p=8;a==8;k())t-2?(scanf("%d %d"
,&p,&i),p+=i*9):++p;else if(s)s=0,printf("pass");else break;t=3-t;}return 0;} 
```

越看这段代码，越觉得这段代码的作者是一个真的牛逼。

你可以在下面的网址看到代码(虽然这个页面是用日语写的):
[https://pc3.5ch.net/test/read.cgi/tech/984182993/337](https://pc3.5ch.net/test/read.cgi/tech/984182993/337)

# [](#improved-version)改良版

```
int printf(const char*,...);int scanf(const char*,...);int p,t,a,d,c,v,i,m[90]
,s,r[]={-10,-9,-8,-1,1,8,9,10};char h[]=" - x x\n";void k(){if(m[p]==0)for(i=0
;i<8;i++){for(c=0,v=p+r[i];m[v]==3-t;v+=r[i])c++;if(c&&m[v]==t){a+=c;v=p;if(d)
do m[v]=t,v+=r[i];while(m[v]-t);}}}int main(int q,char**z){t=q;h[2*t+1]='o';f\
or(i=1,m[41]=m[49]=2;i<10;m[i++*9]=3)m[40]=m[50]=s=1;for(;;a=d=0){for(p=9;p<82
;++p)k(),printf("%.2s",h+m[p]*2);if(a)for(d=a=s=p=8;a==8;k())t-2?scanf("%d %d"
,&p,&i),p+=i*9:++p;else if(s)s=0,printf("pass");else break;t=3-t;}return 0;} 
```

如果执行时没有参数，玩家将成为第一个玩家。当使用一个参数运行时，例如。/a .出了 aaa，玩家就第二了。在这个程序中，没有参数或者只支持一个参数。请不要使用两个以上的参数执行。

实际执行的状态如下。请输入列号和行号，用空格隔开。左上是 1 1，右下是 8 8。

```
$ ./a.out

 - - - - - - - -
 - - - - - - - -
 - - - - - - - -
 - - - o x - - -
 - - - x o - - -
 - - - - - - - -
 - - - - - - - -
 - - - - - - - -
5 3

 - - - - - - - -
 - - - - - - - -
 - - - - o - - -
 - - - o o - - -
 - - - x o - - -
 - - - - - - - -
 - - - - - - - -
 - - - - - - - -

 - - - - - - - -
 - - - - - - - -
 - - - x o - - -
 - - - x o - - -
 - - - x o - - -
 - - - - - - - -
 - - - - - - - -
 - - - - - - - -

```

# [](#commentary)解说

## [](#the-way-for-the-player-to-become-the-second)玩家成为第二的方式

因为变量 t 有回合的信息，如果游戏开始时 t=2，计算机成为第一个。具体来说，在“main”函数开始时改变到 t=2 就足够了。

```
m[40]=m[50]=t=s=1;    /* before */
m[40]=m[50]=s=1,t=2;  /* after  */ 
```

## [](#changing-players-piece-character)改变玩家的棋子角色

通过以上修改，现在可以选择第一种和第二种。但是不管顺序如何，玩家的棋子角色总是“o”。让我们改变这一点。棋子的特征由变量 h 定义，然后适当地修改 h 的内容就足够了。

具体来说，当 player 是第一种情况，也就是 t=1 时，设置 h[3]='o '，h[5]='x '就足够了，当另一种情况，也就是 t=2 时，设置 h[3]='o '，h[5]='x '也就足够了。

无论是分别设置' o '还是' x ',代码量都会增加。因此，它预先将 h[3]和 h[5]设置为“x ”,并根据 t 的值将 h[3]或 h[5]更改为“o”。

```
char h[]=" - x x\n";
h[2*t+1]='o'; 
```

变量 h 的类型已从 char*变为 char[]。这是因为，在 char*的情况下，要改变 h 的字符，就意味着它将改变常量字符串。因此导致内存访问冲突错误发生，程序将被终止。

## [](#how-to-specify-the-first-or-the-second)如何指定第一或第二

“你是第一个吗？还是第二种？”如果一个程序要求你像往常一样使用 printf 和 scanf，它可能不适合 7 行。因此，使用命令行上的参数来指定第一个或第二个。如果你想作为第一个玩家，请执行这个没有参数的奥赛罗程序。或者，如果你是第二个玩家，请用一个参数来执行。当然，程序的命令行参数也可以。重要的是论点的数量。不是参数内容。

那么程序将如下:

```
int main(int q,char**z){t=q; ... } 
```

在这段代码中，参数的个数被存储在一个变量“q”中。这是因为 main()函数第一个参数中的变量“t”似乎变成了 const int(在 Apple LLVM 版本 10.0.0 (clang-1000.11.45.5)，gcc / macOS mojave 上)。

## [](#excavation-of-the-blanks)挖掘空白处

改进的策略已经完成，所以我们必须找到空白来添加它们。在原代码中，除了第一行，没有大的空格。但是#include 指令需要从行首开始写，之后不允许写任何程序。

我们来想一想为什么原始代码一开始也包括 stdio.h？这当然是因为 printf 和 scanf 的原型声明是必要的。第一行可以更改如下:

```
#include <stdio.h>  // before

int printf(const char*,...);int scanf(const char*,...);  // after 
```

有了这个改变，我们能够得到 23 个空格！

一点一点，让我们进一步缩短代码，让我们做更多的空白:

```
m[90]={0},  // before
m[90],      // after   ( get 4 spaces )

while(m[v]!=t);  // before
while(m[v]-t);   // after   ( get a space )

printf("%.2s",&h[m[p]*2]);  // before
printf("%.2s",h+m[p]*2);    // after   ( get 2 spaces ) 
```

而且，我们将继续使用延续行，这样我们可以在关键字中间换行。

```
// like this
f\
or 
```

# [](#summary)总结

最后，修改后的代码将被推入这样制作的页边空白。由于换行位置，它取代了程序部分的顺序。然而，程序代码的含义没有改变。