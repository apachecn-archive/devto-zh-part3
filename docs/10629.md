# 观察者设计模式[行为]

> 原文:[https://dev . to/its coders life/observer-design-pattern-behavioral-2g 25](https://dev.to/itscoderslife/observer-design-pattern-behavioral-2g25)

**什么是观察者模式**？这是向一组对象通知另一个对象的状态变化的一种方式。观察者订阅接收通知，主体在其状态改变时更新通知。观察者模式实现了这一点，同时使订阅者独立于主体的实现。所有这些对象都保持松散耦合。

*   有一个客体被称为主体。该主题发送通知。
*   subject 维护一个订阅对象的列表，这些订阅对象也称为观察者，并通知它们其状态的变化。
*   观察者需要订阅以接收来自主题的通知。
*   主体和观察者之间没有紧密的联系。

> 观察器允许订阅者在不与发送者紧密耦合的情况下获得关于另一个对象的变化的通知。

示例:

让我们以拍卖系统为例。在这里，主体由拍卖人代表。竞标者是观察者。当新的出价被接受或达到保留价格时，拍卖人更新出价人。拍卖人独立于竞买人。

另一个例子是软件中的通知系统。有一些应用程序可以订阅或观察操作系统中的某些事件。这些事件可以是用户生成的事件，也可以是操作系统生成的事件。操作系统是事件生成时通知所有观察者事件的主体。

观察者设计模式允许对象订阅接收关于另一个对象中的变化的通知。通知中心，也称为主题，在其状态改变时更新观察者。主体只知道接收者采用观察者协议。不需要进一步的实施细节。这种松散耦合的设计让我们可以轻松地添加或删除观察者。创建新的观察者类型时，不需要修改主题。唯一的要求是使新类型符合观察者协议。

缺点:一个潜在的问题是观察者被实验对象保持存活。当一个观察者即将被释放时，我们应该把它从主体中分离出来。否则，主题将使观察者存活，并在它应该被释放后很久才更新它。这可能会导致不希望的副作用和各种奇怪的错误。这种模式的另一个缺陷是允许观察者和主体紧密耦合。如果 subject 只引起了 observer 的 update 方法，那么 observer 模式就正确实现了。