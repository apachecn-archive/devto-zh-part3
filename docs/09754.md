# 访问者设计模式[行为]

> 原文：<https://dev.to/itscoderslife/visitor-design-pattern-behavioral-53cf>

访问者允许向不相关的类型添加公共行为。如果我们不能或不想改变给定类型的源代码，就应该使用它。

*   它将新的行为分离成一个专用的访问者。访问者必须访问每个对象，并对该对象的状态执行所需的操作。
*   如果需要新的功能，您只需扩展访问者，或者为此创建一个新的访问者。
*   如果需要遍历异构对象的集合并执行相关操作，这种模式非常有用。
*   访问者不需要子类化就可以工作。

> 访问者让我们在不改变实现的情况下，向不相关的类型添加新的公共行为。

示例:假设我们在一个在线商店的购物车中添加了一组不相关的产品、书籍、电脑和汽车。它们有不同的属性来检索它们的价格；书的单价，电脑的单价，汽车的标贴价格。因此在计算价格时，我们需要检查产品类型，并相应地调用它的 prie 属性。当产品类型列表增长时，这是有问题的。

访问者模式通过将新的行为提取到访问者类型中来解决这个问题。访问者拥有可以处理每种类型的访问方法。因此，我为 Book、Computer 和 Car 这三种类型声明了带有访问方法的 Visitor 协议。每个类型的接口都在 visitor 类的具体类中定义。

每个产品接受一个访问者，然后产品调用访问者的访问方法。这种方法知道如何计算特定类型产品的价格。*接受一个访问者并调用其访问方法*——这叫双重调度。

**双派遣**:

具体的访问者类型需要对主题状态进行操作。为了接收正确的实例，访问者模式使用了一种称为双重分派的技术。为了使双重分派工作，每种类型都必须定义一个接受访问者方法。

accept 方法将访问者实例作为输入参数。调用 accept 方法可以确保选择当前主题。对于每个主题，我都实现了 accept visitor 方法。

接受访问者以 self 作为参数调用访问者的访问方法。这将调用正确的 visitor 子类，并确保执行正确的操作。由于调用了 accept 和 visit 方法，该流程被称为双重分派。

简而言之:访问者应该用于向不相关的类型添加新的行为，而不需要子类化。没有这样的陷阱，但是如果抽象做得不好，具体的访问者接口会增长。