# OGQL 事后分析

> 原文::1230【https://dev . to/tttaaanningg/ogql-1ec 8】

因此，随着我们最初发布的 [OGQL](https://orpheusgql.com/) ，这似乎是一个停下来总结一下我们在哪里，我们是如何到达这里的，以及我们将从这里走向哪里的好时机。

我们将从我们是如何来到这里开始。

## 我们是如何来到这里的

我们一直在联系各种软件工程师，询问他们关于 GraphQL 的痛点。出现了几个值得注意的问题。

*   GraphQL 是一种基于图形的查询语言，但不是图形数据库，并且缺少图形数据库内置的一些查询功能。
*   读取嵌套的 JSON 有困难
*   通过 GQL 的抽象层调试查询的困难

我们决定解决第 2 点和第 3 点。这是我们的流程。

首先，我们从解析器开始。解析器是存在于 GraphQL 类型和“根”中的方法，它们返回客户端请求的数据。GraphQL 调用每个解析器，直到它们返回将填充请求模式的标量(非嵌套)值。

如果我们在 GraphQL 中寻找潜在的瓶颈和调试问题，这就是我们要开始的地方。

我首先使用一个装饰器来添加对所有根解析器的跟踪，这样我们就可以尝试做一些事情，比如计算它们被调用的频率。这在某种程度上起了作用，但不足以真正理解我们的查询行为。

一旦我们开始遇到嵌套解析器和异步数据库请求，问题就出现了。只要是同步操作，嵌套解析器就能很好地工作，因为我们可以通过检查前后的日期对象来可靠地计时它们的持续时间，但是大多数 GraphQL 操作将需要从另一个 API 或数据库获取数据。

那么，问题是如何区分不同的情况(琐碎的解析器、API 调用和各种不同的数据库调用)。

似乎 GraphQL 本身有办法解决数据库调用返回的承诺。因为它会累积 JSON 响应，所以我们试图深入 GraphQL JS 源代码以了解这是如何发生的，并将我们自己的调试/跟踪代码注入其结构中。我们花了几天时间研究这个话题，并试图设计解决方案，但最终都没有成功。

我们时间紧迫，士气极其低落，精疲力竭。最后，我们缩小了项目的范围。这导致了...

## 我们做了什么？

因此，我们有了一个紧密耦合的跟踪系统，它获得了一些数据(运行时和解析器，带有嵌套深度)。

在绝望中，我们最终从我们的结果开始逆向工作，以便弄清楚我们是如何到达那里的。它可以工作，但不建议这样做，因为您将无法获得有关单个解析器的详细信息，并且只有在所有解析器都能够正确返回数据的情况下，它才能工作。

在这种折衷的形式中，您可以通过 GraphQL 返回的嵌套对象上的键名来跟踪解析器。您将无法判断哪些解析器是无关紧要的，进行了多少次数据库查询或获取请求，或者无法获得哪些解析器可能需要最长时间进行评估的明细。

然而，好处是我们能够与任何 GraphQL 端点一起工作，包括那些不能将代码注入后端的端点。我们仍然能够可视化返回的数据总量、每个查询如何影响最终结果的细分，以及执行和返回数据之间的总运行时间。

最初，我们将项目设计为服务器上的一个端点，目的是将它转移到一个电子应用程序上。然而，electron 有很多开销，会给一个并不真正需要存在于浏览器之外的项目增加很多麻烦。最终，我们研究了 Graphiql，并决定以类似的方式实现 OGQL。

当我们使用 GraphQL 作为 graphql 扩展时，当浏览器访问它时，它将在'/graphql '处呈现一个 GUI。GraphQL 扩展所能提供的服务相当有限。graphic QL 只通过发送一个呈现为 HTML 的字符串来管理 React 前端，该字符串包括脚本标记，这些标记将从 cdn 中获取它对节点承诺、React、一个缩小的样式表以及编译后的 graphic QL 本身的一个缩小的包的所有依赖关系。

遵循这种模式，OGQL 默认为'/orpheus '提供 HTML，并导入我们从前端编译的包。因为我们不能把 OGQL 和所有的 GQL 安装捆绑在一起，所以我们把它打包成一个节点模块，上传到 NPM，这样任何开发者都可以很容易地安装和使用它。

与 Graphiql 不同，我们所有的样式和资源都由 Webpack 编译成一个包。这是低效的，我们应该从与 graphiql 相同的 cdn 中提取，这样我们就可以利用缓存并最小化我们的包大小。

现在，我们的 OGQL 包大约有 5mb。这比它需要的要大得多。

我们最初使用 React 和 Redux、Ace 编辑器和 React Vis 来构建我们的前端。我们的状态可能不够大，不足以证明 Redux 的使用(但它是一个相当轻量级的库，所以我们并不 100%紧急地削减它。随着我们扩展/添加更多功能，它可能会变得更加有用)。如前所述，我们可以从 CDN 中提取 React，我们可能只想从 React-Vis 中提取 sun burst/Treemaps(我们实际上使用的库的唯一部分来可视化我们的数据)。Ace Editor 是一项有趣的技术，但也相当笨重，我们并没有真正利用它的高级功能，所以我们可能也想放弃它，并找到一种更轻便的替代方法(或者实际上使用语法高亮之类的东西？).

我知道这种情况会在下一节讨论，但是我们将主要讨论考虑添加的特性。

## 接下来是什么？

因此，目前 OGQL 的存在，主要是一个花哨的 JSON 可视化工具。我很高兴我做了一点树遍历/构建，将它解析为一棵树，以便 React Vis 能够读取它，并且我觉得我对 GQL 的理解比我开始时好得多，但是我实际上并没有在扩展它的方面做太多。

我们实现了一些历史，但是它不是持久的，并且它不缓存我们的可视化数据。它只是保存你最近做的一些查询。

有很多方法可以扩展我们的历史功能。我认为我们可以做的一个更清晰的用例是构建一些特性，让我们可以在选择的查询之间进行比较。运行时的差异、总数据大小的差异以及解析器方面的差异/重叠可能是值得考虑的因素。拥有一些系统来比较许多查询，并添加导出它们的功能，也将有助于扩展我们的用例。

我认为构建跟踪数据库请求的功能绝对值得再考虑一下。我在想，我们可能想检查一个返回值是否是一个承诺，然后等待它以某种方式解决。我不明白 GraphQL 是怎么做到的。(promise.all？但是，我们必须确保我们将所有承诺都推送到一个阵列，并确保在承诺完成后，数据正确地流向我们需要的任何功能。如果有人对 GraphQL 如何处理这个有见解，请说一说)。我们或许可以通过观察 GraphQLObjectType 构造函数的工作方式来识别类型。如果我们能够解析名称和字段，我们甚至可以找到 resolve 方法和其中的数据库/API 调用。

我不期望能够区分 API 调用和数据库调用，但是我们可以通过简单地将它们识别为异步任务来解决这个问题。

当我们得到一个异步任务时，我们希望标记一个特定的解析器正在进行异步工作，我们希望使用异步方法来计时和跟踪它们，因为这些方法特别值得关注。管理数据可能会变得棘手，但基于 web 的应用程序的头号瓶颈将是网络请求，所以这是我们要优先考虑的。

## 流程中的变化

我们应该重新评估单口相声，保持更好的沟通。至少就我而言，我感受到了一种完成任务的压力(很大程度上是自我施加的)，但不知道哪些任务应该优先处理，以及它们朝着什么目标前进。这大大削弱了我的动力。

围绕用户同理心组织我们的立场将有助于保持每个人团结一致地向更好的产品前进。相反，我最终发现自己试图发明和要求任务，以便我能感到富有成效，同时发现其中许多任务没有结果或过于模糊，无法有效地追求。我想尽我最大的努力来支持我的团队，结果在这个过程中，我把实际产品的优先级降低了。通常，我也觉得被我们为自己设定的任务“卡住了”,如果我觉得有权重新评估一个似乎不起作用的任务，并考虑其他替代方案，这将节省很多时间。

在某些时候，认识到一个过程没有工作，或者没有像我们需要的那样工作是至关重要的。这是一件痛苦的事情，这也是我在这个项目中避免这么做的原因。

领域知识也非常重要。解决一个你不理解的问题几乎是不可能的。我在工作中学习得相当快，但我从未停下来评估和重新整理我的知识，或我对手头任务的整体理解。我们设法做了一些航向修正，但是又一次缺乏明确的修正方向。避免失败不是创造成功的好方法。

## 结论

一般来说，我们的开发瓶颈实际上不是技术专长、时间或编程能力，而是产品管理和士气。缩小项目范围通常是个好主意，但是一旦我们实现了 MVP，就需要空间和方向来发展。

用户同理心可以极大地帮助我们创造这个方向。我们专注于技术任务，绝对没有计划我们的实际用例是什么。诚然，这是我们第一次对 GraphQL 有所了解，但非常遗憾的是，我们费了这么大劲才开发出一个不太符合我们最初设想的用例的系统。当我们的工作有任何东西可以展示的时候，我们彻底迷失了，然后遇到了最后期限。

至于我们该何去何从，总结如下:

毫无疑问，我们应该减少我们的包大小。5mb 对于如此简单的前端来说是不可接受的。即使只有提供给我们的数据，我们也可以做得更好。我们应该添加更好的历史记录工具和分析工具，它们可以很好地扩展以比较多个请求，还应该添加导出这些日志的工具。有了这些工具，开发人员可以试验查询，比较结果，并保存任何值得保存的内容。GQL 的自省工具也是系统中非常有价值的一部分，作为我们应用程序的一部分来实现会很棒。

然而，鉴于我们应用程序的当前状态，我也建议进一步开发两个模型中的一个:

1.  集成到后端:如果我们要求用户将我们的软件作为节点模块安装，我们应该提供只能通过将代码导入他们的后端才能实现的功能。事实上，它作为 GraphQL 的扩展是不错的，但不需要下载。如果我们走这条路，我们应该挖掘解析器的实际功能。跟踪 API/DB 请求的能力将是这种方法的主要吸引力。

2.  完全分离成一个独立的前端。如果我们不通过 NPM 安装提供额外的功能，我们应该将我们的前端分离到它自己的网站，在那里它可以作为 PWA 存在(不需要安装！).这将是一个轻量级的、灵活的、快速的查询工具，可以用来帮助开发人员计划对一个不熟悉的端点的请求(比如说，如果您正在使用一个公共的 GQL API，并且没有对其后端的完全访问权，那么您可以使用这个工具来查询和理解 API 响应的形式)

最终，我对现有的应用程序并不完全满意。它易于使用，设计良好，并提供了对查询结果的快速理解，但继续受到残留代码和模仿 Graphiql 的决策的拖累，而不是为我们自己的用例选择最佳解决方案。OGQL 目前最可行的用例是为不太熟悉 GraphQL 的用户提供可视化。

(我以前没有想到这一点，但将我们的工具瞄准更随意的受众将是另一种方法。我们可以集成 GQL 的自省特性，允许用户通过适当的图形化点击/点击-拖动界面构建查询，然后返回数据，同时可以导出格式化的查询字符串。)

然而，有足够的时间和空间来学习和成长，我当然希望继续将我们的项目构建成它能够成为的适当工具。感谢您的阅读！