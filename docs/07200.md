# Java 中公共和私有的区别

> 原文：<https://dev.to/renegadecoder94/the-difference-between-public-and-private-in-java-3g2e>

当我正在写我第一学期的教学反思时，我有了一个想法，开始一系列被称为编码切线的学生问题。在本系列中，我将通过清晰、易于理解的解释来解决学生的问题，揭开常见编程语言语法的神秘面纱。特别是，我想解决今天 Java 中公共和私有的区别。

## 学生遇到的问题

很多时候，当我们教 Java 的时候，我们会把很多语法当成一个机械的过程。换句话说，我们告诉学生，像`public`、`static`和`private`这样的关键词稍后会向他们解释。与此同时，他们只需要相信我们以后会解释这些概念。

几乎总是留到以后讨论的语法片段之一是`private`对`public`。这些关键字被称为访问修饰符，我们将在本文中深入探讨它们。

但是首先，让我们看一个几乎肯定会引起一些关于访问修饰符问题的代码示例:

```
public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
} 
```

Enter fullscreen mode Exit fullscreen mode

为了教授 Java，我们经常被这些可怕的五行代码所困扰。毕竟，这是运行 Java 程序的最低要求。

因此，我们经常被迫告诉学生一些类似这样的事情:

> 不用担心外四行。只需将您想要执行的任何代码放在中间的块中。
> 
> -各地的计算机科学教授

当然，如果你是新生，这种推理方式还有很多不足之处。例如，这四条外线是做什么的？什么是`public`？`static`、`String[]`或者`System.out.println`怎么样？

幸运的是，我今天将讲述访问修饰符部分。

## 学生渴望的解释

现在，让我们在高层次上讨论访问修饰符。

### 访问修饰符概述

在 Java 中，访问修饰符是一种帮助我们避免踩在自己脚上的方法。一般来说，它们用于设置对类、方法或变量的某种级别的访问。

例如，如果我们想从现实世界中建模某样东西(比如一辆汽车)，我们可能不想让这个对象的某些方面*暴露给公众*(比如对雨刮片的个人控制)。也许在引擎盖下，雨刷是单独控制的，但我们已经建立了我们的系统，以便给用户的开关已经封装了该行为。换句话说，两个雨刷如预期的那样一起移动。

如果我们选择暴露对每个游标的单独控制，我们可能会发现许多用户不小心破坏了游标的功能。毕竟，如果雨刷没有完全同步，它们可能会相互碰撞。

这是访问修饰符背后的高级思想。我们使用它们来暴露或隐藏某些功能，以改善整体用户体验。

### 误解

在这一点上，许多学生会开始认为访问修饰符是某种使代码更安全的方法。虽然这在很大程度上是不真实的，但这种说法还是有一定道理的。当然，没有什么能阻止人们使用反射这样的特性来访问私有字段和方法。也就是说，访问修饰符有助于保护普通用户不破坏对象的状态。

想想挡风玻璃雨刷的例子。当我们打开雨刷时，我们希望它们以相同的速度移动。如果不限制访问，我们可以更改其中一个雨刷的默认速度。然后，下一次我们打开雨刷的时候… *砰！*为了避免这个问题，我们**封装了**(或者隐藏)我们在一个暴露的(公共的)方法中有两个单独的擦拭器的事实。

封装是将复杂状态简化为一组公开行为的艺术。如果我让你扔一个球，你肯定不会一开始就要求一组手臂旋转的矩阵变换。你只是扔球。这就是封装(和抽象)背后的思想。

在这个例子中，我们可以使用访问修饰符来指定公开哪些行为。例如，我们可能希望允许用户访问`throw`命令，但可能不允许访问`rotateArm`或`pickUpBall`命令。

既然我们已经解决了一些误解，让我们进入语法。

### 关键词

在 Java 中，实际上有四个访问修饰符:`public`、`private`、`package-private`(默认)和`protected`。每个关键字提供了下表给出的代码访问级别:

|  | 公众的 | 私人的 | 包装-私人 | 保护 |
| --- | --- | --- | --- | --- |
| 同班 | T | T | T | T |
| 同一包装中的不同类别 | T | F | T | T |
| 同一包中的子类 | T | F | T | T |
| 不同包装中的不同类别 | T | F | F | F |
| 不同包装中的子类 | T | F | F | T |

换句话说，我们可以按照可访问性最低的顺序排列关键字:

1.  私人的
2.  包-私有(默认)
3.  保护
4.  公众的

在本教程中，我不会探究`package-private`或`protected`关键字，因为它们稍微有点微妙，但我认为它们很重要。

### 将动作分类为公共或私人

使用之前的投球示例，让我们试着找出在各种情况下哪个访问修饰符是合适的:

*   公众的
    *   扔
    *   捕捉
    *   投掷
    *   投
*   私人的
    *   旋转臂
    *   翻译文本
    *   拾球
    *   计算体积

请注意，所有高级操作都是公开的，而低级操作是私有的。这是因为我们不一定要将较低层次的行为暴露给公众。但是，为什么不呢？让我们看另一个例子。

假设高级功能依赖于系统的一些底层状态。例如，投掷一个球依赖于了解像重力强度和球的属性这样的信息。如果有人能够以某种方式访问较低层次的行为，他们就有可能操纵世界的这些基本假设。

如果我们能够访问像`setGravity`或`setBall`这样的动作，会发生什么？我们像`throw`或`catch`这样的高层行动会有什么变化？

使用`setGravity`命令，我可以告诉你，在告诉你扔球之前，重力实际上是你认为的两倍。在这一点上，你应该更新你的世界模型，然后再显著增加你投掷的力量来适应重力的变化。然而，在现实中，重力实际上并没有改变，所以相反你推翻了球。

当我们公开不触发依赖属性自动更新的低级功能时，经常会发生这种情况。在许多情况下，系统非常复杂，改变一个基本参数会导致系统故障。因此，我们试图封装功能来覆盖我们所有的基础。

### 用户定义的类

到目前为止，我们大部分时间都在谈论访问修饰符的哲学，但是真实世界的结果是什么，我们实际上如何使用它们呢？为了帮助澄清这些问题，让我们花点时间写一些我们自己的类，试图展示`public`和`private`之间的实际差异。

#### Hello World 重游

现在我们已经看到了一些高级的解释，让我们回到 Hello World 的例子。

```
public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
} 
```

Enter fullscreen mode Exit fullscreen mode

这里我们可以看到我们使用了 public 关键字两次:一次用于类，另一次用于 main 方法。换句话说，我们选择向公众公开 HelloWorld 类和 main 方法。

为了让事情变得更有趣一点，让我们用它自己的私有方法来包装这个打印:

```
public class HelloWorld {
  public static void main(String[] args) {
    printHelloWorld();
  }

  private static void printHelloWorld() {
    System.out.println("Hello, World!"); 
  }
} 
```

Enter fullscreen mode Exit fullscreen mode

如果我们尝试运行这个解决方案，我们会注意到行为根本没有改变。那是因为私有方法可以在自己的类中使用。然而在`HelloWorld`之外，甚至没有人知道`printHelloWorld()`的存在。事实上，我们可以尝试直接从同一个文件夹中的另一个类调用这个方法，我们会发现自己有一个错误:

```
public class CallPrivateMethod {
  public static void main(String[] args) {
    HelloWorld.printHelloWorld();  // ERROR
  }
} 
```

Enter fullscreen mode Exit fullscreen mode

如我们所见，我们隐藏了打印功能，因此它只能由`HelloWorld`类使用。如果出于某种原因我们公开了`printHelloWorld()`方法，我们可以很好地运行它。

#### 挡风玻璃雨刷

现在，让我们通过用 Java 实际实现挡风玻璃雨刷(至少在高层次上)来进一步理解这个概念。首先，我们将创建一个汽车类，它有一个用于一个雨刷的`private`方法和一个用于两个雨刷的`public`方法:

```
public class Car {
    private boolean[] wipers;

    public Car() {
        this.wipers = new boolean[2];
    }

    private void turnOnWiper(int index) {
        this.wipers[index] = true;
    }

    public void turnOnWipers() {
        for (int i = 0; i < this.wipers.length; i++) {
            this.turnOnWiper(i);
        }
    }
} 
```

Enter fullscreen mode Exit fullscreen mode

在这里，我们创建了一个 Car 类，它存储了一个雨刷状态的`private`数组。对于每个雨刷，它们的状态或者是开(`true`)或者是关(`false`)。为了打开游标，我们编写了一个`private`方法，让您通过游标的索引来打开游标。然后，我们用一个`public`方法将所有这些集合在一起，这个方法遍历所有的雨刷并打开它们。

现在，忽略这里的现实问题，即雨刷是串联的，而不是并联的，我们有一个非常可靠的解决方案。如果有人要实例化一辆汽车，他们只能同时打开所有的雨刷。

```
public class CarBuilder {
    public static void main(String[] args) {
        Car car = new Car();
        car.turnOnWipers(); // Turns on wipers!
        car.turnOnWiper(1); // Compilation ERROR
        car.wipers[0] = false; // Compilation ERROR
    }
} 
```

Enter fullscreen mode Exit fullscreen mode

有趣的事实:用户甚至不知道雨刷是如何实现的，所以我们可以完全控制随时改变底层架构。当然，我们仍然必须提供相同的功能，但是如何实现这一点取决于我们自己。换句话说，我们可以改变游标数组来存储整数。然后，对于每个游标，该整数将与速度相关。

现在，你为什么不自己试着扩大班级。比如我推荐增加一个关闭雨刷的方法。然后你可能想写一个新的私有方法来关闭单个的擦拭器，或者你可能会发现重构`turnOnWiper`方法来获取一个布尔值更有意义。因为用户永远看不到这些方法，所以您可以完全控制底层的实现。编码快乐！

## 开放论坛

希望这能帮助你理解私有和公共关键字之间的区别，以及我们为什么使用它们。如果没有，我欢迎您的任何反馈和问题。请随意使用下面的评论来开始一段对话。如果这对你有所帮助，请与你的朋友分享。我总是感谢支持！