# 大家都懂算法分析！

> 原文:[https://dev.to/wiz/everyone-knows-algorithm-analysis-76](https://dev.to/wiz/everyone-knows-algorithm-analysis-76)

#### [](#problem-problem-and-problem)问题，问题，问题！

虽然这将是所有关于算法，但它始于问题。是啊！我们就像在数学、物理和生命的各个阶段一样有问题！
而我们做什么？我们试图解决它们。一般来说，任何像你一样的正常人都会遵循这种方法:

1.  明白了，实际中有什么问题(*为什么我觉得自己像条鱼？1/sinx 的集成度是多少？*)
2.  然后你得到一些原因和障碍。如果它们模糊不清，你就继续努力寻找它们，直到你找到一些明确的原因。(*我不知道什么是融合！，不喜欢积分，不知道公式*
3.  然后你试着用你超人的策略来移除它们。(*让我们谷歌一下公式吧！*)
4.  然后你应用这些策略，作为回报，你会得到一个结果。(*我答错了*:()
5.  根据你执行上述 3 个关键步骤的成功程度，结果可能是成功的。如果没有，则返回步骤 1。(*哎呀妈的！这是一个负号！*)

在所有这些步骤中，你都在试图构建一个解决方案。解决问题的方法。简单不！

在计算机科学中，在解决计算机问题时，你称这个术语为算法。是的，就像叫茄子一样:茄子！！计算机科学问题的算法(或解决方案)。

#### [](#what-are-these-computer-science-problems)这些计算机科学问题是什么？

*   按名字对 10 亿人的数据进行排序
*   连接两段文本
*   1000000000000000000 中有多少个零？
*   勒克瑙->诺伊达->克什米尔和勒克瑙->哈里亚纳邦->克什米尔哪个更便宜？.....等等..

#### [](#anatomy-of-problem-solving)解剖解题

显然，解决一个问题有很多方法。但是我们不希望我们的计算机程序年复一年地运行，这就是为什么我们希望一个算法(又名解决方案)能在尽可能短的时间内运行。好吧，那我怎么知道哪个解决方案比其他的好呢？
**简单！只需通过运行它们来计算它们所用的时钟时间！**
*但是我们有特定于特定机器的执行次数(i5 或 i3)*
**然后，只统计哪个语句数多。更多的陈述更多的时间！！**
*否，语句数量取决于编程语言和程序员风格*

...................
**然后呢？**
*将运行时间表示为输入大小的函数*
whaaaaaaaaaaaaat？？？

实际上，我们感兴趣的是知道一旦我们增加输入量会发生什么。该解决方案适用于 100 个元素、1000 个元素，但适用于 1 万亿个元素呢？执行时间一样吗？
输入大小是输入中元素的数量，根据问题的不同，它可以是数组的大小、多项式次数、矩阵中元素的数量、二进制表示中的位数或图形中顶点和边的数量。

我们正在根据输入大小的变化将如何影响算法的运行时间来检查有效性。
更快的大输入规模算法是我们正在寻找的东西！！

我们用功能把这两样东西粘合起来。
算法 a 运行时间 f(n): 2n+n-9
算法 b 运行时间 f(n): 7logn+2n
算法 c 运行时间 f(n): 3n+6+n^2

现在我们如何比较 2n+n-9 和 7logn+2n？
*增长率*

### [](#comparing-algorithms-rate-of-growth)比较算法:增长率

假设你打算今年圣诞节买一辆自行车和一栋房子。当你的朋友问你买什么的时候，你会说房子，因为房子的价格比自行车贵。

```
total cost = house + bicycle
total cost = house(~approximately) 
```

行..让我们举一个严重的例子。数学上我们知道:

```
f(n) = n^2+2n+6 ~ n^2(approximately)
f(n) = 4n+2^n ~ 2^n(approximately) 
```

当 n 的值变得非常非常高时，其他项`2n`、`6`、`4n`对 f(n)的影响不如`n^2 or 2^n`大。
无影响的意思是，对于较大的 n 值，`n^2`将变得比`2n and 6`大，以至于其值的变化不会像`n^2`那样有大的影响。所以近似地，我们可以说，对于 n 的较大值，f(n)等价于 n^2

```
f(n) ~ n^2 , n is very large 
```

##### [](#rate-of-growth)增长率

*运行时间作为输入的函数增加的速率称为增长率。*
如果`n^4`、`2n^2`、`100n`是函数的组成项，那么它近似于 n^4，因为 n^4 是增长率最高的。

```
n^4+2n^2+100n ~ n^4 
```

##### 为什么我们对大感兴趣？

实际上，你很难得到 50 或 100 个元素的数据。想想 Gmail 用户、亚马逊或网飞用户、youtube 和高性能计算工具，如模拟和天气预报、大学、办公室等等...我们需要能够处理如此大量输入数据的高效算法

在下一部分，我将把这个讨论引向渐近分析，也就是我们通常看到的(大的东西)