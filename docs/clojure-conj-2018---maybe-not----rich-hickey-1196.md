# Clojure Conj 2018 -也许不是- Rich Hickey

> 原文：<https://dev.to/cjthedev/clojure-conj-2018---maybe-not----rich-hickey-1196>

这是我在这个系列的第一篇文章。Rich Hickey 是 Clojure 语言的创造者。他以清晰的思维和独特的软件方法而闻名。这些是我对他在 Clojure Conj 2018 上发表的题为“也许不是”的演讲的笔记。

## NULL

> 我称之为我的十亿美元错误。这是 1965 年零引用的发明。—东尼·霍尔

## 为什么要使用空值/选项？

*   可选要求
    *   Clojure 通过提供 varaidics 和 kw-args(关键字 args)缓解了这个问题
*   有条件条款(退货)
*   管理部分信息(汇总)

## 也许？

如果我们通过将参数封装在一个`maybe`中来使参数可选或使返回值可选，这两者都会破坏所有的 API，而它应该是兼容的，因为我们使事情可选。

`Maybe` / `Either`不是类型系统的`or` / `union`类型，而是缺乏一流联合类型的证据

Kotlin 通过提供可空和不可空类型解决了这个问题

dotty(Scala 的继承者):联合类型是交集类型的对偶。类型`A | B`的值是类型`A`的所有值和类型`B`的所有值。

`|`是可交换的，即`A | B`与`B | A`是同一类型

> 聚集→一起移动的羊群/牛群

## 地图 vs 记录/字段/产品类型

*   地图
    *   地图是数学函数
    *   编程中最简单的函数
        *   键→值
        *   没有代码，没有类别
*   记录
    *   面向位置的程序设计
    *   即使是命名字段
        *   名字不是一级索引
        *   因此不是函数
    *   产品类型完整的含义和位置
        *   没有办法知道第一个字符串存储什么，第二个字符串存储什么
*   但是记录更加严格(这是好事)
*   规格/键
    *   独立的、可重用的属性，RDF 风格
    *   聚集属性以形成模式

## 可选性和聚集性

*   当一个集合中缺少某样东西时→把它去掉
*   地图是可枚举的，所以如果我们忽略我们不知道的，那么它们就没有空槽

## 上下文

RDF 样式属性是上下文无关的

没有可能→要么你认识一个模特，要么你不认识。

*   一个名字总是一个字符串，你是否知道它是一个正交的概念，用一个类型把它们绑定在一起是错误的

将可选性放在聚合定义中是错误的，因为与 args 和 returns 不同，这里没有使用上下文。

## 我们想要的

*   最大程度的模式重用，因为为同一个想法定义多个上下文特定的模式会导致不同模式定义之间的脱节。
*   支持对称请求/响应
*   信息构建管道

## 图式很深

*   模式可以嵌套
*   属性值可以是集合
*   可选性规格应深入

## 搞定

**分离模式(形状)和选择(当前上下文的可选性)**

该模式将只提到结构，而不是可选性

该选择将在方法签名中描述，以便可以清楚地指定模式的哪些部分是必需的。

将要求属性与属性的要求分开，例如:地址是可选的，但如果提供了地址，则邮政编码是必需的

该系统非常灵活，允许您指定对传入数据的假设，同时默认允许一切。

> 创建可扩展的系统，可以随着时间的推移而改变和增强

[链接到原发言](https://www.youtube.com/watch?v=YR5WdGrpoug)

如果你喜欢这篇文章，请看看这个系列的其他文章:)