# 容器—kubricks 中的应用程序的生命周期是怎样的

> [https://dev . to/campus MVP/container-如-es-El-life cycle-of-one-app-in-kubricks-1ief](https://dev.to/campusmvp/contenedores-como-es-el-ciclo-de-vida-de-una-aplicacion-en-kubernetes-1ief)

> 原帖子由[校园 MVP](https://www.campusmvp.es/recursos/post/contenedores-como-es-el-ciclo-de-vida-de-una-aplicacion-en-kubernetes.aspx) 中的【eduard tommas】

他最近在一篇文章中向你们解释了 **[什么是立方结构，它的架构和基本功能是什么](https://dev.to/campusmvp/qu-es-kubernetes-y-cmo-funciona-mbd-temp-slug-5971176)** 。如果您不清楚这些概念，请在继续之前阅读。

在这一次，我将继续进行这一解释，并分析随 kubernetes 部署的应用程序的生命周期。

我们首先要清楚的是，**在忽必烈从不直接运行容器**。也就是说，不能部署容器或停止容器。而是用所谓的 ***pods*** 操作。

**un*【pod】*是罐体的最低部署和运行单位**。也就是说，我们部署 *pods* ，爬 *pods* ，在不同节点上运行的是 *pods* 。

*pod* 与容器之间的关系不必是一对一的，即**在单一 *pod* 中可以运行多个容器**。只需记住，在这种情况下，它们将一起缩放和部署(因为缩放或部署整个 *pod* 。

虽然理论上可以在一个 *pod* 上部署 web 及其 API 两个容器，但这并不是他通常做的事情。绝大多数情况下*【pod】*和容器之间的关系实际上是一对一的。但一个 *pod* 可以运行多个容器，这就启用了某些高级方案，如拥有一个为另一个容器提供服务的容器(例如， *proxy* 、 *logger* 或类似)。

重要的是要记住，**在同一 *pod* 上运行的所有容器共享网络空间**。也就是说，他们用*【localhost】*互相通信，不能打开相同的端口。他们还共用[【IPC】](https://es.wikipedia.org/wiki/Comunicaci%C3%B3n_entre_procesos)的空间，因此可以使用任何 IPC 技术(如交通灯)相互通信。

## [](#los-distintos-estados-de-un-pod)一个 *pod* 的不同状态

Un *pod* 在其整个生命周期中经历了几个阶段:

*   *:已创建 *pod* ，但尚未创建其容器，也未决定运行哪个节点。*
**   *运行* :已创建 *pod* 容器，且 *pod* 已在节点上运行。“t8”【pod】中至少有一个容器正在运行或正在创建中。*

 *> **这很重要**:一台 *pod* 处于*运行状态*并不意味着其容器正在运行。例如，它们可能正在启动或重新启动。

*   ***成功***:*pod*的容器已圆满完成(全部)运行。
*   *失败；*pod*的容器已经(全部)完成运行，其中至少有一个做错了。*
**   ***【未知】*** :无法得知 *pod* 的状态。这通常表示与正在运行“t8”pod 的节点 *minion* 通信出错。*   ***【克拉何洛普烤箱】*** :驱动器*正在运行，但其中一个容器由于完成(通常错误)而重新启动。**

 **重要的是**将 *pod* 的生命周期与其容器**的生命周期分开。Un *pod* 可能处于*运行阶段*，但其中一个容器可能未运行。当一个*pod _ 处于 _ crashoop back office*阶段时，这意味着其中一个容器正在重新启动，但是 *pod* 中的其他容器可能正在运行。

> 人们常说忽必烈重启一个 *pod* ，但这种说法并不是严格正确的:忽必烈重启一个 *pod* 的容器，但 *pod* 本身在这整个过程中仍在运行忽必烈是否重新启动 *pod* 的容器(以及在何种情况下)取决于 *pod* 的配置。也就是说，对于某些 *pods* 来说，他们决不可能进入*发生的阶段*，因为他们的任务是永久运行(例如 API)，所以如果容器完成，库比涅斯就会重新启动。

*pods* 被认为是‘过渡对象’，意思是说群集中的某些事件是无法生存的。p .例如，如果节点 *minion* 脱落，则在其上运行的所有 *pods* 也随之脱落。***pods*既不移动节点，也不重新启动**(如前所述重新启动其容器)。

一般来说，*pods*不会直接生成，而是使用我们称之为**控制器**。一个控制器负责确保其控制的 *pods 在任何时候都满足一定条件，就像在任何时候都有该 *pod* 的实例一样。*

> 我在此提出一个命名事项:当我说“n 个‘t0’pod’t1’实例”时，我指的是 N *相同的 pods(运行相同的容器和配置)，但它们是 N _pods* 。

如果我们使用一个控制器，并且希望在任何时候都有给定‘t0’pod’的 2 个实例，而其中一个‘T2’pods 死亡(因为它的节点 p。)，控制器将创建另一个 *pod* ，以确保继续存在两个实例。

当我们有 n 个实例时，n′t0′pods〖t1〗都被认为是“相同的”。如果出于某种原因(例如必须取消缩放)需要删除任何“*pod”*，则驱动程序将删除任何一个，而无需任何首选项。这符合集装箱完全符合的应用模式*【无状态】*。也就是说，作为开发人员，您必须确保您的容器是*无状态的*，因为您可以随时选择删除 *pod* (从而删除容器)，并在别处重新创建。

这种模式*无状态*并不总是适用:有时，如果我们有 *pod* 的 n 个实例，就有一些发挥特殊作用，因此要求它们具有身份。一个示例是主/从属数据库配置。如果其中一个 *pods* 掉下来了，认为新的应该是同一类型，不仅如此，还应该接收到 *pod* 掉下的状态。kubernetes 能够通过特定的控制器(名为“`StatefulSet`”来处理这些案例，但理想情况下我们的应用程序应为“*无状态”*。

> 原帖子由[校园 MVP](https://www.campusmvp.es/recursos/post/contenedores-como-es-el-ciclo-de-vida-de-una-aplicacion-en-kubernetes.aspx) 中的【eduard tommas】***