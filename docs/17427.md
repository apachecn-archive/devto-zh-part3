# 改变你的视角

> 原文:[https://dev.to/flaque/change-your-perspective-5ac1](https://dev.to/flaque/change-your-perspective-5ac1)

让我们想象一种要求你自带运行时的语言。

为了理解我的意思，让我们稍微回顾一下编程语言是如何工作的。

## [](#start-with-a-calculator)用计算器启动🧮

当你在你的 ti-89 或当今 80 年代技术学校学生使用的任何高价设备上输入东西时，你输入的是一种语言。这种语言有词法分析器、语法分析器、运行时等等。

取以下:

```
1 + 1 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

当计算器遇到`1 + 1`时，它遍历并把接收到的字符串转换成令牌，类似于:

```
INT(1) PLUS INT(1) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后，它通过一个递归下降解析器运行这些令牌，该解析器看起来像这样:

```
int() {
  return items.pop()
}

expr() {
    left = int()
    op = items.pop()
    right = int()

    return int() + int()
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

最后，它将调用`expr()`并将其返回给用户。

## [](#programming-languages-end-with-an-expression)编程语言以表达式结尾

一天结束时，编程语言将评估它的文字，然后通过它的运行时调用一些操作系统函数。

所以一种更“程序 y”的语言，可能会这样做:

```
print(1 + 1) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这将转换成:

```
PRINT LEFT_PAREN INT(1) PLUS INT(1) RIGHT_PAREN 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

会变成这样:

```
root() {
  system.print(expr())
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#back-to-our-fantasy-language)回到我们的幻想语言

在现有的编程语言中，运行时远远隐藏在编译器之下。事实上，这种语言的全部意义就是将运行时从你身边抽象出来。

你不需要知道什么系统命令执行打印功能或打开文件，因为你可以运行`print()`或`open()`。

## 如果我们让 runtimes 成为一等公民，会发生什么？

相反，让我们想象一种语言，在这种语言中，你被鼓励、支持并被期望去编写一个替代的运行时。

例如，如果编程语言说`print`，你可以准确定义`print`的意思。

相反，您打印机可以调用任意的文本到语音代码。如果它在 web 中，它可以返回一个组件。或者它可以调用任意函数。

## [](#change-your-perspective)改变你的视角

通常，我们认为软件是一个不断变化的系统，它运行在一个极其不变的基础上:语言运行时。大多数语言的全部意义在于给你一个工具，在每个人的电脑上运行相同的。

运行时抽象出多个操作系统和硬件，因此您可以始终确保逻辑保持不变。

但是这样做的话，我们经常会不小心将代码的*逻辑*耦合到它运行的*域*。无数的时间被浪费在重写同一个“与数据库对话的 web 服务器”解决方案上。

相反，如果我们不使用常量运行时，而是使用常量代码会怎么样。

如果您只是从包管理器中取出“web 服务器代码”并重写较低层次的代码会怎么样？而不是自己重写整个故事？

你的 CRUD 应用程序可以被重写，只需重写语言的输出就可以在 iOS、Android 和 web 上运行。

## [](#woah-woah-woah-isnt-this-super-insecure)woah，Woah，Woah 这不是超级没有安全感吗？

大概吧。虽然这也可能是一个安全福利。想象一下，能够将运行时的能力赋予个人用户。

任何运行程序的人都可以禁止不安全的调用。不再有不可信程序的`chmod`或网络调用。

## [](#whats-the-point-of-this)这有什么意思？

建造这样的东西是愚蠢的。大多数可以用这样的语言解决的问题已经用其他方法解决了。

操作系统有更好的访问控制，模块化让我们有自己的伪运行时，这可能太奇怪而没有用。

但是探索解决现有问题的替代方法可以锻炼你大脑中有趣的肌肉。也有点好玩。