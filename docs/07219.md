# 多达 20%的应用程序依赖项可能无法维护

> 原文:[https://dev . to/tide lift/up-to-20-of-your-application-dependencies-may-be-un maintain-5ga 3](https://dev.to/tidelift/up-to-20-of-your-application-dependencies-may-be-unmaintained-5ga3)

我们最近增加了一个新功能，Tidelift 用户可以使用它来发现未维护的依赖项。重新利用这一特性来收集一些普遍感兴趣的数据，看起来大约有 10-20%的*常用的* OSS 包没有得到积极的维护...这意味着在过去的一年中没有一个提交，*和*大多数问题和 PRs 在过去的一年中仍然是开放的。

这个数字让我们大吃一惊！我们预计会有很多包维护不足，但是我们没有想到会有这么多根本没有活动的包。

我们认为这是一个系统性的问题。个人维护者没有过错。

我们也觉得这是一个值得解决的现实问题。

## 总之，为什么维护很重要？

在这篇博文中，我们首先看了一个样本 JavaScript 代码库(我们自己的支持 Tidelift 的库之一)。

当我们将应用程序部署到生产环境中时，它将包含我们自己编写的代码和大量来自开源依赖项的代码。在我们的示例 repo 中，我们编写了大约 15%的代码行，开源开发人员编写了大约 85%。我猜这是一个相当普遍的比例。

在大多数组织中，没有人真正知道 85%中有什么(尤其是在许多回购的总和中)，也没有人知道它是否得到维护，或者谁在维护它，或者维护到什么标准。

有人会处理安全漏洞吗？包裹是否有被[交给恶意参与者](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident)的风险？该项目是否有健全的法律实践？这个项目会跟得上一个不断发展的生态系统吗？或者当它不能和其他东西一起升级时，会让你陷入[依赖地狱](https://dev.to/dependency-hell-is-inevitable)吗？项目会看到任何有用的新特性或追踪与其功能相关的新规范吗？

我们知道保持我们的 15%很重要，但是对于那 85%我们甚至不去追踪它是什么，更不用说有一个计划去照顾它了。这部分是因为对于如何保护它还没有一个明确的答案；那个计划是什么？

团队可能会合理化自己的问题:“嗯，我们真的不知道如何保持这些依赖关系，但其他人都在使用它们，所以这可能是好的。”这个[绝对不正确](https://dev.to/who-supports-react-that-depends-on-what-you-mean)。

我们查找未维护依赖项的新特性提供了更多证据；我们在我们自己的示例回购的依赖项上运行了它，我们有很多需要改进的地方。

## [](#how-we-define-unmaintained)我们如何定义“无人维护”

对于第一次切割，我们非常狭义地定义了未维护:

*   该项目在去年没有提交
*   如果去年有任何问题或 PRs，其中不到一半被关闭

使用这个定义，我们的样本库的 1285 个依赖项中有 259 个(20.15%)是未维护的。

其中一些项目在它们的自述文件中被明确标注为不可维护，但是更常见的是它们被“幽灵化”(活动在某个点停止，但是它们没有被标记为不可维护)。

请注意，我们谈论的是一个非常普通的应用程序中广泛使用的包。事实上，从这个角度来看，任何主要的单页面应用程序框架中的“Hello，World”看起来都与我们的示例 repo 相似。

如果我们看一下*所有*包的百分比(也就是说:包括不受欢迎的包)，可以合理地猜测，无人维护的数量将高于 20%。不是危言耸听，但 20%可能是最好的情况——如果你*只*使用当前流行的东西，这是一个数字。一旦你开始从“Hello，World”栈之外添加包，或者一旦时间流逝，你使用的是老一代的包……情况可能会变得更糟。

到目前为止，我们只标记那些拥有已知 GitHub 库的未维护包(因为我们使用 GitHub 的 API 来收集指标)。如果一个包不在 GitHub 上或者我们不能确定它的仓库，我们假设它被维护了。这可能是保守数字的另一个来源，特别是对于像 Maven 这样的老生态系统。

## [](#i-know-what-youre-going-to-say)我知道你要说什么！

每当我在互联网上看到一个关于未维护的软件包或 OSS 指标的帖子，人们都想争论细节…我很同情，但这些争论中有许多是站不住脚的合理化。以下是听到无人维护的包裹时的三种常见反应:

*   表面上没有维护的包实际上已经“完成”了，所以不需要维护
*   这只是 npm/JavaScript 的问题
*   自动化的度量标准可能会遗漏一些关键的细节或死角

这三个都是真实的:它们有一点真实性，也就是说，它们移动了一点数字，但它们没有改变情况的数量级。

## 这些包裹还没有全部完成

事情是这样的。“特性冻结”和“不维护”之间有很大的区别即使一个包是特性冻结的，如果发现安全问题，移动到生态系统的新版本，或者至少记录项目是特性冻结的，也有基线工作要响应！

考虑一些非常不同的场景:

1.  维护者不再响应——他们继续前进，不再做任何事情，而问题经常被忽略。
2.  维护者在自述文件中记录了该包未被维护或被弃用，并建议改用其他东西。
3.  维护者记录道“没有新的特性会被接受，但是如果有严重的问题或者需要新的版本，请让我知道，我会处理的。”

在我们标记为未维护的包中，场景 1 是最常见的，场景 2 偶尔出现，场景 3 最不常见——事实上很难找到例子。场景 3 是我称之为“完成但仍在维护”的场景

Sindre Sorhus 维护超过 1100 个 npm 软件包，并支持 Tidelift 上的 100 多个软件包；他说:

问:我们经常听到的一个评论是，许多 JavaScript 项目不需要维护者，因为它们已经“完成”了你对这种哲学有什么想法吗？

答:这只适用于小型封装。因为它们的范围很窄，所以可以按特性来做。然而，这个参数忽略了包所需的所有其他维护任务；使用已弃用的 node . js API 保持最新，新的更好的 node . js API，新的语法(可以提高可读性，有时还会更快)，依赖关系更新(对于减少依赖关系树中的漏洞尤其重要)，错误修复，文档改进，问题分类，添加 TypeScript 类型定义等。在更大范围的包中，您还需要处理特性请求和细化现有的特性。维护所需的工作经常被低估。我每天在这些任务上花费大量的时间。

## 这些包裹并不都是微不足道的

我们碰巧计算了。每个包包含的 js 文件——这里有一些数字。对于我们的示例 repo，平均而言，未维护的包比维护的包小(11K 行代码对 40K 行代码)。这意味着尽管有 20%的包没有被维护，但这 20%只代表不到 20%的代码。

然而，许多这种无人维护的包都很大。我真的很想链接到具体的项目，但我决定不这样做，因为这些维护者的错误并不在于软件包的衰落，而且将具体的项目放在现场似乎有些苛刻和跑题。

在不指名道姓的情况下，我们谈论的是解析器和其他实质性的库。是的，也有一些短短几行的软件包。这绝不会改变整体情况。给你一个分布的感觉，在 259 个未维护的包中，91 个包含 1K in 以下。js 文件，而 75 包含超过 4K 在。js 文件。

请记住，对于一些维护不足的风险(如[事件流式风险](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident)或需要跟上生态系统)，无论“完成”还是“规模小”都不一定重要。重要的是有人还在周围看着。

## 这不是 JavaScript 生态系统独有的

听到这些维护统计，有些人会回答“lol JavaScript”除非你真的研究过你使用的依赖关系(还有最近的*，因为维护人员一直在做鬼)，否则我建议你不要太自信。不维护和维护不足在所有开源软件中都很常见。*

 *JavaScript 似乎确实有更细粒度的代码重用和更分散的维护；这既有成本也有收益。除此之外，它使得分析缺乏维护变得更加容易(我们的方法不能检测大型项目的未维护的子目录，只能检测未维护的整个存储库)。

以下是我们目前发现的一些情况:

*   React、Angular 和 Vue 的“Hello World”都有我们在样本 Tidelift 代码库中看到的大约 20%的未维护数量。
*   在我们不久前创建的一个常用的 pypi-dependencies 示例存储库中，有 13%的包是未维护的。
*   一个“Hello，World”Spring app 看起来大概有 8%的未维护包……但是我们只有在有来自 GitHub 的指标的情况下才标记未维护的东西，而有些 Maven 包缺乏指标，所以这个数字很低。
*   一个“Hello，World”Rails 5.1 应用程序有 70 个中的 8 个不符合我们使用的标准，而 5.2 有 79 个中的 10 个，所以这是 11-12%。

总的来说，我们似乎可以在非 JS 生态系统中发现大约 10%的未维护资源，而在 JS 应用程序中则有 20%。一个细节是，基本上所有的 10%都是更大的、实质性的包，因为这些生态系统没有 npm 上常见的小包。

还要记住,“Hello，World”JS 应用程序是完全包含电池的，而一些框架在默认情况下根本没有依赖关系。现实世界的应用程序将会引入更多的依赖(它们不会只坚持最初的框架)，所以它们可能会变得更类似于包含电池的 JS 应用程序。

请不要过分解读上面的确切数字；我们没有假装这是一个科学的比较。关键是所有的生态系统都有消失的维护者，我们都不应该觉得这仅限于 JavaScript。

## [](#the-packages-are-actually-abandonedit-isnt-a-metrics-artifact)包实际上被放弃了——这不是一个度量工件

我们对“未维护”的定义简单而保守，在这个样本 JavaScript 项目中仍然有 20%的未维护。

我们想知道像“嗯，也许提交是在一个奇怪的分支上，”或者“也许没有问题，”这样的极端情况，所以我们继续手动查看这些存储库。(在 [Tidelift 订户仪表板](https://tidelift.com/subscription/how-tidelift-subscription-works)中，有一个指向我们识别的每个未维护包的回购的便捷链接，使这一操作变得更容易。)

简而言之:自动化的标准基本上是正确的。大多数情况下，这些仓库已经很久没人动过了。大多数已经不活跃超过一年，他们往往有许多被忽视的问题。

我们还没有试图确定下的*-维护，然而，只有全面放弃。人们已经为 OSS 项目提出了[许多复杂的度量标准](https://github.com/chaoss/metrics)。因为看起来我们有很多工作要做，只是为了解决完全不活跃的项目，所以没有必要马上变得花哨。*

20%从两方面来看都是一个保守的数字:

1.  如果在过去的一年中有一个提交，或者大多数问题在过去的一年中被关闭，我们标记这个包被维护。
2.  我们看到的是主流“你好，世界”中的包，而不是存在的整个包世界。

例如，我有一个[维护严重不足的项目](https://github.com/lightbend/config)，上面有我自己的名字。这个包不符合我们最初的免维护标准，因为我偶尔会合并一个 PR，但它 95%是免维护的——我没有时间。问题和公关堆积如山，其中很多值得关注。

很难准确地标记像我这样的项目，而不引入更多的误报或有争议的判断。从开源的角度来看，坏消息是保守的屏幕仍然会标记很多包，这样做通常是正确的。

## [](#how-can-we-improve-this-situation)如何才能改善这种情况？

我们认为解决方案包括[为维护者提供的价值](https://dev.to/open-source-has-a-working-for-free-problem)付费。影子包和维护不足的包之所以存在，是因为人们缺乏时间和动力来维护它们。很难为一个废弃的包找到新的维护者，用户也很难离开一个废弃的包。正确的解决方案是让维护人员留下来，并给维护人员一个采用孤立包的理由。

以下是我们如何努力改善 Tidelift 的开源维护问题:

*   我们向购买 Tidelift 订阅的应用开发团队所使用的任何包的维护者提供月收入。Tidelift 的用户使用某个特定的包越多，该包的维护者得到的报酬就越多。
*   用户可以看到他们使用的似乎没有维护的软件包的明细，以及维护不足的后续影响，如安全和许可问题。
*   对于直接依赖，我们帮助订户找到替代方案；当没有其他选择时，如果维护者再次出现，或者出现了其他选择，我们也会提供月收入。
*   对于可传递的依赖(依赖的依赖)，应用程序开发团队自己往往做不了多少。因此，当我们向订户展示间接引入的安全、维护和许可问题时，我们也向我们的参与维护者网络展示同样的问题，并且我们要求那些维护者修复他们的包引入的问题。我们将问题推到堆栈的底部，以解决根本原因。
*   除了报告历史问题之外，我们向你所使用的东西的维护者付费的事实应该会降低你的软件包未来的“幽灵率”。

每个用户都有一定数量的“特殊雪花”，特别是随着时间的推移——他们正在使用的古怪的软件包，或者旧版本，等等。通过跟踪他们对 Tidelift 的确切依赖关系，每个用户都知道他们所处的位置，知道他们被覆盖了——T2，因为有了 Tidelift，他们就向维护者付费，让他们被覆盖。

这个问题的真正解决方案需要是全面的:

*   *工具*让每个人都能看到问题所在，并找到根本原因。

*   *激励措施*这样我们就可以付钱让维护人员留下来解决问题，而不是为他们的[无偿劳动](https://dev.to/open-source-has-a-working-for-free-problem)产生一堆新的请求。

这不是假设。我们现在向维护者付费，并帮助订阅者改善他们的依赖性。

## [](#let-us-prove-it)让我们证明一下

好奇你用的是哪个无人维护的包？选择一个样本库(最好是您实际维护和关心的东西)，将包管理器文件发送给我们，我们将通过电子邮件向您发送一份报告，其中包含您所依赖的 10 个最重要的未维护包。

在此提交您的文件。*