# 为什么要学习...静态类型语言？

> 原文:[https://dev . to/gypsydave 5/learn-a-static-typed-language-42n 5](https://dev.to/gypsydave5/learn-a-statically-typed-language-42n5)

大多数人的第一种编程语言是动态类型的、解释型语言——JavaScript、Python 或 Ruby。这些都是学习编程的优秀语言，使用这三种语言你会非常有效率。但是有一类独立的语言被广泛使用:静态类型的编译语言——C、Go、Java、C#和许多其他语言。本文将尝试解释这两种语言类别之间的区别，看看它们的优缺点，然后考虑对于只熟悉动态类型语言的程序员来说，学习静态类型语言是一个不错的选择。

*   [这是给谁的](#who-is-this-for)
*   什么是静态类型的编译语言？
*   [优势](#advantages)
*   [缺点](#disadvantages)
*   我应该从哪里开始？

## [](#who-is-this-for)这是给谁的？

本文的目标读者是熟悉动态类型语言编程、对学习静态类型语言感兴趣并想知道为什么值得学习的人。例子有 JavaScript、TypeScript、Python 和 Go，但是不需要这些语言的知识。它是基于我自己作为一名自学成才的开发人员的经历，我开始使用 Ruby 和 JavaScript，并扩展到了像 Go、TypeScript、Kotlin 和 Rust 这样的语言。

## [](#what-is-a-statically-typed-compiled-language)什么是静态类型化、编译型语言？

这里要看两对对立面:*动态类型化* vs. *静态类型化*，*编译* vs. *解释*。让我们按这个顺序来看一下。

### [](#dynamic-vs-static-typing)动态 vs 静态打字

如果有人问你:

> 一根香蕉加五是多少？

你会感到困惑——它们是什么意思？看起来他们犯了一个错误。也许他们不知道‘add’是什么意思，也不知道‘香蕉’是什么。也许它们对我们来说有着不同的意义。尽管有些地方出错了，因为他们的问题对我们来说没有意义。 <sup id="fnref1">[1](#fn1)</sup>

编程语言有一种方式告诉我们，用该语言编写的表达式有意义或没有意义。他们通过使用编程语言中每个值都有的*类型*来实现这个目的。在动态类型语言中，只有当我们以错误的方式使用一种类型的值时，我们才真正意识到类型——当我们说一些没有“意义”的话时。

例如，在 Python 中我们可以这样写:

```
5 + "banana" 
```

尝试将它保存在一个名为`typecheck.py`的文件中，并用`python typecheck.py`执行它。您应该会在您的终端中得到以下错误:

```
Traceback (most recent call last):
  File "typecheck.py", line 1, in <module>
    5 + "banana"
TypeError: unsupported operand type(s) for +: 'int' and 'str' 
```

这是一个类型错误——从错误消息中显示的方式可以看出这一点。这个错误告诉你你不能把类型`int`和`str`放在一起`+`。这很公平；就像你不知道如何把 5 和一根香蕉加在一起，Python 也不知道。

类型错误由*类型检查器*抛出，它检查表达式中的所有类型是否以正确的方式使用。当 Python 程序运行时，类型检查器开始工作，检查两个被`+`在一起的东西是否是正确的类型。 <sup id="fnref2">[2](#fn2)</sup>

类型检查可能发生在两个时间之一:当程序运行时(通常称为“运行时”)或在此之前的某个时间。动态类型语言在运行时检查它们的类型——这就是我们上面运行的 Python 程序所发生的情况；程序运行时，打字错误变得很明显。静态类型语言在运行之前会检查它们的类型。

#### [](#type-annotations)类型标注

为了让类型检查器准确地检查静态类型语言中的类型，您通常必须通过*类型注释*显式声明变量的类型。类型注释是添加到变量中的一点额外信息，用来说明它是什么类型。在英语中，我们可以想象给名词和动词添加类型注释，作为括号中的额外信息。所以我们的简单句子:

> 一根香蕉加五是多少？

成为

> 香蕉(是一种水果)加五(是一个数字)是多少？

这可能是自然语言不适合类型注释的好证据。

有了这些英文类型注释，我们不需要知道什么是“五”，什么是“香蕉”，什么是“加法”，就知道这个句子没有意义。我们甚至不需要知道“数字”是什么。我们只知道中间的动词需要两个类型为“number”的名词，这个句子才有效。我们可以只通过看单词来自动执行这种检查，而不必知道它们的任何意思——我们不能对“水果”做“添加”。静态类型语言中的类型检查器以同样的方式工作。 <sup id="fnref3">[3](#fn3)</sup>

让我们看看 TypeScript 中的类型注释，它是 JavaScript 的一种静态类型变体:

```
var theNumberFive: number = 5 
```

这声明了变量`theNumberFive`的类型为`number`，并为其赋值`5`。

在 JavaScript 中对应的是:

```
var theNumberFive = 5 
```

完全相同，只是没有类型注释。

我们还可以在函数签名中添加类型声明。JavaScript:
中的函数`add`

```
function add(n1, n2) {
    return n1 + n2
} 
```

在 TypeScript 中是这样的:

```
function add(n1: number, n2: number): number {
    return n1 + n2
} 
```

我们说函数`add`有两个参数，`n1`是一个`number`和`n2`是一个`number`，并且返回值也是一个`number`。

这些注释将由 TypeScript 类型检查器使用，该检查器在 TypeScript 被*编译*时运行。

### [](#compiled-interpreted)编译/解释

在解释型语言中，例如 JavaScript，程序的每一行都是由解释器一行接一行地依次读取和执行的，解释器从你编写的程序中一行一行地构建运行过程。

编译是将你用一种语言编写的程序转换成另一种语言的行为。对于 TypeScript，目标语言是 JavaScript。在编译期间，即“编译时”，类型检查器将分析 TypeScript 程序中的任何错误。

编译器通常用于将高级编程语言(如 JavaScript)翻译成低级语言，如汇编语言或机器码。在类型脚本的情况下，编译器输出另一种高级语言——JavaScript。 <sup id="fnref5">[5](#fn5)</sup>

当使用特定的编程语言时，编译和解释几乎没有固定的区别——解释器有时会在代码执行前运行编译步骤， <sup id="fnref6">[6](#fn6)</sup> ，编译器的输出必须由解释器运行。此外，被编译或解释不一定是语言本身的属性。编译器是为正常解释的语言编写的，解释器是为正常编译的语言编写的。

对于静态类型的编译语言，编译步骤是类型检查器运行的地方。类型检查对编译器很有用，因为它允许编译器优化软件的性能——如果一个变量总是为`number`,它可以优化使用的内存位置。

## [](#advantages)优点

### [](#type-checking-catches-mistakes)类型检查捕捉错误

让我们把这些放在一起，用 JavaScript 和 TypeScript 编写我们的自然语言“表达式”例子。我们很快就会看到静态类型语言的一个优点

```
var five = 5
var banana = "banana"

function add(n1, n2) {
    return n1 + n2
}

add(five, banana) 
```

这将给我们结果

```
'5banana' 
```

哦 JavaScript...余乐于`+` *任何事情*在一起。对这种错误一笑置之很容易，但是我见过一些团队花了几天的时间来研究基于一个以字符串形式存储的数字的 JavaScript 错误。这是一个容易犯的错误。这也是那种永远不会发生在你身上的错误——除非它发生在你身上。

但是如果我们试图在 TypeScript
中复制同样的错误

```
var five: number = 5
var banana: string = "banana"

function add(n1: number, n2: number): number {
    return n1 + n2
}

add(five, banana) 
```

当我们用 TypeScript 编译器 <sup id="fnref8">[8](#fn8)</sup>
编译这个的时候

```
add.ts:8:11 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.

8 add(five, banana)
            ~~~~~~

Found 1 error. 
```

TypeScript 编译器已经发现了我们的错误，甚至在我们出错的地方加了下划线——我们不能在应该放`number`的地方放`string`。

从程序员的角度来看，这是静态类型的最大优势；类型检查器确保我们没有做任何*愚蠢的事情*，比如像使用`number`一样使用`string`。突然间，我们对自己编写的程序将如何工作有了一个新的层次的把握——甚至不用运行它。

### [](#editor-integration)编辑整合

但是类型检查的乐趣并没有随着编译而结束——远远没有。因为类型检查器甚至可以在你编译程序之前运行，所以它可以和你的文本编辑器集成在一起，在你打字的时候给你程序的信息。因为类型注释声明了变量的类型，所以编辑器现在可以告诉您有用的信息，比如可以对它使用哪些方法。 <sup id="fnref9">[9](#fn9)</sup>

### [](#compiled-code-runs-faster)编译后的代码运行速度更快

编译不仅仅是将一种语言翻译成另一种语言；编译器还会查看你的程序，并试图找出让它运行得更快或更有效的方法。例如，递归函数调用变成了简单的循环。

## [](#disadvantages)缺点

这些听起来都不错——但是使用静态类型的编译语言的缺点是什么？

### [](#compilation-takes-time)编译需要时间

编译程序可能需要很长时间。如今，使用快速计算机和优秀编译器的时间越来越少，但在我经历过的最糟糕的情况下，仍然只有两三分钟。如果你的工作流程依赖于快速、紧密的反馈循环，那么当你的程序变得越来越大时，你可能会发现一个令你烦恼的编译器。

### [](#types-need-more-syntax)类型需要更多的语法

如果您习惯于动态类型的语言，静态类型的语言的冗长会非常令人讨厌。必须声明每个变量和函数参数的类型会让人觉得很累。现代语言会尽可能地通过推断变量的类型来消除这种压力，但是像 Java、C#、C++和 C 这样的老式静态类型语言看起来会非常冗长。

### [](#the-world-isnt-typed)世界不是打出来的

静态类型语言的冗长在程序的边界上表现得非常明显——在那里它与“世界”交互。需要一些额外的步骤来处理进入系统的数据。这在解析 JSON 时变得很明显——为了获得系统中类型的全部好处，您必须将一般的`JSON`类型转换成您自己的类型，这可能相当困难。动态语言使这变得容易得多(尽管更容易出现类型错误，如上所述)。

### [](#no-repl-based-development)没有 REPL 基础的发展

大多数编译语言不支持读取-评估-打印循环， <sup id="fnref10">[10](#fn10)</sup> ，也不支持像 Clojure 这样的交互式开发。如果你以这种方式工作，你将会错过它——如果你不这样做，对你来说也不会有什么不同。

## [](#where-should-i-start)应该从哪里开始？

那么什么是好的静态类型的编译语言呢？

如果我对 JavaScript 有很多经验，那么可能有一个很好的理由去尝试 TypeScript，但是我发现编译成 JavaScript 的语言会引入一层开销和工具，这会阻止你专注于该语言。

我建议避开 Java，因为这种语言有很多不必要的缺点和复杂之处，其中一些是 c 语言的遗留物

```
User user = new User() 
```

在 Java 中，这总是让我觉得我已经写了单词`user`至少两次了，为了 Go

```
user := NewUser() 
```

如果你*想看看基于 JVM 的静态类型语言，Kotlin 是个不错的选择。*

在我看来最好的选择是 [Go 编程语言](https://golang.org/)。它有一个简单的类型系统(不需要担心泛型类型)，语言的语法很小而且容易学习，工具和文档是同类中最好的，并且越来越受欢迎。看看优秀的[比试](https://gobyexample.com/)或[学步带考](https://github.com/quii/learn-go-with-tests)。

## [](#what-do-you-think)你怎么看？

你有从动态类型语言过渡到静态类型语言的经验吗？还是反过来？最难的部分是什么？你有什么建议？你认为哪种语言是对静态类型的最好介绍？

* * *

1.  我们可以说这个句子在句法上是正确的，但在语义上是无意义的。 [↩](#fnref1)

2.  试着想象一下，如果一种语言中没有类型会发生什么。你所拥有的只是在内存中浮动的位。你怎么知道“数字”是从哪里开始的？还是结束了？或者程序在内存的哪个位置？这就是为什么所有的编程语言都是类型化的——没有它们编程是不可能的。 [↩](#fnref2)

3.  虽然类型检查器*通常不知道*正在查看的值的类型，但它会知道`1`是一个数字。这就是类型推断的工作方式，帮助静态类型语言变得不那么冗长。例如，在 Go 中，我们只需说出`x := 1`，类型检查器就能推断出`x`的类型是一个数字。 [↩](#fnref3)

4.  这里有一些微妙之处——通常语言解释器会动态地编译部分代码，而编译后的语言可能会有一些代码段，其类型只能在编译后运行程序时(在“运行时”)才能确定。 [↩](#fnref4)

5.  这有时被称为*传输*。 [↩](#fnref5)

6.  出于显而易见的原因，这被称为“实时”编译器。 [↩](#fnref6)

7.  如果你还没有看过加里·伯恩哈特的 JavaScriptWAT 视频，现在是个好时机。 [↩](#fnref7)

8.  如果您有兴趣亲自查看，您的计算机上需要一个 NodeJS 环境。然后，您需要通过运行`npm install -g typescript`从 NPM 安装 TypeScript 编译器。要编译一个类型脚本文件，即名为`add.ts`的文件，运行`tsc add.ts`。如果没有编译错误，编译后的 JavaScript 输出将位于一个名为`add.js`的文件中。 [↩](#fnref8)

9.  这种帮助*在动态类型语言中*是可用的，但是程度不同。 [↩](#fnref9)

10.  当然，这里有一些细微的差别。例如，在 Java 虚拟机(JVM) *上运行的语言*可以通过将从 REPL 发出的编译后的 Java 字节码直接发送到 JVM 的运行实例来支持 REPL。 [↩](#fnref10)