# 汽车和面向对象程序设计，一个坚实的理解

> 原文：<https://dev.to/jckuhl/automobiles-and-oop-a-solid-understanding-3cag>

# 固体

SOLID 是面向对象编程中五个最佳实践原则的缩写。目的是让 OOP 更具可重用性和可维护性，更容易理解。

坚实的原则如下:

**单一责任**

*   一个班做好一件事又一件事

**打开-关闭**

*   一个类可以扩展，但不能直接修改

**利斯科夫换人**

*   在不破坏程序的情况下，一个超类可以被一个子类替换

**界面偏析**

*   最好有小的特定接口，而不是一个大的接口

**依赖倒置**

*   一个类应该依赖抽象而不是具体

这有点拗口，所以我将扩展我的汽车类比来谈论每一个类似的原理。

# 单一责任

汽车是由许多不连续的零件组成的。制动器、车轮、发动机等。我要把重点放在引擎上。现在，大多数人认为发动机的职责是让汽车行驶，但这不是真的。

发动机的职责是旋转曲轴。就是这样。让汽车行驶是许多不同部件的共同努力，每个部件只做一件事。然而，引擎并不关心刹车、车轴或车轮。它唯一的工作就是转动曲轴。事实上，你甚至可以把引擎从车里拿出来，放到别的东西里，引擎就会完成它的工作。

汽车的每个零件都是这样的。刹车只关心对车轮施加摩擦力。火花塞只关心活塞“燃烧”阶段的点火。

现在，这可能是机械工程的一个局限，创造一个同时做多件事的零件并不容易，但在编程中，这非常容易，甚至很诱人。为什么不做一个大师班呢？

因为它会变得一团糟，这就是原因。如果您有一个与应用程序的多个部分相关的单个对象，在这里更改一个东西可能会以一种不太可预测的方式破坏其他地方的其他东西。也许代码是旧的，你已经忘了这里的值在那里有双重功能。

这是一个可以扩展到 OOP 之外的原则，也是一般编程的好原则，尤其是在函数式编程中。一个功能应该做一件事，并且做好。

但是“做一件事”是什么意思呢？毕竟，拥有一个只有一行指令的函数或对象是没有意义的。这是一个设计的问题，基于你自己的判断。这取决于你和你的团队将软件分成具有不同角色的小的离散部分，并创建类、对象和函数来执行它们。

例如，假设有一个对象负责连接到您的数据库。这就是它应该做的。它也不应该执行 CRUD 操作或公开公共 API。它应该连接到数据库并管理该连接。就是这样。就像汽车的引擎一样，你可以从你的软件中分离出这样一个对象，并在其他地方使用它。如果您开始在其中构建 REST 方法和 CRUD 方法，它会变得更加复杂，可重用性更低。

# 开-关

开闭原则认为对象不应该被修改，而只是被扩展。这类似于继承。当斯巴鲁或福特制造汽车时，他们*在汽车的原始概念上扩展*。(当我谈到依赖倒置原则时，我们将进一步触及这一点。)我们对汽车有一个基本的想法，没有人想改变它，而且理由很充分。如果斯巴鲁“改变”了汽车的概念，他们就会生产出一辆我们无法轻易操作的汽车。

现在，这里的类比失败了，因为我们对汽车的概念是抽象的，但假装它是具体的，如果你改变了基类，那么所有的派生类也坏了。

一旦创建了对象或模块，就应该能够编写代码来扩展它，根据需要向扩展添加字段和属性，而不是向基本对象本身添加。相反，基本对象保持其内部封装，只暴露它需要暴露的部分。

# 利斯科夫——换人

Liskov-Substitution 声明超类型可以被子类型替换而不破坏代码。如果我用一个基类对象写代码，我应该能够用它的任何子类型替换那个基类对象，并且它仍然工作。继承通常是允许这种情况发生的方法。

大多数人知道如何驾驶汽车。如果你认为福特或斯巴鲁或雪佛兰是汽车的子类，你可以用任何其他汽车替换任何汽车，并且仍然知道如何操作它。每个汽车品牌和型号都有不同的属性，但它们是一样的，因为它们都是从汽车的基本类别中派生出来的，不需要修改就可以替换。

# 界面偏析

最好有许多小的特定接口，而不是一个大的。一个大型的通用接口，就像一个大型的对象，是不可维护的，也是笨拙的。相反，软件应该被分解成更小的组件来完成简单的事情。

例如，我汽车上的雨刷不依赖于其他系统(除了基本的电子设备)先激活或不激活。它们不依赖于其他部分的状态。

当我可以根据需要添加或删除接口时，这还有进一步的用途。以电脑为例。一个接口是键盘。它做一件事，它发送键盘指令到主板。它不依赖于任何其他部件(甚至不依赖于主板，因为它可以插入*其他*主板和可能的其他硬件部件。)可以在不影响电脑其他部分的情况下移除。

这是笔记本电脑的一个缺点，尤其是 MAC 电脑。你不能轻易交换部件，接口是一个巨大的块，Mac 用户没有能力添加新的 RAM 或内部 ROM。

将软件分解成独立的部分，并保持它们相互独立。试着从“即插即用”的角度来思考

# 依存倒置

这里的原则是类应该基于抽象，而不是具体的实现。

再说一次，我们都知道汽车是什么以及如何操作。我们驾驶的汽车，我们驾驶的具体金属物体，基于汽车公司总部储存的具体图表，都是基于这个抽象的想法。关于如何实现 car 的确切细节可以在 schematics(类)中找到，并在 car 本身(实例对象)中构造。)

Java Servlets 是面向对象编程的一个很好的例子。层次结构如下:

*   Servlet 是一个接口。
*   GenericServlet 是实现 Servlet 的抽象类
*   HttpServlet 是实现 GenericServlet 的具体类。

我们从 servlet 是什么的抽象概念开始。*接口*让我们知道这些类需要实现什么。*抽象类*将提供更多需要通过扩展类来实现的细节，并将提供一些已经设置好的行为和属性。HttpServlet 是基于这两个更高模板的具体类。

我们知道 HttpServlet 实现了`init()`、`destroy()`和`service()`，因为顶层的接口要求它这样做。这是一个自顶向下的系统，顶层设计了扩展/实现类需要执行的行为和状态，底层的类提供了实现。

这是一个最佳实践，因为实现细节越多，整个继承链就越脆弱。如果我改变了顶部的某些东西，那种影响会波及到下面的所有东西。依赖倒置只把一个契约放在顶部，派生的对象自己决定实现细节。

汽车有一个基本的概念，斯巴鲁傲虎是汽车的一个具体实现。汽车是一个没有多少细节的模糊定义，斯巴鲁傲虎是一个有具体细节的具体定义。

# 结论

SOLID 是五个原则的集合，帮助开发人员创建可重用、可理解和易于维护的软件。了解并应用这些原则会让你成为一名更好的程序员。

快乐编码。