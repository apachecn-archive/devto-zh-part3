# 文件夹结构和框架:什么在施加控制？

> 原文：<https://dev.to/barryosull/folder-structure-and-frameworks-what-is-exerting-control-4kpi>

最近我一直在思考文件夹结构，特别是我们如何构建我们的 web 应用程序，以鼓励我们想要的设计，并使其他开发者能够探索和理解代码库。这一思路是由我们的一个应用程序面临的一个问题激发出来的，我很快就会谈到这个问题。

## 文件夹给出上下文

当我们打开一个应用程序时，文件夹结构是我们首先看到的，甚至在我们浏览 readme 之前。它传达了概念的层次结构，并希望它们如何相互关联。乱七八糟的文件夹弊大于利，尤其是当你不得不从一个文件夹跳到另一个文件夹时。选择正确的结构很重要，这就是为什么许多框架都有一个已经定义好的结构，这是一个你可以轻松构建的基础。

现在一些开发者提倡把你所有的代码放在一个单独的文件夹中，这个文件夹是“每个特性”的，例如控制器、数据库访问器、repos、配置等等...老实说，我从来没有见过这种工作，一旦你有超过 7 个类，它总是一团乱麻，分崩离析，所以我只是要立即忽略这个想法。

这样一来，让我们看看导致我们问题的文件夹结构。

## 现状

```
/app
    /Funding
        /App
        /Domain
        /Infra
/bootstrap
/config
/database
/public
/resources
/routes
/storage
/tests
/vendor 
```

这是我们的 web 应用程序的结构，正如你所看到的，这是一个相当标准的 Laravel 应用程序，唯一不同的是“app”文件夹结构的内部。

简单介绍一下背景，我们使用一个[干净的架构](https://barryosull.com/blog/cleaning-up-your-codebase-with-a-clean-architecture/) / [洋葱架构](https://www.codeguru.com/csharp/csharp/cs_misc/designtechniques/understanding-onion-architecture.html)来构建我们的代码库。我不会说得太详细，但这里有一个简单的概述:

**域:**系统的核心代码，对你正在解决的问题进行建模。不包含技术细节(例如，没有 SQL 或 DB 概念)，而是侧重于业务语言/概念。

**应用:**将域对象组成一个单一的业务操作(如 CreateUser)，允许域代码通过接口(如 NotificationService 或 UserRepository)与外部系统交互。

**基础设施:**领域/app 概念的实现。所有的技术细节和框架绑定都在这里。这是你将你的领域/应用程序代码粘合到技术概念上的地方，比如数据库和/或库。HTTP 控制器存在于此，因为它们是插入到域/应用程序代码中的技术概念。

这样做的主要原因是将您的系统从实现细节中分离出来，使其更容易设计、理解和测试。

## 问题

引发我反思文件夹结构的问题是高级文件夹“app”。“app”是 Laravel 为您的应用程序代码创建的默认文件夹(因此得名)。但是，您可以看到在“app”中有另一个名为“App”的文件夹。我们不喜欢这样，因为这意味着在一个层次结构中有两个同名的文件夹，尽管它们的用途不同。一个是框架的“应用”概念，另一个是为我们的“应用”定义的接口，即与框架和技术细节分离的输入和输出。这可能会令人困惑。

我们讨论过把文件夹的名字改得更清晰，因为“app”不是很好。我们迭代了几个名字，包括“组件”、“src”，甚至“代码”(我不是开玩笑)。这些都不合适。我们意识到更改名称会打破 Laravel 惯例，这会让新开发人员感到困惑。

这让我思考，为什么我们要让框架来控制这些呢？毕竟是实现细节。除此之外，我们的业务代码现在由框架代码包装和包含。这意味着我们的代码是系统的子集，尽管事实正好相反。这影响了我们的思维，并不断强化框架处于控制中的想法(尽管它不应该处于控制中)。

我看到开发人员在这个问题上花了很多时间，他们关注的是他们的业务概念如何融入框架，而不是相反。这导致每个概念都是通过框架的镜头来看的，混淆了概念，使人们更难理解意图。

仔细想想，这个结构打破了[依赖倒置原则](https://stackify.com/dependency-inversion-principle/)。我们有由细节(框架)控制的抽象(业务概念)。这肯定会引起问题。

相反，我喜欢一种结构，它鼓励我们为解决业务问题而编写的代码和我们用来完成工作的代码之间的分离。

那么，考虑到以上所有因素，我们将如何构建我们的代码库呢？(你大概能猜到我要说什么)。

## 新结构

```
/contexts
    /Funding
        /App
        /Domain
        /Fund
/framework
    /bootstrap
    /config
    /database
    /resources
    /routes
    /storage
/public
/tests
/vendor 
```

首先，你会注意到我们的“app”代码现在被称为“contexts”。通过将它命名为 contexts，我们可以非常清楚地看到，里面的代码正在为一个特定的子域解决一个特定的问题(这里有一些关于[有界上下文](https://martinfowler.com/bliki/BoundedContext.html)概念的细节)。随着应用程序的增长，我们将添加更多的上下文。“app”这个名字太普通了，而“contexts”直接给出了上下文(我为这个双关语感到抱歉)。

其次，您会注意到框架代码现在包含在它自己的文件夹结构中，独立于上下文。这就很清楚了，框架是一个细节，而不是系统的控制器。它是我们的上下文使用的一个组件(很像“供应商”文件夹)，而不是一个对我们的上下文施加设计控制的系统。

测试仍然在外面，因为测试代码应该耦合到上下文，而不是框架。您正在测试您的系统是否按预期工作，而不是框架是否按预期工作。这种结构鼓励这种思维，我相信这种思维会导致更好的系统设计(不要将测试代码直接耦合到框架)。

Public 位于根级别，因为它通常包含许多独立于框架的资源，唯一特定于框架/系统的是引导应用程序的索引页面中的代码，这不是捆绑它和所有其他资源(css、js、图像等)的足够好的理由...)对于框架来说，它确实是一个独立的东西。

实际上，我已经将依赖关系转化为文件夹结构，现在抽象(业务代码)不再包含在细节(框架)中。

## 结构要紧

你如何构建你的代码库会影响你对它的看法，我们在框架代码中构建应用程序代码的做法会导致问题。对于初级和高级开发人员来说，这种思维方式只会把水搅浑。

我用上面的结构的目的是非常清楚地表明上下文是应用程序的核心，而不是框架。这引导开发人员专注于编写可靠的上下文代码，从领域的角度而不是实现细节的角度来编写。我相信这种结构鼓励更好的设计，并帮助开发人员理解每个文件夹的区别和责任。简而言之，噪音更少，信号更多。

你呢？有什么有趣的结构可以分享吗？欢迎在下面的评论中留言或在 twitter 上给我发消息。