# 用太多的表格打破 Postgres

> 原文:[https://dev . to/kspeakman/breaking-postgres-with-too-many-tables-4pg 0](https://dev.to/kspeakman/breaking-postgres-with-too-many-tables-4pg0)

在之前的一篇文章中，我分享了一个关于多租户事件商店的策略。这里的策略是通过按租户划分事件来分解数据。一如既往，细节决定成败。我后来想到要考虑的一件事是这会支持多少租户。因为每个分区都是一个单独的表，所以我需要研究可以创建多少个表。

# [](#table-count-limit)表计数限制

从技术上讲，Postgres 对表格的数量没有限制。然而，每个表都是 OS 文件系统中的一个文件。并且操作系统可能对多少文件是“太多”有一些看法。特别是 Linux 有一个打开文件的限制。你可以用下面的命令查看它(在我的发行版中)。

```
cat /proc/sys/fs/file-max 
```

当我检查一个标准的 Amazon Linux EC2 t2.micro 实例时，它返回 96972。一些快速搜索告诉我，这个数字是根据内存量计算的。所以我想检查一个 RDS Postgres 实例。我无法访问 shell，所以测试它的唯一方法是创建表，直到它崩溃。当我在 AWS RDS Postgres 11 Preview 实例(也是 t2.micro)上测试时，我能够在崩溃前创建 130 万个表。

> 正如下面评论中指出的(感谢小文森特·米卢姆！)，我在这个实验中可能遇到的限制是 inode 限制。此限制基于文件系统的大小，而不是 RAM 的大小。
> 
> 关于 inode 限制的更多信息，请参见本文。

## [](#reaching-the-limit)达到极限

在我达到崩溃极限之前——在数万个表中——pg admin 的加载/刷新变得非常慢。为了支持有这么多表的数据库，我可能需要使用命令行工具。因为 GUI 工具倾向于预加载大量信息。

当我达到桌数上限时，*非常糟糕的事情*发生了。

最后的`CREATE TABLE`操作收到了这个错误(在客户端和日志中)。

```
53100: could not create file "<file path>": "No space left on device"` 
```

RDS 服务也注意到了这个问题，并在控制台中将 DB 实例状态标记为`storage-full`。我不知道你，但这个错误通常会让我认为存储驱动器已满。但事实并非如此。大约有 13GB 的可用空间。我用了大约 4GB 来创建空表！

真正糟糕的是，我编写的用于删除表的脚本无法再连接到 DB 实例。显然，每个连接都会创建临时表。因为不能创建新表，所以也不能建立连接。此外，Postgres 的一些内部进程使用临时表。例如，我在日志中看到统计数据计算失败，出现相同的错误。

幸运的是，我仍然在 pgAdmin 中打开了一个连接。所以我开始在那里发布`DROP TABLE`声明。在我的清理脚本可以再次连接之前，我必须删除大约 2000 个表。如果 pgAdmin 连接没有打开，数据库将无法运行。

这个故事的寓意是:超过这个限制**会破坏您的数据库实例**。

# [](#conclusion)结论

在这篇文章中，我想特别指出表计数的限制。许多其他类型的限制可能会降低性能(CPU/mem)，或者很容易修复/监控(存储空间)。但是表计数限制正在严重突破。因此，在考虑数据库组织策略时，请记住这个限制。