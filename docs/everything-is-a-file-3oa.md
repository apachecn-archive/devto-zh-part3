# 一切都是一个文件

> 原文：<https://dev.to/awwsmm/everything-is-a-file-3oa>

UNIX 和类 UNIX 操作系统的一个定义特性是“一切都是文件”[1](https://en.wikipedia.org/wiki/Everything_is_a_file)。*从操作系统的角度来看，文档、目录、链接、输入和输出设备等都只是字节流的汇点或来源[ [2](https://www.computerhope.com/jargon/f/file-descriptor.htm) ]。您可以使用命令
来验证目录只是一种特殊的文件

```
$ view /etc 
```

Enter fullscreen mode Exit fullscreen mode

...这将显示`/etc`文件(目录)的内容。注意，`view`是以只读模式运行`vi`的简写，`vi -R` [ [7](https://www.lifewire.com/view-linux-command-4093565) ]，所以你可以通过键入`:q!`来退出它。以文件形式打开目录时要非常小心——如果你不小心编辑了不该编辑的内容，会对你的系统造成严重的损害。在 Linux 文件系统上，`/dev`目录包含代表设备的文件，`/proc`包含代表进程和系统信息的特殊文件，等等:

```
$ ls -l /dev/std*
lrwxrwxrwx 1 root 15 Nov  3  2017 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx 1 root 15 Nov  3  2017 /dev/stdin -> /proc/self/fd/0
lrwxrwxrwx 1 root 15 Nov  3  2017 /dev/stdout -> /proc/self/fd/1

$ cat /proc/uptime  # shows current system uptime
36710671.21 1127406622.14

$ cat /dev/random  # returns randomly-generated bytes
{IGnh▒I 侨▒▒Ұ>j▒L▒▒%▒=▒▒U@▒Q▒2▒;▒l▒q▒$▒r▒1▒U񝾎... 
```

Enter fullscreen mode Exit fullscreen mode

其他常见的`/dev`文件包括`/dev/zero`和`/dev/null`，前者产生连续的零流，后者接受所有输入，但不做任何处理(把它想象成一个垃圾箱)[ [8](https://www.howtogeek.com/117939/htg-explains-what-everything-is-a-file-means-on-linux) 。请注意，“文件”可以在您每次打开它们时显示相同的信息，或者它们可能在不断变化——反映系统的当前状态，或者显示一些不断运行的过程的结果。

## 但是*为什么*在 UNIX 中一切都是文件？

正如 Dennis Ritchie 和 Ken Thompson 在他们 1974 年的 ACM 论文“UNIX 分时系统”中概述的那样，“一切都是一个文件”的方法有三个主要优点:

1.  文件和设备 I/O 尽可能相似
2.  文件名和设备名具有相同的语法和含义，因此可以向需要文件名作为参数的程序传递设备名
3.  特殊文件[ `/dev/random`等。]受到与常规文件相同的保护机制的保护

这种方法的优势在 1982 年贝尔实验室的视频中有所阐述，AWK 编程语言的创造者和 UNIX 的共同创造者 Brian Kernighan 在视频中描述了程序如何通过流水线化来减少不必要的代码重复(通过模块化)和增加灵活性(跳到 05:30):

[https://www.youtube.com/embed/tc4ROCJYbm0](https://www.youtube.com/embed/tc4ROCJYbm0)

```
$ makewords sentence | lowercase | sort | unique | mismatch 
```

Enter fullscreen mode Exit fullscreen mode

Kernighan 键入的代码如上所述。在其中，`makewords`将文本文件`sentence`分割成单词(由空白字符分隔)并每行返回一个单词。`makewords`被传递了一个文件作为输入，它的输出通常会被发送到终端，但是我们已经*通过管道*将它(使用`|`)作为下一个方法`lowercase`的输入。`lowercase`将每一行视为一个单独的参数，将所有大写字符转换为小写字符，然后将其输出传输到`sort`，后者按字母顺序对单词列表进行排序。`sort`将其输出传输到`unique`，T8 从列表中删除重复的单词，并将输出发送到`mismatch`，T9 根据字典文件检查唯一的、全小写的单词列表。默认情况下，任何拼写错误的单词(字典中没有的单词)都会打印到终端上。通过连接这五个独立的函数，我们很容易地创建了一个全新的对文件进行拼写检查的函数。

请注意，输入可以来自常规文件，也可以来自特殊文件，如磁盘和其他输入设备，如终端本身。输出可以发送到终端，或其他程序，或作为文件写入磁盘。这种将功能管道化在一起的能力，将文件、磁盘和特殊的 I/O 设备同等对待，相对于其他系统来说，极大地增强了 UNIX 的能力和灵活性，因为其他系统对这些东西的处理方式各不相同。

* * *

*这更正确的写法是“一切都是文件描述符或进程” [3](https://yarchive.net/comp/linux/everything_is_file.html) 。(文件描述符有时也称为“句柄”。)文件描述符是简单的非负索引，它涉及文件、目录、输入和输出设备等。【[5](https://www.computerhope.com/jargon/f/file-descriptor.htm)`stdin`、`stdout`、`stderr`的文件描述符分别为 0、1、2。这就是为什么当我们想要抑制错误输出时，我们用
将它(用`>`命令[ [4](https://www.computerhope.com/jargon/r/redirect.htm) ]重定向到`/dev/null`

```
$ command 2>/dev/null 
```

Enter fullscreen mode Exit fullscreen mode

我们可以将一个特定命令的所有输出(`stdout`和`stderr`)作为输入发送给另一个带有`2>&1 |`的命令，或者更简单地说，‘|&’[[6](https://www.computerhope.com/unix/ubash.htm#pipelines):

```
$ command1 2>&1 | command2
$ command1 |& command2 
```

Enter fullscreen mode Exit fullscreen mode

操作系统使用*索引节点*(索引节点)[ [10](https://en.wikipedia.org/wiki/Inode) ，将文件描述符映射到文件(字节在磁盘上的实际位置)。

进程[ [9](https://www.tecmint.com/linux-process-management) 与文件描述符是分开的。一个*进程*是一个当前正在执行的程序的实例。一个进程包含一个要执行的代码的*映像*(只读副本)、一些要在执行期间使用的内存和堆空间、相关的文件描述符等等。进程也有自己独立的索引系统(进程 id，或`pid`)。

* * *

### 相关:

[Linux 介绍(2008)，Machtelt Garrels](//ftp://ftp.wayne.edu/ldp/en/Intro-Linux/Intro-Linux.pdf)

[UNIX 流程简介(2014 年)，Brian Storti](https://www.brianstorti.com/an_introduction_to_unix_processes/)

UNIX 过去的幽灵:设计模式的历史探索(2010)，尼尔·布朗

[unix-history-repo(从 1970 年至今的连续 unix 提交历史)](https://github.com/dspinellis/unix-history-repo)