# 测试驱动

> 原文:[https://dev.to/geewiz/test-driven-1623](https://dev.to/geewiz/test-driven-1623)

测试驱动开发(TDD)的概念已经不是什么新鲜事了。但是，即使在我的代码(不管是 Rails 应用程序还是 Chef infra 代码)伴随测试好几年之后，TDD 仍然远远不是我的第二天性。我最近看了 RubyHACK 2018 的一个演讲，激励我在这方面做得更好。

在他的演讲“关于测试的一些谎言的一些真相”中，David Brady 解释了为什么我们中的许多人发现很难首先构建测试，然后实现实际的业务逻辑:我们中的大多数人学习编程的方式是立即处理实现。实际上，这就是我们学习解决问题的一般方法:拿一个问题，把它分解成可管理的小块，然后一点一点地建立解决方案。最终，该解决方案将交付预期的结果。或者可能不会，这是我们开始测试的时候，以找出我们的哪些部分没有按照它应该的方式运行。

在他的演讲中，David 将这种方法称为“开发后测试”(TAD)或“Q3 开发”，因为*知道实现，但不知道期望的行为看起来是什么样子*是两个轴“行为已知/未知”和“实现已知/未知”之间的象限 III。

*   象限一:行为已知，实施已知
*   象限二:行为已知，实施未知
*   象限三:行为未知，实施已知
*   象限四:行为未知，实施未知

很明显，测试驱动的开发通常是象限 II:我已经清楚地定义了我想要的行为，并且正在实现它。

David 也很好地解释了为什么我经常不得不强迫自己至少为我的实现花费*的精力来构建测试，如果不是在我的实现*之前花费*的话。泰德给你即时的满足感。您看到您的代码做了一些事情，使您更接近解决方案，如果不是全部的话。问题是，这种开发方法可能开始很容易，但随着代码库的增长会变得越来越难。David 提到了导致一行代码的变更是如何花了他们将近两天的时间来实现的。*

然而，TDD 在未来的某个时候会有回报。当然，开始很难，但随着时间的推移会变得容易，因为你可以越来越依赖你的测试来指导你。

当我进行测试时，我可以做出改变，如果不是更有效的话，那么至少更有信心，我不会不小心弄坏东西。与解开似乎与我最近的变化完全无关但却突然表现奇怪的代码的痛苦相比，花在构建测试上的时间是一项更好的投资。而每天安心部署代码的经历，足以成为我一步一步进入象限 II 的理由。

看大卫的演讲，我发现它既有趣又鼓舞人心！