# 在 C#中使 ToString()可读

> 原文:[https://dev . to/calucon/make-tostring-human-readable-in-c-4m 18](https://dev.to/calucon/make-tostring-human-readable-in-c-4m18)

# kot Lin 中的数据类

如果你曾经使用过 Kotlin 并且它是`data class`，我敢肯定你在调用`ToString()`方法时偶然发现了它的一个惊人的特性。

> *本文中的术语`DataClass`只是指我自己实现的覆盖`ToString()`方法和* ***而不是****kot Lin`data class`的任何其他功能！我这边命名不好。*

基本上，它所做的是以人类可读的格式在一个类中呈现数据。下面是 Kotlin 中的一个例子，显示了这两种类型:

```
class Person(val name: String, val age: Int)
// toString -> de.calucon.sample.Person@63e31ee

data class Person(val name: String, val age: Int)
// toString -> Person(name=Simon, age=21) 
```

# [](#potential-usage)潜在用法

在某些情况下，这可能是一个非常有用的特性，尤其是在开发过程中。当然，您可以使用集成调试器，它可以显示每个变量及其成员，但为此，您还必须暂停应用程序的执行。这对你有什么好处取决于你正在做什么类型的项目。

我目前正在开发一个 WPF 应用程序，它从与服务器的 TCP 连接中获取数据。在尝试中断应用程序时，将来自 TCP 套接字的解析数据打印到调试窗口是一个巨大的好处，因为我能够观察到是否传输了正确的数据，或者数据是否没有到达发送器。

# [](#data-class-implementation-in-c)数据类在 C#中的实现

默认情况下，C#不像 Kotlin 那样提供`data class`。
这是它在 C#中使用类或结构时的样子:

```
public class Person
{
    public string Name;
    public int Age;
}

var person = new Person()
{
    Name = "Simon",
    Age = 21
};

Console.WriteLine("Person: {0}", person);
// Console Output: Person: Calucon.Sample.Person 
```

`Console.Write`所做的是为每个对象/参数调用`ToString()`方法。
我们现在可以覆盖每个类的默认`ToString()`方法，并返回一个看起来像 Kotlin 的字符串，但这可能非常耗时，而且我们必须应对一个大敌人:变量名的重构。这迫使我们更改`ToString()`方法的返回值，以使新的字段/属性名称与输出相匹配。

# [](#implementation)实现

**首先——**使用反射
从我们的`Person`类中查询所有的`fields`和`properties`

```
// define which fields/properties to get
var flags = BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;

foreach (var prop in GetType().GetProperties(flags))
{
    // code...
}

foreach (var field in GetType().GetFields(flags))
{
    // code...
} 
```

**第二-**获取字段/属性名及其值
*(代码在上面的`foreach`循环中)*

```
// Property
string name = prop.Name;
object val = prop.GetValue(this);

// Field
string name = field.Name;
object val = field.GetValue(this); 
```

`GetType()`返回实现我们的`DataClass`的类的类型，因此关键字`this`指的是实现我们的`DataClass`的类。

**第三-**让它看起来像科特林

Kotlin 默认的样子是这样的:
`Type(field0=value0, field1=value1, ...)`

```
private void Analyze(ref StringBuilder sb, string name, object val)
{
    sb.AppendFormat("{0}={1}, ", name, val);
} 
```

这基本上就可以了，但是 Kotlin 也可以翻译数组、列表等。
在 C#中我们有一个接口`ICollection`，我们将使用它来识别数组、列表、字典……

```
private void Analyze(ref StringBuilder sb, string name, object val)
{
    // if it's an ICollection, parse the collection
    if (val is ICollection) val = ConvertCollection(val as ICollection);
    sb.AppendFormat("{0}={1}, ", name, val);
}

// Analyze any ICollection
private string ConvertCollection(ICollection enumerable)
{
    var sb = new StringBuilder();
    foreach (var item in enumerable) 
    {
        sb.AppendFormat("{0}, ", item);
    }
    var data = sb.ToString().TrimEnd(',', ' '); // remove trailing ', '
    return string.Format("[{0}]", data);
} 
```

**第四-**排除编译器创建的字段
*。NET 会在编译期间生成一些仅供内部使用的字段。通过使用反射，我们也可以揭示这些，但是它们并没有给我们提供任何有用的东西。*
*它们可能是这样的:* `<Array>k__BackingField`

```
private void Analyze(ref StringBuilder sb, string name, object val)
{
    // exclude fields generated by the compiler
    if (name.EndsWith("k__BackingField")) return;
    if (val is ICollection) val = ConvertCollection(val as ICollection);
    sb.AppendFormat("{0}={1}, ", name, val);
} 
```

**第五-**创建我们的`DataClass`，它覆盖了`ToString()`方法
*在这个例子中，我们覆盖了默认的* `CultureInfo` *到* `InvariantCulture` *来补偿不同的数字格式。*T13】

```
public class DataClass
{
    public override string ToString()
    {
        // store current culture and override it with InvariantCulture
        var currentCulture = CultureInfo.CurrentCulture;
        CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;

        var sb = new StringBuilder();
        // code from 'First' and 'Second'

        // reset culture info
        CultureInfo.CurrentCulture = currentCulture;

        // return final string and remove traling ', ' from the StringBuilder
        return string.Format("{0}({1})", 
            GetType().Name, 
            sb.ToString().TrimEnd(',', ' ')
        );
    }

    private void Analyze(ref StringBuilder sb, string name, object val)
    {
        // code from 'Fourth'
    }

    private string ConvertCollection(ICollection enumerable)
    {
        // code from 'Third'
    }
} 
```

* * *

# [](#codecomparison)代码对比

#### [釜底抽薪](#kotlin)

```
data class Person(val name: String, val age: Int)
// toString -> Person(name=Simon, age=21) 
```

#### [](#c)C#

```
public class Person
{
    public string name;
    public int age;
}
// toString -> Person(name=Simon, age=21) 
```

* * *

# [](#dataclass-sourcecode)DataClass 源代码

你可以从我的 Gitlab [**这里**](https://gitlab.com/snippets/1860946) 获得完全工作类

*   编译器自动生成的字段被排除在外
*   实现`ICollection`的对象被自动处理。这包括像*数组、列表、字典、…* 这样的对象
*   数字用的`InvarriantCulture`表示。网

默认情况下，它还包括`static`字段和属性。如果您想删除它们，只需编辑代码片段:
中第 9 行**上的`DataClass`**

```
// with static fields/properties
var flags = BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;

// without static fields/properties
var flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance; 
```

* * *

# [](#final-thoughts)最后的想法

有时，我觉得我是唯一一个有时更喜欢以人类可读的格式打印所有/一些变量的人。我真的很好奇你们中有多少人有时会有同样的想法，并覆盖默认的`ToString()`方法。我很高兴这至少能帮助一个人:)

这也是我的第一篇博客。我将非常感谢你给我的任何反馈，以进一步提高我的写作<3
T3】你可以在这里阅读原文。