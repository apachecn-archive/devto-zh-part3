# 删除 Swift 代码如何让你成为更有价值的 iOS 开发者——干净的 iOS 代码库系列

> 原文：<https://dev.to/essentialdeveloper/how-deleting-swift-code-can-make-you-a-more-valuable-ios-developer-clean-ios-codebase-series-1jgo>

开发和维护一个干净的 iOS 代码库的能力对于成为一名出色的 iOS 开发人员至关重要。

您可以采取的一个简单但非常有价值的行动是删除未使用的代码——毫不留情。

同时，我们遇到许多开发人员害怕删除代码*，因为他们可能在未来需要它*。

今天，您将了解从 *git* 存储库中检索删除代码的两种方法，以及提交的良好实践如何促进干净的 iOS 代码库的维护。

## 提交的良好实践

我们教导我们的学生和学员用清晰的描述性信息将他们的改变分解成微小/简洁的承诺。

微小的、单一焦点的、带有详细消息的提交:

1.  使代码更容易审查、更改和维护。
2.  作为文件。
3.  简化并降低撤销变更的成本。

我们建议您在每次代码库的行为或状态发生变化时提交，同时保持绿色状态(所有测试都通过)，不管变化有多小(越小越好)。

因此，您将处理更小和风险更低的更改，并且变得更具适应性，因为您可以自由地探索解决方案、回复和恢复他们的更改。

通常，两个是每次提交更改文件的理想数量，因为我们同时编写生产代码和测试。重构通常只提交对一个文件的更改，但是当我们更改一个公共接口时，偶尔可能会影响更多的文件。

组件之间的紧密耦合通常会阻止开发人员以小块的方式进行开发。因此，每次提交只编辑少量文件的能力可以表明系统组件之间存在积极的松散耦合关系！

换句话说，用良好的抽象设计的系统允许您在不影响其他组件的情况下更改特定组件，使代码库的更改更容易、更快、风险更小。相反，糟糕的抽象将迫使你同时编辑多个组件，在不同的文件中，即使是很小的改变(增加了错误和合并冲突的风险，减慢了团队的速度)。

## 恢复提交

如果您遵循*提交*良好实践(带有描述性消息的简明变更)，恢复变更将变得非常简单和便宜——接近零撤销成本！

例如，在基础开发人员学院的持久性模块:iOS Lead 基础课程中，我们演示了如何创建灵活的抽象来无缝替换任何底层缓存机制。

通过使用该抽象，我们创建了两个生产就绪的缓存实现:

1.  由使用`FileManager`的文件系统支持的`Codable`实现。
2.  具有持久的`SQLite`存储的`Core Data`实现。

尽管这两种解决方案都能很好地工作和执行，但我们需要一个单一的持久性实现。`Core Data`更适合我们在课程中创建的应用程序；因此，我们大胆地选择删除`Codable`实现。

我们将文件删除捆绑在一个简洁的单焦点提交中，仅包含:

*   删除`Codable`商店实施的生产文件
*   删除`Codable`存储实现的测试文件
*   Xcode 在项目结构中所做的任何更改

此外，提交保存了描述更改的以下消息:

> “删除`CodableFeedStore`以支持`CoreDataFeedStore`(我们在这个项目中只需要一个)。当然，如果需要的话，我们可以回复这个提交并恢复`Codable`实现。”

通过在提交中只包含**最少的必要更改(如删除文件或变量重命名)，您可以在需要时快速`revert`特定的更改。为此，只需要您想要恢复的提交的散列。**

要恢复提交，只需运行`git revert <commit hash>`。然后 Git 将创建一个新的提交，恢复由给定的提交散列引入的更改。Git 将提示您使用恢复的更改编辑新提交的默认消息。默认消息是:

> 回复"< given commit message >"

如果您愿意使用默认消息，您可以通过运行`git revert <commit hash> --no-edit`来跳过编辑。注意`--no-edit`标志告诉 git 您不希望编辑新的提交消息。

在开发 iOS 应用的过程中，你会做出很多决定，比如删除代码。你应该能够自由地改变你的想法，并以最小的摩擦和成本恢复变化。

在我们的案例中，我们知道我们可能会改变主意，决定恢复`Codable`商店。因此，我们只能*无畏地*做出这种改变，因为这种改变很容易撤销(低成本)。很容易撤销，因为我们已经创建了:

1.  一个灵活的抽象，将我们的生产和测试代码从具体的后台存储中分离出来。
2.  代码删除的简明—单一焦点—提交。

> 一个简洁的 git 历史，加上精心编写的消息，可以帮助开发人员理解变更的历史，创建代码的三维视图，其中时间成为我们可以旅行的轴。

## 从杂乱的提交中提取删除的文件

具有包含许多*非特定变更*的贡献的 *git 历史*每一次提交都会使回复一个*特定变更*变得非常困难(或者不可能！).

例如，如果提交还引入了重要的业务逻辑变更，您将无法快速恢复*仅*一个被删除的文件。如果您试图恢复提交，您还会恢复重要的业务逻辑更改(这可能是您不想做的！).

当在提交中恢复特定的文件删除(简单的方法)不可行时，您可以使用一种替代技术，通过扩大您对已删除文件的搜索范围(困难的方法)。

在下面的过程中，您将学习如何找到被删除的文件，检查和恢复它们。当然，您可以定制这个过程，并根据您的需要优化您的工作流程。

### 1。*获取存储库中所有已删除文件的列表*:

`git log --diff-filter=D --summary | grep delete`

`--diff-filter=D`参数告诉 git 只选择被删除的文件，而`--summary`标志指示 git 格式化输出，以包含包括模式更改的扩展头信息的压缩摘要，然后我们可以用`grep`过滤打印的删除内容。

该命令将产生所有已删除文件的完整路径。在那里，您可以找到要恢复的文件的完整路径，这是后续步骤所必需的。

### 2。*获取包含被删除文件的所有提交的列表*:

`git log --all --full-history -- <file path>`

首先，当键入命令时，确保在`--`和文件路径之间添加一个空格，因为破折号表示分隔符，而不是该命令的参数。

上面的命令将产生包含被删除文件的所有提交的列表。

`--all`和`--full-history`标志告诉 git 搜索**所有包含引用被删除文件的提交的分支**，而不仅仅是当前分支。当在团队和大规模项目中工作时，这个功能很方便，因为在存储库中创建了多个分支，并且您知道您不是唯一一个在代码库中进行更改的人。不包括`--all`和`--full-history`选项，你可能会错过你没有意识到的重大变化。

### 3。*找到你想要的文件版本，并显示其内容*:

现在您已经有了被删除的提交的散列和您想要恢复的文件的文件路径，您可以请求 git 向您展示该文件以查看其内容。只需运行:

`git show <commit hash> -- <file path>`

同样，确保在`--`和文件路径之间添加一个空格。

这是一个可选步骤，但是对于验证您正在恢复正确的文件来说是必不可少的！

### 4。*将删除的文件恢复到你的工作目录*:

`git checkout <commit hash>^ -- <file path>`

通过运行上面的命令，git 将**恢复**和**阶段**添加新文件及其内容到您当前的工作目录。

脱字符号(^)表示将使用给定提交的父代。这是因为，在给定的提交中，文件保持删除状态，这意味着它不存在；因此，您需要指示 git 在 it(父)获取丢失的文件之前查看提交*。*

## “可是我不用 git 啊！”

不管您使用什么版本控制系统，您都可以应用这些简单但必要的技术来维护一个干净的 iOS 代码库。

目标是将你的贡献分成小而简洁的批次，这样你就可以很容易地操作它们了！

## 维护干净的 iOS 代码库

干净的 iOS 代码库由经过深思熟虑的提交序列组成。

通过规范您的贡献并保持代码库整洁有序，您可以在前进的过程中获得不同程度的自由，例如轻松地审查、维护、删除和恢复代码。

不幸的是，我们看到许多代码库不必要地携带未使用的代码。“死”代码增加了每次构建和测试运行的时间开销。此外，未使用的代码可能会给新团队成员带来很大的困惑，因为他们必须研究它的引用或询问其他团队成员它在代码库中的使用和存在情况。

作为一名专业的 iOS 开发者，你也是一名风险管理者。通过积极地思考你未来的需求，花几秒钟的时间合理地组织你的贡献，你和你的团队从长远来看节省了几个小时的痛苦和浪费！