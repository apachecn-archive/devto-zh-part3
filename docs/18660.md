# 具有(静态)强制顺序的消息传递模式？

> 原文:[https://dev . to/mind play/messaging-pattern-with-static-enforced-order-2o 5](https://dev.to/mindplay/messaging-pattern-with-statically-enforced-order-2o5)

我正试图为一组以流的方式传递的消息/事件设计一个 API。

具体来说，我正在构建一个测试框架，并且我想要分离后端监听器(比如 XML 报告器、控制台报告器、代码覆盖报告器等)。)使得它们实现一个接口(或一组接口),该接口使测试框架能够发送一组固定的/已知的消息类型，这些消息类型以定义的有效顺序出现。

例如:

*   开始测试套件 A
*   开始测试案例 1
*   日志断言结果 X
*   日志断言结果 Y
*   结束测试案例 1
*   开始测试案例 2
*   日志断言结果 Z
*   结束测试案例 2
*   结束测试套件 A
*   开始测试套件 B
*   ...

换句话说，这些消息有一个必要的顺序:测试用例不能在测试套件开始之前开始，每个测试用例必须在开始新的测试用例之前结束，断言结果必须在有活动测试用例时记录，等等。

我的第一次尝试是一组[接口](https://bitbucket.org/mindplaydk/test-interop/src/3219cd25de13b6d333d43b74744f1a5dae1b8f80/src/?at=master)，我在这里的想法是，在你启动测试套件之前，你不能启动测试用例，因为这是你获得测试用例监听器的方式，在你启动测试用例之前，你不能提交断言结果，等等。

不过，这种方法只实施了一个规则，确保您不能在发布另一个给定类型的消息之前发布一个特定类型的消息——例如，没有任何东西可以保证客户端代码不只是引用先前的测试用例，并且不按顺序提交断言结果。也没有什么能保证你调用`end()`方法来关闭一个测试套件或用例。所以这真的行不通。

我能想到的唯一替代方法是更传统的事件流——其中每种消息类型都是一个扩展标记接口的接口，所有消息都通过相同的方法提交给总线，总线将消息分发给侦听器。

这可能更容易实现和理解，并且避免了客户端代码引用以前的侦听器的问题，因为提交消息只有一种方式。我可以编写这样一个侦听器的标准实现，它简单地验证消息顺序，框架可以在内部将这样一个实例放在用户提供的侦听器列表之前。

这可能更简单、更清晰，但是您当然仍然会以错误的顺序提交消息——消息顺序仍然需要在运行时进行验证。

有没有哪种消息模式是*静态地*强制消息顺序的？