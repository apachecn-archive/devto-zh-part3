# 迭代器设计模式[行为]

> 原文:[https://dev . to/its coders life/iterator-design-pattern-behavioral-2fhl](https://dev.to/itscoderslife/iterator-design-pattern-behavioral-2fhl)

**为什么？**遍历容器中的物体。

有不同的结构让我们以结构化的格式存储数据。数据结构应该提供一种遍历其元素的方法。我们可以想出不同的解决方案来顺序访问它们的元素。结果，这些数据结构的接口将被不同遍历器的操作弄得混乱不堪，并且这些操作将因类型而异，这反过来又使它们难以使用和维护。

迭代器模式解决了这个问题。它为遍历不同类型的聚集对象提供了一个标准接口。迭代器将访问和遍历逻辑封装在一个单独的类型中；因此，它从数据结构中移除了这些职责。所以我们不必暴露底层数据结构的任何细节来迭代它的元素。

*   提供对聚合对象元素的顺序访问。
*   将不同遍历的操作封装到专用的迭代器类型中。
*   不公开被遍历对象的内部结构。
*   迭代器必须跟踪被遍历的元素。
*   调用它的 *next* 方法返回当前元素，它在序列中前进一步。
*   迭代器模式是最常用的模式之一。

> 迭代器提供对容器元素的顺序访问，而不暴露其底层细节。它从数据结构本身中删除了不同遍历的操作。

现在，让我们看看迭代器模式的设计。在大多数语言中，所有内置的集合类型，数组、集合和字典，都符合一个序列接口/协议。如果我们需要遍历它们的元素，我们的自定义类型也必须采用该接口。

迭代器协议提供了一个统一的接口，用于一次一个地访问序列中的项目。方法前进到序列中的下一个元素并返回它。实际上，每当我们依赖 for-in 循环来遍历给定类型的项时，我们都在使用它的迭代器。

例子:栈，队列，链表，数组等等都有迭代器。

这是一个简单的遍历数组元素的例子。编译器生成以下代码。它首先通过调用数组的 make 迭代器方法创建一个迭代器。然后，while 循环调用下一个的迭代器*。当*下一个*方法没有返回有效值时，循环退出。在实现定制迭代器时，了解这些细节非常重要。我们的 *next* 方法实现也必须返回 nil 或一个无效值，以表示序列结束；否则，循环将永远继续下去。*

始终考虑迭代器实现的性能影响。下一个方法不得执行缓慢或计算密集型操作。