# 关于图形 API 和图形库的思考

> 原文：<https://dev.to/reg__/thoughts-on-graphics-apis-and-libraries-4lcd>

警告:这是一个长篇大论。我想分享一下我个人对 Vulkan，Direct3D 12 这样的图形 API 的想法和看法。

不久前，我想出了一个图表，展示了图形软件技术在过去几十年中是如何发展的——参见我的博客文章[“低级图形 API——这是什么意思？”](http://asawicki.info/news_1601_lower-level_graphics_api_-_what_does_it_mean.html)。新的图形 API(direct 3d 12、Vulkan、Metal)不仅是一个干净的开始，因此它们抛弃了所有可以追溯到 90 年代的遗留垃圾(如`glVertex`)，而且它们还将图形编程带到了一个新的水平。这是一个较低的层次——它们更明确，更接近硬件，更符合现代 GPU 的工作方式。至少是这个想法。这意味着更简单、更高效、更不容易出错的驱动程序。但它们并没有让游戏或引擎编程变得更简单。恰恰相反——现在更多的责任转移到了引擎开发人员身上(例如内存管理/分配)。总的来说，这通常被认为是一件好事，因为引擎对其用例有更高层次的了解(例如，哪些纹理至关重要，哪些纹理可以在 GPU 内存满时卸载)，所以它可以通过正确地执行它来获得更好的性能。无论如何，所有这些都隐藏在引擎中，所以开发他们游戏的开发者不会注意到不同。

你们中的一些人——就像我一样——在日常工作中处理那些低级图形 API，可能想知道这些 API 是否提供了正确的抽象级别。我知道这听起来会有争议，但有时我感觉它们处于最差的水平——低到难以学习和正确使用，而高到仍然隐藏了一些对获得良好性能很重要的实现细节。我们以图像/纹理障碍为例。它们在以前的 API 中是不存在的。现在我们不得不这样做，这是将旧代码移植到新 API 时的一个主要痛点。如果做得太少，就会在一些 GPU 上出现图形损坏，而在其他 GPU 上则不会。做得太多，你的表现可能会比在 DX11 或 OGL 更差。同时，它们是一个抽象的概念，仍然隐藏着发生在引擎盖下的多种事情。你永远无法确定哪个障碍会刷新一些缓存，停止整个图形管道，或者在特定 GPU 上的[内部压缩格式](https://gpuopen.com/dcc-overview/)之间转换你的纹理，除非你使用一些专门的，特定于供应商的分析工具，如[镭龙 GPU Profiler (RGP)](https://github.com/GPUOpen-Tools/Radeon-GPUProfiler) 。

记忆也是一样。在 DX11 中，你可以只指定预期的资源使用(`D3D11_USAGE_IMMUTABLE`，`D3D11_USAGE_DYNAMIC`)，驱动程序为它选择首选位置。在 Vulkan 中，您必须查询当前 GPU 上可用的内存堆，并根据低级标志(如`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`、`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`等)明确选择您认为最适合您的资源的内存堆。 [AMD](https://vulkan.gpuinfo.org/displayreport.php?id=5148#memory) 曝光 4 种内存类型，3 种内存堆。 [Nvidia](https://vulkan.gpuinfo.org/displayreport.php?id=5168#memory) 有 11 个类型，2 个堆。[英特尔集成显卡](https://vulkan.gpuinfo.org/displayreport.php?id=5169#memorytypes)仅暴露 1 个堆和 2 种类型，显示内存真正统一，而 [AMD APU](https://vulkan.gpuinfo.org/displayreport.php?id=5026#memory) 也是集成的，内存型号与独立卡相同。如果您试图将这些与您所知道的物理上现有的视频 RAM 和系统 RAM 进行匹配，这没有任何意义。你可以选择第一个`DEVICE_LOCAL`内存来实现最快的 GPU 访问，但即使这样，你也不能保证你的资源会留在显存中。它可能会在您不知道和不同意的情况下悄悄迁移到系统 RAM 中(例如，如果内存不足)，这会降低性能。更重要的是，没有办法在 Vulkan 中查询空闲 GPU 内存的数量，除非您使用 DXGI 进行类似[的攻击。](http://asawicki.info/news_1695_there_is_a_way_to_query_gpu_memory_usage_in_vulkan_-_use_dxgi.html)

硬件队列也好不到哪里去。Vulkan 声称提供了对 GPU 硬件的显式访问，因此您需要查询可用的队列。例如，[英特尔](https://vulkan.gpuinfo.org/displayreport.php?id=5169#queuefamilies)仅公开一个图形队列。 [AMD](https://vulkan.gpuinfo.org/displayreport.php?id=5148#queuefamilies) 允许您创建多达 3 个额外的纯计算队列和 2 个传输队列。 [Nvidia](https://vulkan.gpuinfo.org/displayreport.php?id=5168#queuefamilies) 有 8 个计算队列和 1 个传输队列。它们真的都映射到可以并行工作的硅片上吗？我表示怀疑。那么使用多少才能获得最佳性能呢？仅仅用 Vulkan API 是没办法分辨的。AMD 提倡在 3D 渲染的同时进行计算工作，而 Nvidia 则委婉地建议要“意识到”这一点。

有人可能会说，新的 API 并没有实现它们的承诺，即低级、明确和具有可预测的性能。这是不可能的，除非 API 是特定于一个 GPU 的，就像游戏机上的一样。不同 GPU 上的一个通用 API 永远是高级的，事情发生在引擎盖下，还是有快慢路径的。所有这些复杂性难道不是徒劳的吗？与上一代 API 相比，新一代 API 的驱动程序不需要在后台启动额外的线程，也不需要在第一次绘制调用时执行着色器编译，这大大降低了出现重大问题的几率。(随着 API 和驱动程序的发展，我们将看到这种状态会持续多久。)仍然没有办法预测或确保最小 FPS/最大帧时间。我们讨论的是多个进程竞争资源的系统。在现代的 pc 机上，甚至没有办法知道一条指令需要多少个周期！高速缓存、分支预测、无序执行–CPU 中的所有这些机制都是为了加速一般情况，但总会有运行缓慢的情况(例如缓存未命中)。图形也是一样。我认为我们应该放弃对可预测性能的错误希望，就像[呈现像素级完美的图形](http://asawicki.info/news_1692_scaling_is_everywhere_pixel-perfect_is_the_past.html)一样。我们可以优化平均值，但不能确保最小值。毕竟游戏是“软实时系统”。

基于此，我在想，是否有一个新的图形 API 或 DX12 或 Vulkan 顶部的空间。我不是指整个游戏引擎，包括物理模拟、声音处理、输入控制器等等，比如 Unity 或者 UE4。我指的是一个类似 DX11 或 OGL 的 API，在一个相似或更高的抽象层次上(如果是更高的层次，也许具有显式传递和资源依赖的持久“框架图”的概念才是正确的方向？).我也认为仅仅重新实现这些旧的 API 是不够的。新的 API 应该利用显式 API 的特性(比如并行命令缓冲区记录)，同时隐藏困难的部分(比如队列、内存类型、描述符、障碍)，因此更容易使用，更难误用。(类似这个概念的现有库是 AMD 的 [V-EZ](https://github.com/GPUOpen-LibrariesAndSDKs/V-EZ) 。)我觉得可能还是有不错的表现。创建这样的库所需要的关键是放弃这样的假设，即开发人员必须预先定义一切，在第一次使用时不分配、创建或转移任何东西。