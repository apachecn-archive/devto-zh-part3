# C++参考

> 原文:[https://dev.to/noah11012/c-references-5ghm](https://dev.to/noah11012/c-references-5ghm)

C++向后兼容 C，所以它继承了指针。如果你不知道指针是什么，快速回顾一下:指针是一个保存对象内存地址的变量。声明指针涉及到我们所指向的对象类型和符号' * '。

示例:

```
int value = 10;
int *ptr_value = &value;

double vaule2 = 506.305;
double *ptr_value2 = &value; 
```

我们有了指针，但是我们如何得到对象的内存地址呢？和符号(&)。

为了通过指针访问数据，我们需要做所谓的解引用。这也包括*符号的使用。

```
printf("value: %d\n", *ptr_value);
printf("value2: %f\n, *ptr_value2); 
```

现在，总结已经结束，我们可以转到参考。

C++引入了引用作为指针的替代。参考文献被设计成在使用时更简单、更安全、更容易阅读。创建一个引用类似于我们声明一个指针。首先，我们需要类型和符号' & '。

```
int value = 200;
int &ref_value = value; 
```

注意，我们在右边没有任何额外的东西，就像指针一样。该语句中唯一的额外符号是左边的&符号。

当需要从引用中检索值时，另一个好处是显而易见的:

```
std::cout << ref_value << "\n"; 
```

代码中没有多余的符号。查看解引用指针的小例子可能不会显示当查看在短时间内有几个解引用发生的较大代码块时可能会给某人带来的认知负担。

如前所述，引用更安全。回到指针，指针可以处于“无效”状态。这可能意味着两件事:

1.  指针已声明，但没有初始值设定项，随后被默认初始化

在局部范围内，如果变量在创建时没有提供初始值，则垃圾值会留在那里。最有可能的是，我们现在所占据的，是以前记忆中遗留下来的一些价值。访问默认初始化的对象是未定义的行为，取消引用默认初始化的指针也是未定义的行为。

1.  空指针

空指针是一种特殊的指针。通常，这是一种方式说，“嘿，我现在没有在使用，但我仍然是显式初始化！”。空指针在 API 设计中有一席之地。许多返回指针的 C 函数可能在出错时返回一个空指针。尽管它比前一种类型的无效指针“更安全”,但取消引用空指针是未定义的行为。

在创建引用时，它必须有一个要绑定的初始值。不这样做就是编译时错误。此外，引用在其整个生命周期内绑定到一个值。

然而，参考文献也有其弱点。像指针一样，引用也可以“悬空”:引用一个被释放的内存空间。

示例:

```
int &return_five()
{
    int value = 5;
    return &value;
}

int some_value = return_five();
std::cout << some_value << '\n'; // undefined behavior 
```

`return_five()`是创建变量并返回变量的函数。对于没有经验的人来说，这可能是无辜的，但是这个程序是错误的。返回的这个值是在堆栈上创建的，当函数返回时，堆栈框架被销毁，里面的变量也被销毁。

当我们返回 main 函数时，引用`some_value`现在指向释放的内存，并且是一个悬空引用。

## [](#the-conclusion)结论

理论上，在某些方面，引用是指针的更好替代。在创建和访问有界值时提供更简单的语法。适当的约束消除了使用指针可能出现的一些问题。